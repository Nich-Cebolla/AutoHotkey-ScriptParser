
#SingleInstance force
#include ..\src\VENV.ahk

; Paste your own script path in to the Demo() call, or leave it as the demo script path.
; If you want `ScriptParser` to recursively process #included scripts, pass a
; `ScriptParser_GetIncluded` object to the second parameter of `Demo`. See src\ScriptParser_GetIncluded.ahk
; for details.
; For long scripts, it will take a little bit to load.

Demo('test-content\UIA.ahk')

class Demo {
    static __New() {
        this.DeleteProp('__New')
        for item in [ 'Expand partial (&I)', 'Expand recursive (&X)', 'Expand all recursive (&Z)' ] {
            TreeViewEx_ContextMenu.Prototype.DefaultItems.Remove(item)
        }
    }
    static Call(Path, GetIncludedObj?, Encoding?) {
        ptm := PropsInfoTree_PropsTypeMap([
                { Type: 'ScriptParser', List: '__ConsecutiveDoubleReplacement,__ConsecutiveSingleReplacement,__LoneSemicolonReplacement,__CollectionList,__CollectionIndex,EndOfLine,__Content,Options,__Text', AddToDefault: true }
              , {
                    Type: [
                        'ScriptParser_Ahk.Component.CommentBlock',  'ScriptParser_Ahk.Component.CommentMultiline'
                      , 'ScriptParser_Ahk.Component.CommentSingleline',  'ScriptParser_Ahk.Component.Getter',  'ScriptParser_Ahk.Component.InstanceMethod'
                      , 'ScriptParser_Ahk.Component.InstanceProperty',  'ScriptParser_Ahk.Component.Jsdoc',  'ScriptParser_Ahk.Component.Setter'
                      , 'ScriptParser_Ahk.Component.StaticProperty',  'ScriptParser_Ahk.Component.String', 'ScriptParser_Ahk.Component.Class'
                      , 'ScriptParser_Ahk.Component.StaticMethod', 'ScriptParser_Ahk.Component.Function'
                    ]
                  , List:  'Collection,__Comment,__CommentParent,__Removed'
                  , AddToDefault: true
                }
              , { Type: [ 'ScriptParser_JsdocCollection', 'ScriptParser_ComponentCollection' ], List: '__ComponentIndex,__MaxComponentIndex,__ComponentBase,__Constructor,Default', AddToDefault: true }
              , { Type: 'ScriptParser_RemovedCollection', List: '__Index,__MaxCode,__CharCode,__CharMaxCode,__CharStartCode,Default', AddToDefault: true }
            ]
          , '__idc,__idr,__idu,Script,__ParentIdu,__Stack,IdScriptParser,IndexCollection,__Text,__ComponentIdu,__TextBody,__TextOwn'
        )
        pitOpt := this.PropsInfoTreeOptions := {
            CallbackProcessProps: ptm
          , CallbackProps: SciptParserDemo_CallbackProps
          , CallAccessors: false
          , GetAccessors: false
          , SetAccessors: false
          , NormalizeKeyExtent: 2
          , ShowOwnerIndex: false
        }
        tvexTabOptions := this.TvexTabOptions := { Opt: '' }
        options := { Path: path, Encoding: encoding ?? unset }
        this.byoo := BringYourOwnObject(, {
            Name: 'ScriptParser'
          , PropsInfoTreeOptions: pitOpt
          , TvexTabOptions: tvexTabOptions
          , CallbackGui: _CallbackGui
          , DeferAddControl: true
          , GuiShowOpt: 'x10 y100'
          , FontOpt: 's13 q5'
        })
        if IsSet(GetIncludedObj) {
            options.Included := GetIncludedObj
        }
        this.script := ScriptParser(options)
        this.Dotter.Stop := 1
        ctrl := this.Dotter.Ctrl
        ctrl.Text := ''
        ctrl.Enabled := ctrl.Visible := 0
        ctrl.GetPos(&x, &y)
        g := ctrl.Gui
        g.Add('Link', 'x' x ' y' y ' vLink', '<a href="https://github.com/Nich-Cebolla/AutoHotkey-ScriptParser">Click to open the readme</a>')
        this.DeleteProp('Dotter')
        this.byoo.Add(this.script)

        return

        _CallbackGui(g) {
            btn := g.Add('Button', 'Section', 'Click to view information about this window')
            btn.OnEvent('Click', HClickButtonViewInfo)
            txt := g.Add('Text', 'ys', 'Loading.....')
            Demo.Dotter := Dotter(txt.Hwnd)
            btn.GetPos(&x, &y, &w, &h)
            txt.GetPos(, , , &h2)
            txt.Move(, y + (h - h2) / 2)
            Demo.TvexTabOptions.Opt := 'x' x ' y' (y + h + g.MarginY) ' w1150 r19'

            return

            HClickButtonViewInfo(ctrl, *) {
                local g := ctrl.Gui
                if HasProp(g, 'InfoWindow') {
                    g.InfoWindow.Show()
                } else {
                    iw := g.InfoWindow := Gui('+Resize')
                    lf := TreeViewEx_Logfont(ctrl.Hwnd)
                    iw.SetFont('s' lf.FontSize ' q' lf.Quality, lf.FaceName)
                    local txt := iw.Add('Text', 'Section w700 vTxtInfo', 'The purpose of this demo'
                    ' is to allow you to explore a ``ScriptParser`` object visually, so you can'
                    ' learn about what it has to offer. The gui and tree-view seen in this demo are'
                    ' a separate project unrelated to ``ScriptParser``, but I packaged the project'
                    ' with ``ScriptParser`` for the purpose of this demo. The tree-view control is a'
                    ' custom class which takes an object as input, and generates a tree-view from the'
                    ' object`'s properties and items. As you explore, try right-clicking on a node to'
                    ' see what the context menu has to offer.`r`n`r`n'
                    'Each node in the tree-view represents a value, either from a property or from'
                    ' the object`'s enumerator. The object that is represented here is the'
                    ' ``ScriptParser`` object created from the path passed to the ``Demo`` function.'
                    ' This demo is intended to allow you to explore the object'
                    ' and see the object`'s properties and values, so you can better make use of'
                    ' ``ScriptParser``. Click one of the below buttons to view more information.')
                    btn := iw.Add('Button', 'xs Section', 'ScriptParser')
                    btn.OnEvent('Click', HClickButtonGeneral)
                    btn.__Text := (
                    'ScriptParser`r`n`r`n'
                    '``ScriptParser`` produces a collection of objects representing the'
                    ' classes, class methods, class properties, global functions, comments, jsdoc comments,'
                    ' and strings in the script. It does not currently have a tokenizer, and so it is unable'
                    ' to parse functions defined in an expression, and it does not currently generate an object'
                    ' for functions nested within other functions.'
                    )
                    btn := iw.Add('Button', 'xs', 'The "Collection" property')
                    btn.OnEvent('Click', HClickButtonGeneral)
                    btn.__Text := (
                    'The "Collection" property`r`n`r`n'
                    'The main property of interest is going to be "Collection". Expand the node and you will'
                    ' see the various collection objects. Expand a collection, then expand the "Enum" node.'
                    ' You will see a list of nodes representing component objects. A "component" is'
                    ' a part of your script. ``ScriptParser`` parses 13 types of components:`r`n`r`n'
                    'Classes`r`n'
                    'Global functions`r`n'
                    'Static methods`r`n'
                    'Instance methods`r`n'
                    'Static properties`r`n'
                    'Instance properties`r`n'
                    'Property getters`r`n'
                    'Property setters`r`n'
                    'Comment blocks (multiple consecutive lines of `; notation comments)`r`n'
                    'Multi-line comments (/* */ notation comments)`r`n'
                    'Single line comments (`; notation comments)`r`n'
                    'JSDoc comments (/** */ notation comments)`r`n'
                    'Strings`r`n`r`n'
                    'Expand a collection. If an item has a name (e.g. a function, method, or property),'
                    ' the name will be listed in the label. Expand an item node and you can view the'
                    ' various properties available from the component object.'
                    )
                    btn := iw.Add('Button', 'xs', 'The component object')
                    btn.OnEvent('Click', HClickButtonGeneral)
                    btn.__Text := (
                    'The component object`r`n`r`n'
                    'A component is a discrete part of your script. The following are properties'
                    ' available from all component objects:`r`n`r`n'
                    'AltName: If multiple components have the same name, all subsequent component objects will have a number appended to the name, and "AltName" is set with the original name.`r`n`r`n'
                    'Arrow: Returns 1 if the definition uses the arrow ( => ) operator.`r`n`r`n'
                    'Children: If the component has child components, "Children" is a collection of collection objects, and the child component objects are accessible from the collections.`r`n`r`n'
                    'ColEnd: The column index of the last character of the component`'s text.`r`n`r`n'
                    'ColStart: The column index of the first character of the component`'s text.`r`n`r`n'
                    'Comment: For component objects that are associated with a function, class, method, or property, if there is a comment immediately above the component`'s text, "Comment" returns the comment component object.`r`n`r`n'
                    'CommentParent: This is the property analagous to "Comment" above, but for the comment`'s object. Returns the associated function, class, method, or property component object.`r`n`r`n'
                    'Extends: Returns the string length in characters of the full text of the component.`r`n`r`n'
                    'Get: Returns 1 if the property has a getter.`r`n`r`n'
                    'HasJsdoc: If there is a JSDoc comment immediately above the component, "HasJsdoc" returns 1. The "Comment" property returns the component object.`r`n`r`n'
                    'LenBody: For components that have a body (code in-between curly braces or code after an arrow operator), "LenBody" returns the string length in characters of just the body.`r`n`r`n'
                    'Length: Returns the string length in characters of the full text of the component.`r`n`r`n'
                    'LineEnd: Returns the line number on which the component`'s text ends.`r`n`r`n'
                    'LineStart: Returns the line number on which the component`'s text begins.`r`n`r`n'
                    'Match: If the component is associated with a string or comment, the "Match" property returns the RegExMatchInfo object created when parsing. There are various subcapture groups which you can see by expanding the "Enum" node of the "Match" property node.`r`n`r`n'
                    'Name: Returns the name of the component.`r`n`r`n'
                    'NameCollection: Returns the name of the collection of which the component is part.`r`n`r`n'
                    'Params: If the function, property, or method has parameters, "Params" returns a list of parameter objects.`r`n`r`n'
                    'Parent: If the component is a child component, "Parent" returns the parent component object.`r`n`r`n'
                    'Path: Returns the object path for the component.`r`n`r`n'
                    'Pos: Returns the character position of the start of the component`'s text.`r`n`r`n'
                    'PosBody: For components that have a body (code in-between curly braces or code after an arrow operator), "PosBody" returns returns the character position of the start of the component`'s text body.`r`n`r`n'
                    'PosEnd: Returns the character position of the end of the component`'s text.`r`n`r`n'
                    'Set: Returns 1 if the property has a setter.`r`n`r`n'
                    'Static: Returns 1 if the method or property has the Static keyword.`r`n`r`n'
                    'Text: Returns the original text for the component.`r`n`r`n'
                    'TextBody: For components that have a body (code in-between curly braces or code after an arrow operator), "TextBody" returns returns the text between the curly braces.`r`n`r`n'
                    'TextComment: If the component object is associated with a commment, "TextComment" returns the comment`'s original text with the comment operators and any leading indentation removed. Each individual line of the comment is separated by crlf.`r`n`r`n'
                    'TextOwn: If the component has children, "TextOwn" returns only the text that is directly associated with the component; child text is removed.`r`n`r`n'
                    )
                    btn := iw.Add('Button', 'xs', 'Function parameters')
                    btn.OnEvent('Click', HClickButtonGeneral)
                    btn.__Text := (
                    'Parameters`r`n`r`n'
                    ' Regarding class methods, dynamic properties, and global functions, ``ScriptParser``'
                    ' creates an object for each parameter. Expand one'
                    ' of either "Function", "InstanceMethod", or "StaticMethod". After expanding'
                    ' the node, find a function that you know has parameters and expand the node.'
                    ' Scroll down to the "Params" property and expand it. Parameter objects have'
                    ' the following properties:`r`n`r`n'
                    'Default: Returns 1 if there is a default value.`r`n'
                    'DefaultValue: If "Default" is 1, returns the default value text.`r`n'
                    'Optional: Returns 1 if the parameter has the ? operator or a default value.`r`n'
                    'Symbol: Returns the symbol of the parameter.`r`n'
                    'Variadic: Returns 1 if the paremeter has the * operator.`r`n'
                    'VarRef: Returns 1 if the parameter has the & operator.'
                    )
                    btn := iw.Add('Button', 'xs', 'Dynamic properties')
                    btn.OnEvent('Click', HClickButtonGeneral)
                    btn.__Text := (
                    'Dynamic properties`r`n`r`n'
                    'In addition to the properties common to all component objects, dynamic properties'
                    ' will have one or both of "Getter" and "Setter" children. If the dynamic property'
                    ' has a getter and/or setter, the "Get" and/or "Set" property will return 1,'
                    ' respectively. The getter or setter component objects are accessible from'
                    ' the "Children" property.'
                    )
                    btn := iw.Add('Button', 'xs', 'Strings')
                    btn.OnEvent('Click', HClickButtonGeneral)
                    btn.__Text := (
                    'Strings`r`n`r`n'
                    'All quoted strings are removed from the text before parsing, and they are replaced by replacement'
                    'identifiers. When you access a "Text" property, the identifiers are swapped with the actual text,'
                    'so the original text is returned.`r`n`r`n'

                    'The string component objects will all have a property "Match" which returns'
                    'the ``RegExMatchInfo`` object produced when the string was parsed.'
                    'The "string" item of the match object returns the text without external quotation'
                    'characters.'
                    )
                    btn := iw.Add('Button', 'xs', 'Comments')
                    btn.OnEvent('Click', HClickButtonGeneral)
                    btn.__Text := (
                    'Comments`r`n`r`n'
                    'Comments are divided into four types, "CommentBlock", "CommentMultiLine",'
                    '"CommentSingleLine", and "Jsdoc". When the comment is parsed, the next line'
                    'underneath the comment is included in the match. ``ScriptParser`` uses this to'
                    'associate the comment with what is underneath it. If the line underneath it is'
                    'associated with a component object, and if the component is a function, method, property, or class,'
                    'the comment object will have a property "CommentParent" which will return the object for the line'
                    'underneath the comment, and the object for the line underneath the comment will have a property'
                    '"Comment" which will return the comment object. If the comment is a JSDoc comment, the object for'
                    'the line underneath the comment will also have a property "HasJsdoc" with a value of 1.'
                    )
                    local w := 0
                    y := 2 ** 32 - 1
                    for ctrl in iw {
                        if ctrl.Type = 'Button' {
                            ctrl.GetPos(, &_y, &_w)
                            w := Max(w, _w)
                            y := Min(y, _y)
                        }
                    }
                    x := w + iw.MarginX * 2
                    edt := iw.Add('Edit', 'x' x ' y' y ' w' (700 - x) ' r16 vEdtInfo')
                    edt.Resizer := { W: 1, H: 1 }
                    MonitorGet(1, , , &r)
                    iw.Show('x' (r - 740) ' y200')
                    iw.Resizer := GuiResizer(iw)
                }

                HClickButtonGeneral(ctrl, *) {
                    ctrl.Gui['EdtInfo'].Text := ctrl.__Text
                }
            }
        }
    }
}
SciptParserDemo_CallbackProps(node) {
    switch node.Value.__Class {
        case 'ScriptParser_ComponentList'
        , 'ScriptParser_GlobalCollection'
        , 'ScriptParser_ComponentList'
        , 'ScriptParser_ComponentCollectionIndex'
        , 'ScriptParser_MapEx'
        , 'ScriptParser_ComponentCollection'
        , 'ScriptParser_RemovedCollection.ShortCollection'
        , 'ScriptParser_ChildCollection'
        , 'ScriptParser_IncludedCollection':
            return 1
    }
}

class Dotter {
    __New(HwndCtrl, Period := -1000) {
        this.HwndCtrl := HwndCtrl
        ctrl := this.Ctrl
        StrReplace(ctrl.Text, '.', , , &count)
        this.N := count
        this.Stop := 0
        this.Period := Period
        SetTimer(this, Period)
    }
    Call() {
        if !this.Stop {
            if ++this.N > 5 {
                this.N := 1
                this.Ctrl.Text := RegExReplace(this.Ctrl.Text, '\.+', '.')
            } else {
                this.Ctrl.Text .= '.'
            }
            SetTimer(this, this.Period)
        }
    }
    Ctrl => GuiCtrlFromHwnd(this.HwndCtrl)
}

/***************************************************************************************************
 *
 * The following code contains the necessary dependencies that make this demo possible. You can
 * actually copy this code into a different script and pass any object to the constructor and it
 * will display the object's properties in a tree-view. I have not officially released the project,
 * though it is effectively complete.
 *
 * To use, copy the code into another script, and anywhere at the top, pass an object to the
 * constructor.
 * @example
 * obj := MyClass(params)
 * BringYourOwnObject(obj)
 * ; ... the below code
 * @
 *
 * This ScriptParser demo uses some of the library's customization options to restrict what properties
 * are displayed by the tree-view since most of them are used internally. When you pass your own
 * object to BringYourOwnObject, all properties will be displayed by default. You could hypothetically
 * review the documentation below and figure out how to customize it, but it is a rather large project.
 * I'll release the project when I finish writing the documentation.
 *
 **************************************************************************************************/

#Requires AutoHotkey >=2.0-a

; https://github.com/Nich-Cebolla/AutoHotkey-LibV2/tree/main/inheritance

/**
 * @description - Traverses an object's inheritance chain and returns the base objects.
 *
 * @param {Object} Obj - The object from which to get the base objects.
 *
 * @param {Integer|String} [StopAt = GBO_STOP_AT_DEFAULT ?? "-Any"] - If an integer, the number of
 * base objects to traverse up the inheritance chain. If a string, the case-insensitive name of the
 * class to stop at. If falsy, the function will traverse the entire inheritance chain up to
 * but not including `Any`.
 *
 * If you define global variable `GBO_STOP_AT_DEFAULT` with a value somewhere in your code, that
 * value will be used as the default for the function call. Otherwise, '-Any' is used.
 *
 * There are two ways to modify the function's interpretation of this value. These are only relevant
 * for string values.
 *
 * - Stop before or after the class: The default is to stop after the class, such that the base object
 * associated with the class is included in the result array. To change this, include a hyphen "-"
 * anywhere in the value and `GetBaseObjects` will not include the last iterated object in the
 * result array.
 *
 * In the code snippets below, `b` represents the base object being evaluated.
 *
 * - The type of object which will be stopped at:
 *   - Stop at a prototype object (default): `GetBaseObjects` will stop at the first prototype object
 *     with a `__Class` property equal to `StopAt`. This is the literal condition used:
 *     `ObjHasOwnProp(b, "__Class") && b.__Class = StopAt`.
 *   - Stop at a class object: To direct `GetBaseObjects` to stop at a class object tby he name
 *     `StopAt`, include ":C" at the end of `StopAt`, e.g. `StopAt := "MyClass:C"`. This is the literal
 *     condition used:
 *     `ObjHasOwnProp(b, "Prototype") && b.Prototype.__Class = StopAt`.
 *   - Stop at an instance object: To direct `GetBaseObjects` to stop at an instance object of type
 *     `StopAt`, incluide ":I" at the end of `StopAt`, e.g. `StopAt := "MyClass:I"`. This is the literal
 *     condition used: `!ObjHasOwnProp(b, "__Class") && b.__Class = StopAt`.
 *
 * @returns {Array} - The array of base objects.
 */
GetBaseObjects(Obj, StopAt := GBO_STOP_AT_DEFAULT ?? '-Any') {
    Result := []
    if IsNumber(StopAt) {
        if stopAt > 0 {
            Result.Push(Obj.Base)
            loop stopAt - 1 {
                Result.Push(Result[-1].Base)
            }
        } else {
            throw ValueError('``Options.StopAt`` must be an integer greater than zero.', , StopAt)
        }
    } else {
        if StopAt {
            if InStr(StopAt, '-') {
                StopAt := StrReplace(StopAt, '-', '')
                flag_stopBefore := 1
            } else {
                flag_stopBefore := 0
            }
        } else {
            flag_stopBefore := 1
            StopAt := 'Any'
        }
        if InStr(StopAt, ':C') {
            StopAt := StrReplace(StopAt, ':C', '')
            check := _CheckClass
        } else if InStr(StopAt, ':I') {
            StopAt := StrReplace(StopAt, ':I', '')
            check := _CheckInstance
        } else {
            check := _CheckPrototype
        }
        b := Obj
        if !check() {
            if flag_stopBefore {
                Loop {
                    if b := b.Base {
                        if check() {
                            break
                        }
                        Result.Push(b)
                    } else {
                        _Throw()
                    }
                }
            } else {
                Loop {
                    if b := b.Base {
                        Result.Push(b)
                        if check() {
                            break
                        }
                    } else {
                        _Throw()
                    }
                }
            }
        }
    }

    return Result

    _CheckClass() {
        return ObjHasOwnProp(b, 'Prototype') && b.Prototype.__Class = StopAt
    }
    _CheckInstance() {
        return !ObjHasOwnProp(b, '__Class') && b.__Class = StopAt
    }
    _CheckPrototype() {
        return ObjHasOwnProp(b, '__Class') && b.__Class = StopAt
    }
    _Throw() {
        ; If `GetBaseObjects` encounters a non-object base, that means it traversed the inheritance
        ; chain up to Any.Prototype, which returns an empty string. If `StopAt` = 'Any' and
        ; !IsSet(FlagStopBefore) (the user did not include "-" in the param string), then this is
        ; expected. In all other cases, this means that the input `StopAt` value was never
        ; encountered, and results in this error.
        if IsSet(FlagStopBefore) || StopAt != 'Any' {
            throw Error('``GetBaseObjects`` did not encounter an object that matched the ``StopAt`` value.'
            , , '``StopAt``: ' (IsSet(FlagStopBefore) ? '-' : '') StopAt)
        }
    }
}

/**
 * @description - Gets the property descriptor object for the specified property of the input object.
 * {@link https://www.autohotkey.com/docs/v2/lib/Object.htm#GetOwnPropDesc}
 * @param {Object} Obj - The object from which to get the property descriptor.
 * @param {String} Prop - The name of the property.
 * @param {VarRef} [OutObj] - A variable that will receive a reference to the object which owns the
 * property.
 * @param {VarRef} [OutIndex] - A variable that will receive the index position of the object which
 * owns the property in the inheritance chain.
 * @returns {Object} - If the property exists, the property descriptor object. Else, an empty string.
 */
GetPropDesc(Obj, Prop, &OutObj?, &OutIndex?) {
    if !HasProp(Obj, Prop) {
        return ''
    }
    OutObj := Obj
    OutIndex := 0
    while OutObj && !ObjHasOwnProp(OutObj, Prop) {
        OutIndex++
        OutObj := OutObj.Base
    }
    if OutObj {
        return ObjGetOwnPropDesc(OutObj, Prop)
    } else {
        throw Error('``GetPropDesc`` failed to identify the object which owns the property.')
    }
}

/**
 * @description - Constructs a `PropsInfo` object, which is a flexible solution for cases when a
 * project would benefit from being able to quickly obtain a list of all of an object's properties,
 * and/or filter those properties.
 *
 * In this documentation, an instance of `PropsInfo` is referred to as either "a `PropsInfo` object"
 * or `PropsInfoObj`. An instance of `PropsInfoItem` is referred to as either "a `PropsInfoItem` object"
 * or `InfoItem`.
 *
 * See example-Inheritance.ahk for a walkthrough on how to use the class.
 *
 * `PropsInfo` objects are designed to be a flexible solution for accessing and/or analyzing an
 * object's properties, including inherited properties. Whereas `OwnProps` only iterates an objects'
 * own properties, `PropsInfo` objects can perform these functions for both inherited and own
 * properties:
 * - Produce an array of property names.
 * - Produce a `Map` where the key is the property name and the object is a `PropsInfoItem` object
 * for each property.
 * - Produce an array of `PropsInfoItem` objects.
 * - Be passed to a function that expects an iterable object like any of the three above bullet points.
 * - Filter the properties according to one or more conditions.
 * - Get the function objects associated with the properties.
 * - Get the values associated with the properties.
 *
 * `PropsInfoItem` objects are modified descriptor objects.
 * @see {@link https://www.autohotkey.com/docs/v2/lib/Object.htm#GetOwnPropDesc}.
 * After getting the descriptor object, `GetPropsInfo` changes the descriptor object's base, converting
 * it to a `PropsInfoItem` object and exposing additional properties. See the parameter hints above
 * each property for details.
 *
 * For more information about property accessors, see:
 * - {@link https://www.autohotkey.com/docs/v2/lib/Object.htm#DefineProp}
 * - {@link https://www.autohotkey.com/docs/v2/lib/Object.htm#GetOwnPropDesc}
 * - {@link https://www.autohotkey.com/docs/v2/Objects.htm#Meta_Functions}
 *
 * @param {*} Obj - The object from which to get the properties.
 * @param {Integer|String} [StopAt=GPI_STOP_AT_DEFAULT ?? '-Object'] - If an integer, the number of
 * base objects to traverse up the inheritance chain. If a string, the name of the class to stop at.
 * You can define a global variable `GPI_STOP_AT_DEFAULT` to change the default value. If
 * GPI_STOP_AT_DEFAULT is unset, the default value is '-Object', which directs `GetPropsInfo` to
 * include properties owned by objects up to but not including `Object.Prototype`.
 * @see {@link GetBaseObjects} for full details about this parameter.
 * @param {String} [Exclude=''] - A comma-delimited, case-insensitive list of properties to exclude.
 * For example: "Length,Capacity,__Item".
 * @param {Boolean} [IncludeBaseProp=true] - If true, the object's `Base` property is included. If
 * false, `Base` is excluded.
 * @param {VarRef} [OutBaseObjList] - A variable that will receive a reference to the array of
 * base objects that is generated during the function call.
 * @param {Boolean} [ExcludeMethods=false] - If true, callable properties are excluded. Note that
 * properties with a value that is a class object are unaffected by `ExcludeMethods`.
 * @returns {PropsInfo}
 */
GetPropsInfo(Obj, StopAt := GPI_STOP_AT_DEFAULT ?? '-Object', Exclude := '', IncludeBaseProp := true, &OutBaseObjList?, ExcludeMethods := false) {
    OutBaseObjList := GetBaseObjects(Obj, StopAt)
    Container := Map()
    Container.Default := Container.CaseSense := false
    Excluded := ','
    for s in StrSplit(Exclude, ',', '`s`t') {
        if s {
            Container.Set(s, -1)
        }
    }

    PropsInfoItemBase := PropsInfoItem(Obj, OutBaseObjList.Length)

    if ExcludeMethods {
        for Prop in ObjOwnProps(Obj) {
            if (HasMethod(Obj, Prop) && not Obj.%Prop% is Class) || Container.Get(Prop) {
                if !InStr(Excluded, ',' Prop ',') {
                    Excluded .= Prop ','
                }
                continue
            }
            ObjSetBase(ItemBase := {
                /**
                 * The property name.
                 * @memberof PropsInfoItem
                 * @instance
                 */
                    Name: Prop
                /**
                 * `Count` gets incremented by one for each object which owns a property by the same name.
                 * @memberof PropsInfoItem
                 * @instance
                 */
                  , Count: 1
                }
              , PropsInfoItemBase
            )
            ObjSetBase(Item := ObjGetOwnPropDesc(Obj, Prop), ItemBase)
            Item.Index := 0
            Container.Set(Prop, Item)
        }
        if IncludeBaseProp {
            ObjSetBase(ItemBase := { Name: 'Base', Count: 1 }, PropsInfoItemBase)
            ObjSetBase(InfoItem_Base := { Value: Obj.Base }, ItemBase)
            InfoItem_Base.Index := 0
            Container.Set('Base', InfoItem_Base)
        }
        i := 0
        for b in OutBaseObjList {
            i++
            for Prop in ObjOwnProps(b) {
                if HasMethod(b, Prop) {
                    if !InStr(Excluded, ',' Prop ',') {
                        Excluded .= Prop ','
                    }
                }
                if r := Container.Get(Prop) {
                    if r == -1 {
                        if !InStr(Excluded, ',' Prop ',') {
                            Excluded .= Prop ','
                        }
                        continue
                    }
                    ; It's an existing property
                    ObjSetBase(Item := ObjGetOwnPropDesc(b, Prop), r.Base)
                    Item.Index := i
                    r.__SetAlt(Item)
                    r.Base.Count++
                } else {
                    ; It's a new property
                    ObjSetBase(ItemBase := { Name: Prop, Count: 1 }, PropsInfoItemBase)
                    ObjSetBase(Item := ObjGetOwnPropDesc(b, Prop), ItemBase)
                    Item.Index := i
                    Container.Set(Prop, Item)
                }
            }
            if IncludeBaseProp {
                ObjSetBase(Item := { Value: b.Base }, InfoItem_Base.Base)
                Item.Index := i
                InfoItem_Base.__SetAlt(Item)
                InfoItem_Base.Base.Count++
            }
        }
    } else {
        for Prop in ObjOwnProps(Obj) {
            if Container.Get(Prop) {
                ; Prop is in `Exclude`
                if !InStr(Excluded, ',' Prop ',') {
                    Excluded .= Prop ','
                }
                continue
            }
            ObjSetBase(ItemBase := {
                /**
                 * The property name.
                 * @memberof PropsInfoItem
                 * @instance
                 */
                    Name: Prop
                /**
                 * `Count` gets incremented by one for each object which owns a property by the same name.
                 * @memberof PropsInfoItem
                 * @instance
                 */
                  , Count: 1
                }
              , PropsInfoItemBase)
            ObjSetBase(Item := ObjGetOwnPropDesc(Obj, Prop), ItemBase)
            Item.Index := 0
            Container.Set(Prop, Item)
        }
        if IncludeBaseProp {
            ObjSetBase(ItemBase := { Name: 'Base', Count: 1 }, PropsInfoItemBase)
            ObjSetBase(InfoItem_Base := { Value: Obj.Base }, ItemBase)
            InfoItem_Base.Index := 0
            Container.Set('Base', InfoItem_Base)
        }
        i := 0
        for b in OutBaseObjList {
            i++
            for Prop in ObjOwnProps(b) {
                if r := Container.Get(Prop) {
                    if r == -1 {
                        if !InStr(Excluded, ',' Prop ',') {
                            Excluded .= Prop ','
                        }
                        continue
                    }
                    ObjSetBase(Item := ObjGetOwnPropDesc(b, Prop), r.Base)
                    Item.Index := i
                    r.__SetAlt(Item)
                    r.Base.Count++
                } else {
                    ; It's a new property
                    ObjSetBase(ItemBase := { Name: Prop, Count: 1 }, PropsInfoItemBase)
                    ObjSetBase(Item := ObjGetOwnPropDesc(b, Prop), ItemBase)
                    Item.Index := i
                    Container.Set(Prop, Item)
                }
            }
            if IncludeBaseProp {
                ObjSetBase(Item := { Value: b.Base }, InfoItem_Base.Base)
                Item.Index := i
                InfoItem_Base.__SetAlt(Item)
                InfoItem_Base.Base.Count++
            }
        }
    }
    for s in StrSplit(Exclude, ',', '`s`t') {
        if s {
            Container.Delete(s)
        }
    }
    if !IncludeBaseProp {
        Excluded .= 'Base'
    }
    return PropsInfo(Container, PropsInfoItemBase, Trim(Excluded, ','))
}

/**
 * @description - {@link GetPropsInfoEx} exposes different options than {@link GetPropsInfo}.
 *
 * @param {*} Obj - The object from which to get the properties.
 *
 * @param {Object} [Options] - An object with options as property : value pairs. Note that if
 * `Options.Props` is set, the function ignores all other options except `Options.StopAt`.
 *
 * @param {Boolean} [SkipOptions = false] - Set this to true to save processing time if you have if
 * the value passed to `Options` is a {@link PropsInfo.Options} object, and does not need to be passed
 * to {@link PropsInfo.Options.Prototype.__New}. If false, `Options` is passed to
 * {@link PropsInfo.Options.Prototype.__New}.
 *
 * @param {VarRef} [OutBaseObjList] - A variable that will receive a reference to the array of
 * base objects that is generated during the function call.
 *
 * @param {Boolean} [Options.BaseProp = false] - If true, the property "Base" will be included.
 * @param {Boolean} [Options.Call = false] - If true, properties with a call accessor will be included.
 * @param {String} [Options.Exclude] - A comma-separated list of property names to exclude, e.g.
 * "__Class,Count,Capacity".
 * @param {Boolean} [Options.Get = true] - If true, properties with a get accessor will be included.
 * @param {String} [Options.Props] - A comma-separated list of property names to include, e.g.
 * "__Class,Count,Capacity". If `Options.Props` is set, the function ignores all other options except
 * `Options.StopAt`.
 * @param {Boolean} [Options.Set = false] - If true, properties with a set accessor will be included.
 * @param {Integer|String} [Options.StopAt] - If set, either of the following kinds of values:
 *
 * If an integer, the number of base objects to traverse up the inheritance chain. `Obj.Base` is 1,
 * `Obj.Base.Base` is 2, etc. The number must be greater than zero.
 *
 * If a string, the case-insensitive name of the class to stop at. There are two ways to modify the
 * function's interpretation of this value. These are only relevant for string values.
 * - Stop before or after the class: The default is to stop after the class, such that the base object
 *   associated with the class is included in the result array. To change this, include a hyphen ( - )
 *   anywhere in the value and `GetBaseObjects` will not include the last iterated object in the
 *   result array.
 * - The type of object which will be stopped at. In the code snippets below, `b` represents the base
 *   object being evaluated.
 *   - Stop at a prototype object (default): `GetBaseObjects` will stop at the first prototype object
 *     with a `__Class` property equal to `StopAt`. This is the literal condition used:
 *     `ObjHasOwnProp(b, "__Class") && b.__Class = StopAt`.
 *   - Stop at a class object: Include ":C" at the end of the value to direct the function to stop at
 *     a class object by he name `StopAt`, e.g. `StopAt := "MyClass:C"`. This is the literal
 *     condition used: `ObjHasOwnProp(b, "Prototype") && b.Prototype.__Class = StopAt`.
 *   - Stop at an instance object: Include ":I" at the end of the value to direct the function to
 *     stop at an instance object of type `StopAt`, e.g. `StopAt := "MyClass:I"`. This is the literal
 *     condition used: `!ObjHasOwnProp(b, "__Class") && b.__Class = StopAt`.
 *
 * If unset, the function applies this logic:
 * - If the object does not inherit from `Object`, stop before `Any.Prototype`.
 * - If the object inherits from `Array`, stop before `Array.Prototype`.
 * - If the object inherits from `Buffer`, stop before `Buffer.Prototype`.
 * - If the object inherits from `Class`, stop before `Class.Prototype`.
 * - If the object inherits from `Map`, stop before `Map.Prototype`.
 * - For all other objects, stop before `Object.Prototype`.
 * @param {Boolean} [Options.Value = true] - If true, value properties will be included.
 *
 * @returns {PropsInfo}
 */
GetPropsInfoEx(Obj, Options?, SkipOptions := false, &OutBaseObjList?) {
    if !SkipOptions {
        options := PropsInfo.Options(Options ?? unset)
    }
    OutBaseObjList := []
    if stopAt := options.StopAt {
        if IsNumber(stopAt) {
            if stopAt > 0 {
                OutBaseObjList.Push(Obj.Base)
                loop stopAt - 1 {
                    OutBaseObjList.Push(OutBaseObjList[-1].Base)
                }
            } else {
                throw ValueError('``Options.StopAt`` must be an integer greater than zero.', , options.StopAt)
            }
        } else {
            if flag_stopBefore := InStr(stopAt, '-') {
                stopAt := StrReplace(stopAt, '-', '')
            }
            if InStr(stopAt, ':C') {
                check := _CheckClass
                stopAt := StrReplace(stopAt, ':C', '')
            } else if InStr(stopAt, ':I') {
                check := _CheckInstance
                stopAt := StrReplace(stopAt, ':I', '')
            } else {
                check := _CheckPrototype
            }
            b := Obj
            if !check() {
                if flag_stopBefore {
                    Loop {
                        if b := b.Base {
                            if check() {
                                break
                            }
                            OutBaseObjList.Push(b)
                            b := b.Base
                        } else {
                            break
                        }
                    }
                } else {
                    Loop {
                        if b := b.Base {
                            OutBaseObjList.Push(b)
                            if check() {
                                break
                            }
                            b := b.Base
                        } else {
                            break
                        }
                    }
                }
            }
        }
    } else {
        stopAt := options.__StopAtDefaultList
        if !ObjHasOwnProp(Obj, '__Class') || !InStr(stopAt, ',' Obj.__Class ',') {
            b := Obj.Base
            Loop {
                if ObjHasOwnProp(b, '__Class') && InStr(stopAt, ',' b.__Class ',') {
                    break
                }
                OutBaseObjList.Push(b)
                b := b.Base
            }
        }
    }
    container := Map()
    excluded := Map()
    excluded.CaseSense := container.CaseSense := false
    container.Default := ''
    propsInfoItemBase := PropsInfoItem(Obj, OutBaseObjList.Length)
    propsInfoItemBase.__Class := propsInfoItemBase.__Class
    if options.Props {
        include := ',' options.Props ','
        for prop in ObjOwnProps(Obj) {
            if InStr(include, ',' prop ',') {
                ObjSetBase(itemBase := {
                    /**
                     * The property name.
                     * @memberof PropsInfoItem
                     * @instance
                     */
                        Name: prop
                    /**
                     * `Count` gets incremented by one for each object which owns a property by the same name.
                     * @memberof PropsInfoItem
                     * @instance
                     */
                      , Count: 1
                    }
                  , propsInfoItemBase
                )
                ObjSetBase(item := ObjGetOwnPropDesc(Obj, Prop), itemBase)
                item.Index := 0
                container.Set(prop, item)
            } else {
                excluded.Set(prop, 1)
                continue
            }
        }
        if InStr(include, ',Base,') {
            ObjSetBase(itemBase := { Name: 'Base', Count: 1 }, propsInfoItemBase)
            ObjSetBase(infoItem_Base := { Value: Obj.Base, Index: 0 }, itemBase)
            container.Set('Base', infoItem_Base)
        }
        i := 0
        for b in OutBaseObjList {
            i++
            for prop in ObjOwnProps(b) {
                if o := container.Get(prop) {
                    ObjSetBase(item := ObjGetOwnPropDesc(b, Prop), o.Base)
                    item.Index := i
                    o.__SetAlt(item)
                    o.Base.Count++
                } else if InStr(include, ',' prop ',') {
                    ObjSetBase(itemBase := { Name: prop, Count: 1 }, propsInfoItemBase)
                    ObjSetBase(item := ObjGetOwnPropDesc(b, prop), itemBase)
                    item.Index := i
                    container.Set(prop, item)
                } else {
                    excluded.Set(prop, 1)
                    continue
                }
            }
            if InStr(include, ',Base,') {
                ObjSetBase(item := { Value: b.Base, Index: i }, infoItem_Base.Base)
                infoItem_Base.__SetAlt(item)
                infoItem_Base.Base.Count++
            }
        }
        if !InStr(include, ',Base,') {
            excluded.Set('Base', 1)
        }
    } else {
        baseProp := options.BaseProp
        kind := ''
        if options.Call {
            kind .= ',Call'
        }
        if options.Get {
            kind .= ',Get'
        }
        if options.Set {
            kind .= ',Set'
        }
        if options.Value {
            kind .= ',Value'
        }
        kind .= ','
        if StrLen(kind) = 20 {
            if options.Exclude {
                exclude := ',' options.Exclude ','
                for prop in ObjOwnProps(Obj) {
                    if InStr(exclude, ',' prop ',') {
                        excluded.Set(prop, 1)
                        continue
                    }
                    ObjSetBase(itemBase := {
                        /**
                         * The property name.
                         * @memberof PropsInfoItem
                         * @instance
                         */
                            Name: prop
                        /**
                         * `Count` gets incremented by one for each object which owns a property by the same name.
                         * @memberof PropsInfoItem
                         * @instance
                         */
                          , Count: 1
                        }
                      , propsInfoItemBase
                    )
                    ObjSetBase(item := ObjGetOwnPropDesc(Obj, Prop), itemBase)
                    item.Index := 0
                    container.Set(prop, item)
                }
                if baseProp {
                    ObjSetBase(itemBase := { Name: 'Base', Count: 1 }, propsInfoItemBase)
                    ObjSetBase(infoItem_Base := { Value: Obj.Base, Index: 0 }, itemBase)
                    container.Set('Base', infoItem_Base)
                }
                i := 0
                for b in OutBaseObjList {
                    i++
                    for prop in ObjOwnProps(b) {
                        if o := container.Get(prop) {
                            ObjSetBase(item := ObjGetOwnPropDesc(b, Prop), o.Base)
                            item.Index := i
                            o.__SetAlt(item)
                            o.Base.Count++
                        } else {
                            if InStr(exclude, ',' prop ',') {
                                excluded.Set(prop, 1)
                                continue
                            }
                            ObjSetBase(itemBase := { Name: prop, Count: 1 }, propsInfoItemBase)
                            ObjSetBase(item := ObjGetOwnPropDesc(b, prop), itemBase)
                            item.Index := i
                            container.Set(prop, item)
                        }
                    }
                    if baseProp {
                        ObjSetBase(item := { Value: b.Base, Index: i }, infoItem_Base.Base)
                        infoItem_Base.__SetAlt(item)
                        infoItem_Base.Base.Count++
                    }
                }
            } else {
                for prop in ObjOwnProps(Obj) {
                    ObjSetBase(itemBase := {
                        /**
                         * The property name.
                         * @memberof PropsInfoItem
                         * @instance
                         */
                            Name: prop
                        /**
                         * `Count` gets incremented by one for each object which owns a property by the same name.
                         * @memberof PropsInfoItem
                         * @instance
                         */
                          , Count: 1
                        }
                      , propsInfoItemBase
                    )
                    ObjSetBase(item := ObjGetOwnPropDesc(Obj, Prop), itemBase)
                    item.Index := 0
                    container.Set(prop, item)
                }
                if baseProp {
                    ObjSetBase(itemBase := { Name: 'Base', Count: 1 }, propsInfoItemBase)
                    ObjSetBase(infoItem_Base := { Value: Obj.Base, Index: 0 }, itemBase)
                    container.Set('Base', infoItem_Base)
                }
                i := 0
                for b in OutBaseObjList {
                    i++
                    for prop in ObjOwnProps(b) {
                        if o := container.Get(prop) {
                            ObjSetBase(item := ObjGetOwnPropDesc(b, Prop), o.Base)
                            item.Index := i
                            o.__SetAlt(item)
                            o.Base.Count++
                        } else {
                            ObjSetBase(itemBase := { Name: prop, Count: 1 }, propsInfoItemBase)
                            ObjSetBase(item := ObjGetOwnPropDesc(b, prop), itemBase)
                            item.Index := i
                            container.Set(prop, item)
                        }
                    }
                    if baseProp {
                        ObjSetBase(item := { Value: b.Base, Index: i }, infoItem_Base.Base)
                        infoItem_Base.__SetAlt(item)
                        infoItem_Base.Base.Count++
                    }
                }
            }
        } else if options.Exclude {
            exclude := ',' options.Exclude ','
            for prop in ObjOwnProps(Obj) {
                if InStr(exclude, ',' prop ',') {
                    excluded.Set(prop, 1)
                    continue
                }
                item := ObjGetOwnPropDesc(Obj, prop)
                flag := true
                for _prop in ObjOwnProps(item) {
                    if InStr(kind, ',' _prop ',') {
                        flag := false
                    }
                }
                if flag {
                    excluded.Set(prop, 1)
                    continue
                }
                ObjSetBase(itemBase := {
                    /**
                     * The property name.
                     * @memberof PropsInfoItem
                     * @instance
                     */
                        Name: prop
                    /**
                     * `Count` gets incremented by one for each object which owns a property by the same name.
                     * @memberof PropsInfoItem
                     * @instance
                     */
                      , Count: 1
                    }
                  , propsInfoItemBase
                )
                ObjSetBase(item, itemBase)
                item.Index := 0
                container.Set(prop, item)
            }
            if baseProp {
                ObjSetBase(itemBase := { Name: 'Base', Count: 1 }, propsInfoItemBase)
                ObjSetBase(infoItem_Base := { Value: Obj.Base, Index: 0 }, itemBase)
                container.Set('Base', infoItem_Base)
            }
            i := 0
            for b in OutBaseObjList {
                i++
                for prop in ObjOwnProps(b) {
                    if o := container.Get(prop) {
                        ObjSetBase(item := ObjGetOwnPropDesc(b, Prop), o.Base)
                        item.Index := i
                        o.__SetAlt(item)
                        o.Base.Count++
                    } else {
                        if InStr(exclude, ',' prop ',') {
                            excluded.Set(prop, 1)
                            continue
                        }
                        item := ObjGetOwnPropDesc(b, prop)
                        flag := true
                        for _prop in ObjOwnProps(item) {
                            if InStr(kind, ',' _prop ',') {
                                flag := false
                            }
                        }
                        if flag {
                            excluded.Set(prop, 1)
                            continue
                        }
                        ObjSetBase(itemBase := { Name: prop, Count: 1 }, propsInfoItemBase)
                        ObjSetBase(item, itemBase)
                        item.Index := i
                        container.Set(prop, item)
                    }
                }
                if baseProp {
                    ObjSetBase(item := { Value: b.Base, Index: i }, infoItem_Base.Base)
                    infoItem_Base.__SetAlt(item)
                    infoItem_Base.Base.Count++
                }
            }
        } else {
            for prop in ObjOwnProps(Obj) {
                item := ObjGetOwnPropDesc(Obj, prop)
                flag := true
                for _prop in ObjOwnProps(item) {
                    if InStr(kind, ',' _prop ',') {
                        flag := false
                    }
                }
                if flag {
                    excluded.Set(prop, 1)
                    continue
                }
                ObjSetBase(itemBase := {
                    /**
                     * The property name.
                     * @memberof PropsInfoItem
                     * @instance
                     */
                        Name: prop
                    /**
                     * `Count` gets incremented by one for each object which owns a property by the same name.
                     * @memberof PropsInfoItem
                     * @instance
                     */
                      , Count: 1
                    }
                  , propsInfoItemBase
                )
                ObjSetBase(item, itemBase)
                item.Index := 0
                container.Set(prop, item)
            }
            if baseProp {
                ObjSetBase(itemBase := { Name: 'Base', Count: 1 }, propsInfoItemBase)
                ObjSetBase(infoItem_Base := { Value: Obj.Base, Index: 0 }, itemBase)
                container.Set('Base', infoItem_Base)
            }
            i := 0
            for b in OutBaseObjList {
                i++
                for prop in ObjOwnProps(b) {
                    if o := container.Get(prop) {
                        ObjSetBase(item := ObjGetOwnPropDesc(b, Prop), o.Base)
                        item.Index := i
                        o.__SetAlt(item)
                        o.Base.Count++
                    } else {
                        item := ObjGetOwnPropDesc(b, prop)
                        flag := true
                        for _prop in ObjOwnProps(item) {
                            if InStr(kind, ',' _prop ',') {
                                flag := false
                            }
                        }
                        if flag {
                            excluded.Set(prop, 1)
                            continue
                        }
                        ObjSetBase(itemBase := { Name: prop, Count: 1 }, propsInfoItemBase)
                        ObjSetBase(item, itemBase)
                        item.Index := i
                        container.Set(prop, item)
                    }
                }
                if baseProp {
                    ObjSetBase(item := { Value: b.Base, Index: i }, infoItem_Base.Base)
                    infoItem_Base.__SetAlt(item)
                    infoItem_Base.Base.Count++
                }
            }
        }
        if !baseProp {
            excluded.Set('Base', 1)
        }
    }
    _excluded := ''
    for s in excluded {
        _excluded .= s ','
    }

    return PropsInfo(container, propsInfoItemBase, SubStr(_excluded, 1, -1))

    _CheckClass() {
        return ObjHasOwnProp(b, 'Prototype') && b.Prototype.__Class = StopAt
    }
    _CheckInstance() {
        return !ObjHasOwnProp(b, '__Class') && b.__Class = StopAt
    }
    _CheckPrototype() {
        return ObjHasOwnProp(b, '__Class') && b.__Class = StopAt
    }
}

/**
 * @classdesc - The return value for `GetPropsInfo`. See the parameter hint above `GetPropsInfo`
 * for information.
 */
class PropsInfo {
    static __New() {
        this.DeleteProp('__New')
        PropsInfo_SetConstants()
        proto := this.Prototype
        proto.DefineProp('Filter', { Value: '' })
        proto.DefineProp('__FilterActive', { Value: 0 })
        proto.DefineProp('__StringMode', { Value: 0 })
        proto.DefineProp('Get', proto.GetOwnPropDesc('__ItemGet_Bitypic'))
        proto.DefineProp('__OnFilterProperties', { Value: ['Has', 'ToArray', 'ToMap'
        , 'Capacity', 'Count', 'Length'] })
        proto.DefineProp('__FilteredItems', { Value: '' })
        proto.DefineProp('__FilteredIndex', { Value: '' })
        proto.DefineProp('__FilterCache', { Value: '' })
    }

    /**
     * @class - The constructor is intended to be called from `GetPropsInfo`.
     * @param {Map} Container - The keys are property names and the values are `PropsInfoItem` objects.
     * @param {PropsInfoItem} PropsInfoItemBase - The base object shared by all instances of
     * `PropsInfoItem` associated with this `PropsInfo` object.
     * @param {String} [Excluded] - A comma-delimited list of properties that were excluded from the
     * collection.
     * @returns {PropsInfo} - The `PropsInfo` instance.
     */
    __New(Container, PropsInfoItemBase, Excluded?) {
        this.__InfoIndex := Map()
        this.__InfoIndex.Default := this.__InfoIndex.CaseSense := false
        this.__InfoItems := []
        this.__InfoItems.Capacity := this.__InfoIndex.Capacity := Container.Count
        for Prop, InfoItem in Container {
            this.__InfoItems.Push(InfoItem)
            this.__InfoIndex.Set(Prop, A_Index)
        }
        this.__PropsInfoItemBase := PropsInfoItemBase
        this.__FilterActive := 0
        this.Excluded := Excluded ?? ''
    }

    /**
     * @description - Removes a `PropsInfoItem` object from the collection. This does not change the
     * items exposed by the currently active filter nor any cached filters. To update a filter,
     * call `PropsInfo.Prototype.FilterActivate` after calling `PropsInfo.Prototype.Delete`,
     * `PropsInfo.Prototype.Refresh`, or `PropsInfo.Prototype.RefreshProp`.
     * @param {String} Names - A comma-delimited list of property names to delete.
     * @returns {PropsInfoItem[]} - An array of deleted `PropsInfoItem` objects.
     */
    Delete(Names) {
        InfoItems := this.__InfoItems
        InfoIndex := this.__InfoIndex
        NewInfoItems := this.__InfoItems := []
        Deleted := []
        NewInfoIndex := this.__InfoIndex := Map()
        NewInfoIndex.CaseSense := false
        NewInfoItems.Capacity := NewInfoIndex.Capacity := Deleted.Capacity := InfoItems.Length
        Names := ',' Names ','
        for InfoItem in InfoItems {
            if InStr(Names, ',' InfoItem.Name ',') {
                Deleted.Push(InfoItem)
            } else {
                NewInfoItems.Push(InfoItem)
                NewInfoIndex.Set(InfoItem.Name, NewInfoItems.Length)
            }
        }
        Excluded := this.Excluded ','
        for Prop in StrSplit(Trim(Names, ','), ',', '`s`t') {
            if !InStr(Excluded, ',' Prop ',') {
                Excluded .= Prop ','
            }
        }
        this.Excluded := Trim(Excluded, ',')
        NewInfoItems.Capacity := NewInfoItems.Length
        NewInfoIndex.Capacity := NewInfoIndex.Count
        Deleted.Capacity := Deleted.Length
        return Deleted
    }

    /**
     * @description - Performs these actions:
     * - Deletes the `Root` property from the `PropsInfoItem` object that is used as the base for
     * all `PropsInfoItem` objects associated with this `PropsInfo` object. This action invalidates
     * some of the `PropsInfoItem` objects' methods and properties, and they should be considered
     * effectively disposed.
     * - Clears the `PropsInfo` object's container properties and sets their capacity to 0
     * - Deletes the `PropsInfo` object's own properties.
     */
    Dispose() {
        this.__PropsInfoItemBase.DeleteProp('Root')
        this.__InfoIndex.Clear()
        this.__InfoIndex.Capacity := this.__InfoItems.Capacity := 0
        if this.__FilteredIndex {
            this.__FilteredIndex.Capacity := 0
        }
        if this.__FilteredItems {
            this.__FilteredItems.Clear()
            this.__FilteredItems.Capacity := 0
        }
        if this.HasOwnProp('Filter') {
            this.DeleteProp('Filter')
        }
        if this.HasOwnProp('__FilterCache') {
            this.__FilterCache.Clear()
            this.__FilterCache.Capacity := 0
        }
        for Prop in this.OwnProps() {
            this.DeleteProp(Prop)
        }
        this.DefineProp('Dispose', { Call: (*) => '' })
    }

    /**
     * @description - Activates the filter, setting property `PropsInfoObj.FilterActive := 1`. While
     * `PropsInfoObj.FilterActive == 1`, the values returned by the following methods and properties
     * will be filtered:
     * __Enum, Get, GetFilteredProps (if a function object is not passed to it), Has, ToArray, ToMap,
     * __item, Capacity, Count, Length
     * @param {String|Number} [CacheName] - If set, the filtered containers will be cached under this name.
     * Else, the containers are not cached.
     * @throws {UnsetItemError} - If no filters have been added.
     */
    FilterActivate(CacheName?) {
        if !this.Filter {
            throw UnsetItemError('No filters have been added.', -1)
        }
        Filter := this.Filter
        this.DefineProp('__FilteredIndex', { Value: FilteredIndex := [] })
        this.DefineProp('__FilteredItems', { Value: FilteredItems := Map() })
        FilteredIndex.Capacity := FilteredItems.Capacity := this.__InfoItems.Length
        ; If there's only one filter object in the collection, we can save a bit of processing
        ; time by just getting a reference to the object and skipping the second loop.
        if Filter.Count == 1 {
            for FilterIndex, FilterObj in Filter {
                Fn := FilterObj
            }
            for InfoItem in this.__InfoItems {
                if Fn(InfoItem) {
                    continue
                }
                FilteredItems.Set(A_Index, InfoItem)
                FilteredIndex.Push(A_Index)
            }
        } else {
            for InfoItem in this.__InfoItems {
                for FilterIndex, FilterObj in Filter {
                    if FilterObj(InfoItem) {
                        continue 2
                    }
                }
                FilteredItems.Set(A_Index, InfoItem)
                FilteredIndex.Push(A_Index)
            }
        }
        FilteredIndex.Capacity := FilteredItems.Capacity := FilteredItems.Count
        this.__FilterActive := 1
        if IsSet(CacheName) {
            this.FilterCache(CacheName)
        }
        this.__FilterSwitchProps(1)
    }

    /**
     * @description - Activates a cached filter.
     * @param {String|Number} Name - The name of the filter to activate.
     */
    FilterActivateFromCache(Name) {
        this.__FilterActive := 1
        this.__FilteredItems := this.__FilterCache.Get(Name).Items
        this.__FilteredIndex := this.__FilterCache.Get(Name).Index
        this.Filter := this.__FilterCache.Get(Name).FilterGroup
        this.__FilterSwitchProps(1)
    }

    /**
     * @description - Adds a filter to `PropsInfoObj.Filter`.
     * @param {Boolean} [Activate=true] - If true, the filter is activated immediately.
     * @param {...String|Func|Object} Filters - The filters to add. This parameter is variadic.
     * There are four built-in filters which you can include by integer:
     * - 1: Exclude all items that are not own properties of the root object.
     * - 2: Exclude all items that are own properties of the root object.
     * - 3: Exclude all items that have an `Alt` property, i.e. exclude all properties that have
     * multiple owners.
     * - 4: Exclude all items that do not have an `Alt` property, i.e. exclude all properties that
     * have only one owner.
     *
     * In addition to the above, you can pass any of the following:
     * - A string value as a property name to exclude, or a comma-delimited list of property
     * names to exclude.
     * - A `Func`, `BoundFunc` or `Closure`.
     * - An object with a `Call` method.
     * - An object with a `__Call` method.
     *
     * Function objects should accept the `PropsInfoItem` object as its only parameter, and
     * should return a nonzero value to exclude the property. To keep the property, return zero
     * or nothing.
     * @returns {Integer} - If at least one custom filter is added (i.e. a function object or
     * callable object was added), the index that was assignedd to the filter. Indices begin from 5
     * and increment by 1 for each custom filter added. Once an index is used, it will never be used
     * by the `PropsInfo` object again. You can use the index to later delete a filter if needed.
     * Saving the index isn't necessary; you can also delete a filter by passing the function object
     * to `PropsInfo.Prototype.FilterDelete`.
     * The following built-in indices always refer to the same function:
     * - 0: The function which excludes by property name.
     * - 1 through 4: The other built-in filters described above.
     * @throws {ValueError} - If the one of the values passed to `Filters` is invalid.
     */
    FilterAdd(Activate := true, Filters*) {
        if !this.Filter {
            this.DefineProp('Filter', { Value: PropsInfo.FilterGroup() })
        }
        this.DefineProp('FilterAdd', { Call: _FilterAdd })
        this.FilterAdd(Activate, Filters*)

        _FilterAdd(Self, Activate := true, Filters*) {
            result := Self.Filter.Add(Filters*)
            if Activate {
                Self.FilterActivate()
            }
            return result
        }
    }

    /**
     * @description - Adds the currently active filter to the cache.
     * @param {String|Number} Name - The value which will be the key that accesses the filter.
     */
    FilterCache(Name) {
        if !this.__FilterCache {
            this.__FilterCache := Map()
        }
        this.DefineProp('FilterCache', { Call: _FilterCache })
        this.FilterCache(Name)
        _FilterCache(Self, Name) => Self.__FilterCache.Set(Name, { Items: Self.__FilteredItems, Index: Self.__FilteredIndex, FilterGroup: this.Filter })
    }

    /**
     * @description - Clears the filter.
     * @throws {Error} - If the filter is empty.
     */
    FilterClear() {
        if !this.Filter {
            throw Error('The filter is empty.')
        }
        this.Filter.Clear()
        this.Filter.Capacity := 0
        this.Filter.Exclude := ''
    }

    /**
     * @description - Clears the filter cache.
     * @throws {Error} - If the filter cache is empty.
     */
    FilterClearCache() {
        if !this.__FilterCache {
            throw Error('The filter cache is empty.')
        }
        this.__FilterCache.Clear()
        this.__FilterCache.Capacity := 0
    }

    /**
     * @description - Deactivates the currently active filter.
     * @param {String|Number} [CacheName] - If set, the filter is added to the cache with this name prior
     * to being deactivated.
     * @throws {Error} - If the filter is not currently active.
     */
    FilterDeactivate(CacheName?) {
        if !this.__FilterActive {
            throw Error('The filter is not currently active.')
        }
        if IsSet(CacheName) {
            this.FilterCache(CacheName)
        }
        this.__FilterActive := 0
        this.__FilteredItems := ''
        this.__FilteredIndex := ''
        this.__FilterSwitchProps(0)
    }

    /**
     * @description - Deletes an item from the filter.
     * @param {Func|Integer|PropsInfo.Filter|String} Key - One of the following:
     * - The function object.
     * - The index assigned to the `PropsInfo.Filter` object.
     * - The `PropsInfo.Filter` object.
     * - The function object's name.
     * @returns {PropsInfo.Filter} - The filter object that was just deleted.
     * @throws {UnsetItemError} - If `Key` is a function object and the filter does not contain
     * that function.
     * @throws {UnsetItemError} - If `Key` is a string and the filter does not contain a function
     * with that name.
     */
    FilterDelete(Key) {
        return this.Filter.Delete(Key)
    }

    /**
     * @description - Deletes a filter from the cache.
     * @param {String|Integer} Name - The name assigned to the filter.
     * @returns {Map} - The object containing the filter functions that were just deleted.
     * @throws {Error} - If the filter cache is empty.
     */
    FilterDeleteFromCache(Name) {
        if !this.__FilterCache {
            throw Error('The filter cache is empty.')
        }
        r := this.__FilterCache.Get(Name)
        this.__FilterCache.Delete(Name)
        return r
    }

    /**
     * @description - Returns a comma-delimited list of names of properties that were filtered out
     * of the collection.
     * @returns {String}
     */
    FilterGetList() {
        if !this.Filter {
            throw UnsetItemError('No filters have been added.', -1)
        }
        s := ''
        for InfoItem in this.__FilteredItems {
            s .= InfoItem.Name ','
        }
        return SubStr(s, 1, -1)
    }

    /**
     * @description - Removes one or more property names from the exclude list.
     * @param {String} Name - The name to remove or a comma-delimited list of names to remove.
     * @throws {Error} - If the filter is empty.
     */
    FilterRemoveFromExclude(Name) {
        if !this.Filter {
            throw Error('The filter is empty.')
        }
        Filter := this.Filter
        for _name in StrSplit(Name, ',') {
            Filter.Exclude := RegExReplace(Filter.Exclude, ',' _name '(?=,)', '')
        }
    }

    /**
     * @description - Sets the `PropsInfoObj.Filter` property with the filter group.
     * @param {PropsInfo.FilterGroup} FilterGroup - The `PropsInfo.FilterGroup` object.
     * @param {String} [CacheName] - If set, the current filter will be cached. If unset, the
     * current filter is replaced without being cached.
     * @param {Boolean} [Activate := true] - If true, the filter is activated immediately.
     */
    FilterSet(FilterGroup, CacheName?, Activate := true) {
        if IsSet(CacheName) {
            this.FilterCache(CacheName)
        }
        this.DefineProp('Filter', { Value: FilterGroup })
        if Activate {
            this.FilterActivate()
        }
    }

    /**
     * @description - Retrieves a `PropsInfoItem` object.
     * @param {String|Integer} Key - While `PropsInfoObj.StringMode == true`, `Key` must be an
     * integer index value. While `PropsInfoObj.StringMode == false`, `Key` can be either a string
     * property name or an integer index value.
     * @returns {PropsInfoItem}
     * @throws {TypeError} - If `Key` is not a number and `PropsInfoObj.StringMode == true`.
     */
    Get(Key) {
        ; This is overridden
    }

    /**
     * @description - Retrieves the index of a property.
     * @param {String} Name - The name of the property.
     * @returns {Integer} - The index of the property.
     */
    GetIndex(Name) {
        return this.__InfoIndex.Get(Name)
    }

    /**
     * @description - Retrieves a proxy object.
     * @param {String} ProxyType - The type of proxy to create. Valid values are:
     * - 1: `PropsInfo.Proxy_Array`
     * - 2: `PropsInfo.Proxy_Map`
     * @returns {PropsInfo.Proxy_Array|PropsInfo.Proxy_Map}
     * @throws {ValueError} - If `ProxyType` is not 1 or 2.
     */
    GetProxy(ProxyType) {
        switch ProxyType, 0 {
            case '1': return PropsInfo.Proxy_Array(this)
            case '2': return PropsInfo.Proxy_Map(this)
        }
        throw ValueError('The input ``ProxyType`` must be ``1`` or ``2``.', -1
        , IsObject(ProxyType) ? 'Type(ProxyType) == ' Type(ProxyType) : ProxyType)
    }

    /**
     * @description - Iterates the `PropsInfo` object, adding the `PropsInfoItem` objects to
     * a container.
     * @param {*} [Container] - The container to add the filtered `PropsInfoItem` objects to. If set,
     * the object must inherit from either `Map` or `Array`.
     * - If `Container` inherits from `Array`, the `PropsInfoItem` objects are added to the array using
     * `Push`.
     * - If `Container` inherits from `Map`, the `PropsInfoItem` objects are added to the map using
     * `Set`, with the property name as the key. The map's `CaseSense` property must be set to
     * "Off".
     * - If `Container` is unset, `GetFilteredProps` returns a new `PropsInfo` object.
     * @param {Function} [Function] -
     * - If set, a function object that accepts a `PropsInfoItem` object as its only parameter. The
     * function should return a nonzero value to exclude the property. Any currently active filters
     * are ignored.
     * - If unset, `GetFilteredProps` uses the filters that are currently active. The difference
     * between `GetFilteredProps` and either `ToMap` or `ToArray` in this case is that you can
     * supply your own container, or get a new `PropsInfo` object.
     * @returns {PropsInfo|Array|Map} - The container with the filtered `PropsInfoItem` objects.
     * If `Container` is unset, a new `PropsInfo` object is returned.
     * @throws {TypeError} - If `Container` is not an `Array` or `Map`.
     * @throws {Error} - If `Container` is a `Map` and its `CaseSense` property is not set to "Off".
     * @throws {Error} - If the filter is empty.
     */
    GetFilteredProps(Container?, Function?) {
        if IsSet(Container) {
            if Container is Array {
                Set := _Set_Array
                GetCount := () => Container.Length
            } else if Container is Map {
                if Container.CaseSense !== 'Off' {
                    throw Error('CaseSense must be set to "Off".')
                }
                Set := _Set_Map
                GetCount := () => Container.Count
            } else {
                throw TypeError('Unexpected container type.', -1, 'Type(Container) == ' Type(Container))
            }
        } else {
            Container := Map()
            Container.CaseSense := false
            Set := _Set_Map
            GetCount := () => Container.Count
            Flag_MakePropsInfo := true
        }
        Excluded := this.Excluded ','
        InfoItems := this.__InfoItems
        Container.Capacity := InfoItems.Length
        if IsSet(Function)  {
            for InfoItem in InfoItems {
                if Function(InfoItem) {
                    if !InStr(Excluded, ',' InfoItem.Name ',') {
                        Excluded .= InfoItem.Name ','
                    }
                    continue
                }
                Set(InfoItem)
            }
        } else if this.Filter {
            Filter := this.Filter
            if Filter.Count == 1 {
                for FilterIndex, FilterObj in Filter {
                    Fn := FilterObj
                }
                for InfoItem in InfoItems {
                    if Fn(InfoItem) {
                        if !InStr(Excluded, ',' InfoItem.Name ',') {
                            Excluded .= InfoItem.Name ','
                        }
                        continue
                    }
                    Set(InfoItem)
                }
            } else {
                for InfoItem in Infoitems {
                    for FilterIndex, FilterObj in Filter {
                        if FilterObj(InfoItem) {
                            if !InStr(Excluded, ',' InfoItem.Name ',') {
                                Excluded .= InfoItem.Name ','
                            }
                            continue 2
                        }
                    }
                    Set(InfoItem)
                }
            }
        } else {
            throw Error('The filter is empty.')
        }
        Container.Capacity := GetCount()
        return IsSet(Flag_MakePropsInfo) ? PropsInfo(Container, this.__PropsInfoItemBase, Trim(StrReplace(Excluded, ',,', ','), ',')) : Container

        _Set_Array(InfoItem) => Container.Push(InfoItem)
        _Set_Map(InfoItem) => Container.Set(InfoItem.Name, InfoItem)
    }

    /**
     * @description - Checks if a property exists in the `PropsInfo` object.
     */
    Has(Key) {
        return IsNumber(Key) ? this.__InfoItems.Has(Key) : this.__InfoIndex.Has(Key)
    }

    /**
     * @description - Iterates the root object's properties, updating the `PropsInfo` object's
     * internal containers to reflect the current state of the objects. This does not change the
     * items exposed by the currently active filter nor any cached filters. To update a filter,
     * call `PropsInfo.Prototype.FilterActivate` after calling `PropsInfo.Prototype.Delete`,
     * `PropsInfo.Prototype.Refresh`, or `PropsInfo.Prototype.RefreshProp`.
     *
     * - The reason for using `PropsInfo.Prototype.Refresh` instead of calling `GetPropsInfo`
     * would be to preserve any changes that external code has made to the `PropsInfo` object or the
     * `PropsInfoItem` objects. If your code has not made any changes to any of the objects,
     * calling `GetPropsInfo` will perform better than calling `PropsInfo.Prototype.Refresh`.
     *
     * - `PropsInfoObj.FilterActive` and `PropsInfoObj.StringMode` are set to `0` at the start of the
     * procedure, and returned to their original values at the end.
     *
     * - `PropsInfo.Prototype.Refresh` will update the `InfoItem.Alt` array to be consistent with
     * the objects' current state. Any items that are removed are returned when the function ends.
     *
     * - `PropsInfo.Prototype.Refresh` updates the `PropsInfoObj.Excluded` property and the
     * `PropsInfoObj.InheritanceDepth` property.
     *
     * - If an object no longer owns a property by the name, the `PropsInfoItem` object is removed
     * from the collection and added to the returned array.
     *
     * - `InfoItem.Count` is updated for any additions and deletions.
     *
     * - `PropsInfo.Prototype.Refresh` will swap the top-level `PropsInfoItem` object if a new
     * `PropsInfoItem` object is created with a lower `Index` property value than the current top-level
     * item. The original top-level item has the `Alt` property deleted if present, then gets added
     * to the `Alt` property of the new top-level item. This is to ensure consistency that the top-level
     * `PropsInfoItem` object is always associated with either the root object or the object from
     * which the root object inherits the property.
     *
     * @param {Integer|String} [StopAt=GPI_STOP_AT_DEFAULT ?? '-Object'] - If an integer, the number of
     * base objects to traverse up the inheritance chain. If a string, the name of the class to stop at.
     * You can define a global variable `GPI_STOP_AT_DEFAULT` to change the default value. If
     * GPI_STOP_AT_DEFAULT is unset, the default value is '-Object', which directs
     * `PropsInfo.Prototype.Refresh` to include properties owned by objects up to but not including
     * `Object.Prototype`.
     * @see {@link GetBaseObjects} for full details about this parameter.
     * @param {String} [Exclude=''] - A comma-delimited, case-insensitive list of properties to exclude.
     * For example: "Length,Capacity,__Item".
     * @param {Boolean} [IncludeBaseProp=true] - If true, the object's `Base` property is included. If
     * false, `Base` is excluded.
     * @param {VarRef} [OutBaseObjList] - A variable that will receive a reference to the array of
     * base objects that is generated during the function call.
     * @param {Boolean} [ExcludeMethods=false] - If true, callable properties are excluded. Note that
     * properties with a value that is a class object are unaffected by `ExcludeMethods`.
     * @returns {PropsInfoItem[]|String} - If any items are removed from the collection they are
     * added to an array to be returned. Else, returns an empty string.
     */
    Refresh(StopAt := GPI_STOP_AT_DEFAULT ?? '-Object', Exclude := '', IncludeBaseProp := true, &OutBaseObjList?, ExcludeMethods := false) {
        if this.FilterActive {
            OriginalFilterActive := this.FilterActive
            this.FilterActive := 0
        }
        Excluded := ','
        InfoItems := this.__InfoItems
        InfoIndex := this.__InfoIndex
        OriginalStringMode := this.StringMode
        this.StringMode := 0
        Obj := this.Root
        AltMap := Map()
        AltMap.CaseSense := false
        OutBaseObjList := GetBaseObjects(Obj, StopAt)
        this.__PropsInfoItemBase.InheritanceDepth := OutBaseObjList.Length
        OutBaseObjList.InsertAt(1, Obj)
        Exclude := ',' Exclude ','
        ToDelete := ''
        ActivePropsList := this.ToMap()
        Deleted := []
        i := -1
        for b in OutBaseObjList {
            ++i
            for Prop in ObjOwnProps(b) {
                if InStr(Exclude, ',' Prop ',') || (ExcludeMethods && HasMethod(Obj, Prop) && not Obj.%Prop% is Class) {
                    if this.Has(Prop) {
                        ToDelete .= Prop ','
                    }
                    if !InStr(Excluded, ',' Prop ',') {
                        Excluded .= Prop ','
                    }
                    continue
                }
                this.__RefreshProcess(ActivePropsList, AltMap, i, Prop, b)
            }
            if IncludeBaseProp {
                this.__RefreshProcess(ActivePropsList, AltMap, i, 'Base', b)
            }
        }
        for name, InfoItem in ActivePropsList {
            ToDelete .= name ','
        }
        if ToDelete := Trim(ToDelete, ',') {
            if DeletedItems := this.Delete(ToDelete) {
                Deleted.Push(DeletedItems*)
            }
        }
        for Prop, IndexList in AltMap {
            if InfoItem := this.Get(Prop) {
                if IndexList := Trim(IndexList, ',') {
                    if InfoItem.HasOwnProp('Alt') {
                        for s in StrSplit(IndexList, ',') {
                            if s {
                                i := 0
                                Alt := InfoItem.Alt
                                loop Alt.Length {
                                    if Alt[++i].Index = s {
                                        Deleted.Push(Alt.RemoveAt(i))
                                        this.__RefreshIncrementCount(InfoItem, -1)
                                        i--
                                        break
                                    }
                                }
                            }
                        }
                    }
                }
                if InfoItem.HasOwnProp('Alt') && !InfoItem.Alt.Length {
                    InfoItem.DeleteProp('Alt')
                }
            }
        }
        if IsSet(OriginalFilterActive) {
            this.FilterActive := OriginalFilterActive
        }
        this.StringMode := OriginalStringMode
        this.Excluded := Trim(Excluded, ',')
        return Deleted.Length ? Deleted : ''
    }

    /**
     * @description - For each name listed in `Names`, the root object and its base objects are
     * iterated. If an object owns a property with a given name, and if the current collection does not
     * have an associated `PropsInfoItem` object for the property, a `PropsInfoItem` object is
     * created and added to the collection. This does not change the items exposed by the currently
     * active filter nor any cached filters. To update a filter, call
     * `PropsInfo.Prototype.FilterActivate` after calling `PropsInfo.Prototype.Delete`,
     * `PropsInfo.Prototype.Refresh`, or `PropsInfo.Prototype.RefreshProp`.
     *
     * - `PropsInfoObj.FilterActive` and `PropsInfoObj.StringMode` are set to `0` at the start of the
     * procedure, and returned to their original values at the end.
     *
     * - `PropsInfo.Prototype.RefreshProp` will update the `InfoItem.Alt` array to be consistent with
     * the objects' current state. Any items that are removed are returned when the function ends.
     *
     * - `PropsInfo.Prototype.RefreshProp` updates the `PropsInfoObj.Excluded` property and the
     * `PropsInfoObj.InheritanceDepth` property.
     *
     * - If an object no longer owns a property by the name, the `PropsInfoItem` object is removed
     * from the collection and added to the returned array.
     *
     * - `InfoItem.Count` is updated for any additions and deletions.
     *
     * - `PropsInfo.Prototype.RefreshProp` will swap the top-level `PropsInfoItem` object if a new
     * `PropsInfoItem` object is created with a lower `Index` property value than the current top-level
     * item. The original top-level item has the `Alt` property deleted if present, then gets added
     * to the `Alt` property of the new top-level item. This is to ensure consistency that the top-level
     * `PropsInfoItem` object is always associated with either the root object or the object from
     * which the root object inherits the property.
     *
     * @param {String} Names - A comma-delimited list of property names to update. For example,
     * "__Class,Length".
     * @param {Integer|String} [StopAt=GPI_STOP_AT_DEFAULT ?? '-Object'] - If an integer, the number of
     * base objects to traverse up the inheritance chain. If a string, the name of the class to stop at.
     * You can define a global variable `GPI_STOP_AT_DEFAULT` to change the default value. If
     * GPI_STOP_AT_DEFAULT is unset, the default value is '-Object', which directs
     * `PropsInfo.Prototype.Add` to include properties owned by objects up to but not including
     * `Object.Prototype`.
     * @see {@link GetBaseObjects} for full details about this parameter.
     * @param {VarRef} [OutBaseObjList] - A variable that will receive a reference to the array of
     * base objects that is generated during the function call.
     * @returns {PropsInfoItem[]|String} - If any items are removed from the collection they are
     * added to an array to be returned. Else, returns an empty string.
     */
    RefreshProp(Names, StopAt := GPI_STOP_AT_DEFAULT ?? '-Object', &OutBaseObjList?) {
        if this.FilterActive {
            OriginalFilterActive := this.FilterActive
            this.FilterActive := 0
        }
        OriginalStringMode := this.StringMode
        this.StringMode := 0
        OutBaseObjList := GetBaseObjects(this.Root, StopAt)
        this.__PropsInfoItemBase.InheritanceDepth := OutBaseObjList.Length
        OutBaseObjList.InsertAt(1, this.Root)
        Names := StrSplit(Trim(Names, ','), ',', '`s`t')
        Deleted := []
        Excluded := ',' this.Excluded ','
        for Prop in Names {
            i := -1
            if InStr(Excluded, ',' Prop ',') {
                Excluded := StrReplace(Excluded, ',' Prop, '')
            }
            if this.Has(prop) {
                InfoItem := this.Get(Prop)
                IndexList := ',' InfoItem.Index ','
                if InfoItem.HasOwnProp('Alt') {
                    for AltInfoItem in InfoItem.Alt {
                        IndexList .= AltInfoItem.Index ','
                    }
                }
                for b in OutBaseObjList {
                    ++i
                    if b.HasOwnProp(Prop) {
                        if InStr(IndexList, ',' i ',') {
                            if InfoItem.Index = i {
                                InfoItem.Refresh()
                            } else {
                                for AltInfoItem in InfoItem.Alt {
                                    if AltInfoItem.Index = i {
                                        AltInfoItem.Refresh()
                                        break
                                    }
                                }
                            }
                        } else {
                            if Prop = 'Base' {
                                if i < InfoItem.Index {
                                    this.__RefreshSwap(i, InfoItem, b)
                                } else {
                                    this.__RefreshBaseProp(i, b)
                                }
                            } else {
                                if i < InfoItem.Index {
                                    this.__RefreshSwap(i, InfoItem, b)
                                } else {
                                    this.__RefreshAdd(i, Prop, b)
                                }
                            }
                        }
                    } else {
                        if InStr(IndexList, ',' i ',') {
                            if InfoItem.Index = i {
                                if InfoItem.HasOwnProp('Alt') {
                                    if InfoItem.Alt.Length > 1 {
                                        lowest := 9223372036854775807
                                        for AltInfoItem in InfoItem.Alt {
                                            if AltInfoItem.Index < lowest {
                                                lowest := AltInfoItem.Index
                                                LowestIndex := A_Index
                                            }
                                        }
                                        AltInfoItem := InfoItem.Alt.RemoveAt(LowestIndex)
                                        AltInfoItem.DefineProp('Alt', { Value: InfoItem.Alt })
                                    } else {
                                        AltInfoItem := InfoItem.Alt[1]
                                        InfoItem.DeleteProp('Alt')
                                    }
                                    this.__InfoItems[this.__InfoIndex.Get(Prop)] := AltInfoItem
                                    Deleted.Push(InfoItem)
                                    this.__RefreshIncrementCount(InfoItem, -1)
                                    AltInfoItem.Refresh()
                                } else {
                                    Deleted.Push(this.__InfoItems.RemoveAt(this.__InfoIndex.Get(Prop)))
                                    this.__RefreshIncrementCount(InfoItem, -1)
                                }
                            } else {
                                for AltInfoItem in InfoItem.Alt {
                                    if AltInfoItem.Index = i {
                                        Deleted.Push(InfoItem.Alt.RemoveAt(A_Index))
                                        this.__RefreshIncrementCount(InfoItem, -1)
                                        break
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if Prop = 'Base' {
                    for b in OutBaseObjList {
                        this.__RefreshBaseProp(++i, b)
                    }
                } else {
                    for b in OutBaseObjList {
                        ++i
                        if b.HasOwnProp(Prop) {
                            this.__RefreshAdd(i, Prop, b)
                        }
                    }
                }
            }
        }
        if IsSet(OriginalFilterActive) {
            this.FilterActive := OriginalFilterActive
        }
        this.StringMode := OriginalStringMode
        this.Excluded := Trim(Excluded, ',')

        return Deleted.Length ? Deleted : ''
    }

    /**
     * @description - Iterates the `PropsInfo` object, adding the `PropsInfoItem` objects to an array,
     * or adding the property names to an array.
     * @param {Boolean} [NamesOnly=false] - If true, the property names are added to the array. If
     * false, the `PropsInfoItem` objects are added to the array.
     * @returns {Array} - The array of property names or `PropsInfoItem` objects.
     */
    ToArray(NamesOnly := false) {
        Result := []
        Result.Capacity := this.__InfoItems.Length
        if NamesOnly {
            for Item in this.__InfoItems {
                Result.Push(Item.Name)
            }
        } else {
            for Item in this.__InfoItems {
                Result.Push(Item)
            }
        }
        return Result
    }

    /**
     * @description - Iterates the `PropsInfo` object, adding the property names and optionally
     * the property values to a string. Object values are represented using this function:
     * @example
     * _GetDisplayType(value) {
     *     if ObjHasOwnProp(value, "__Class") {
     *         return "{ Prototype : " value.__Class " }"
     *     } else if value is Class {
     *         return "{ Class : " value.Prototype.__Class " }"
     *     } else {
     *         return "{ " value.__Class " }"
     *     }
     * }
     * @
     *
     * @param {Boolean} [NamesOnly = false] - If true, only the property names are added to the string.
     * If false, the property names are followed by the property values separated by a colon and
     * space.
     * @param {String} [Separator = "`n"] - The substring that separaters each item.
     * @param {Boolean} [Call = true] - If true, properties with a Call accessor are grouped beneath
     * the Get / value properties underneath a section header "Methods".
     * @param {Boolean} [Get = true] - If true, properties with a Get accessor will be represented
     * in the list.
     * @param {Boolean} [Set = true] - If true, properties with a Set accessor are grouped beneath
     * the Get / value properties underneath a section header "Setters".
     * @param {Boolean} [Value = true] - If true, value properties will be represented in the list.
     * @param {Boolean} [IncludeErrors = false] - If true, and if `NamesOnly` is false, properties
     * that result in an error when calling {@link PropsInfoItem.Prototype.GetValue} are represented
     * in the list. If `NamesOnly` is true, {@link PropsInfoItem.Prototype.GetValue} is not called,
     * so all properties are represented in the list.
     * @param {String} [headerSeparator = "`n`n"] - The substring that separates the primary property
     * list (Get properties and value properties) from methods (properties with a Call accessor) and
     * from setters (properties with a Set accessor).
     *
     * @returns {String} - The list of property names and/or values.
     */
    ToList(NamesOnly := false, separator := '`n', Call := true, Get := true, Set := true, Value := true, IncludeErrors := false, headerSeparator := '`n`n') {
        s := ''
        VarSetStrCapacity(&s, 2048)
        if Call {
            methods := ''
            VarSetStrCapacity(&methods, 2048)
        }
        if Set {
            setters := ''
            VarSetStrCapacity(&setters, 2048)
        }
        if NamesOnly {
            for item in this.__InfoItems {
                switch item.KindIndex {
                    case 1:
                        if Call {
                            methods .= item.Name separator
                        }
                    case 2:
                        if Get {
                            s .= item.Name separator
                        }
                    case 3:
                        if Get {
                            s .= item.Name separator
                        }
                        if Set {
                            setters .= item.Name separator
                        }
                    case 4:
                        if Set {
                            setters .= item.Name separator
                        }
                    case 5:
                        if Value {
                            s .= item.Name separator
                        }
                }
            }
        } else {
            for item in this.__InfoItems {
                switch item.KindIndex {
                    case 1:
                        if Call {
                            methods .= item.Name separator
                        }
                    case 2:
                        if Get {
                            if item.GetValue(&value) {
                                if IncludeErrors {
                                    s .= item.Name ': ' Type(value) ' - ' value.Message separator
                                }
                            } else {
                                if IsObject(value) {
                                    s .= item.Name ': ' _GetDisplayType(value) separator
                                } else {
                                    s .= item.Name ': ' _Escape(value) separator
                                }
                            }
                        }
                    case 3:
                        if Get {
                            if item.GetValue(&value) {
                                if IncludeErrors {
                                    s .= item.Name ': ' Type(value) ' - ' value.Message separator
                                }
                            } else {
                                if IsObject(value) {
                                    s .= item.Name ': ' _GetDisplayType(value) separator
                                } else {
                                    s .= item.Name ': ' _Escape(value) separator
                                }
                            }
                        }
                        if Set {
                            setters .= item.Name separator
                        }
                    case 4:
                        if Set {
                            setters .= item.Name separator
                        }
                    case 5:
                        if Value {
                            if !item.GetValue(&value) {
                                if IsObject(value) {
                                    s .= item.Name ': ' _GetDisplayType(value) separator
                                } else {
                                    s .= item.Name ': ' _Escape(value) separator
                                }
                            }
                        }
                }
            }
        }
        lenSeparator := -StrLen(separator)
        if s {
            s := SubStr(s, 1, lenSeparator)
        }
        if methods {
            methods := SubStr(methods, 1, lenSeparator)
        }
        if setters {
            setters := SubStr(setters, 1, lenSeparator)
        }
        if s {
            if methods {
                s .= headerSeparator 'Methods' separator methods
            }
            if setters {
                s .= headerSeparator 'Setters' separator setters
            }
        } else if methods {
            s := 'Methods' separator methods
            if setters {
                s .= headerSeparator 'Setters' separator setters
            }
        } else if setters {
            s := 'Setters' separator setters
        }

        return s

        _GetDisplayType(value) {
            if ObjHasOwnProp(value, '__Class') {
                return '{ Prototype : ' value.__Class ' }'
            } else if value is Class {
                return '{ Class : ' value.Prototype.__Class ' }'
            } else {
                return '{ ' value.__Class ' }'
            }
        }
        _Escape(value) {
            return StrReplace(StrReplace(value, '`n', '``n'), '`r', '``r')
        }
    }

    /**
     * @description - Iterates the `PropsInfo` object, adding the `PropsInfoItem` objects to a map.
     * The keys are the property names.
     * @returns {Map} - The map of property names and `PropsInfoItem` objects.
     */
    ToMap() {
        Result := Map()
        Result.Capacity := this.__InfoItems.Length
        for InfoItem in this.__InfoItems {
            Result.Set(InfoItem.Name, InfoItem)
        }
        return Result
    }

    /**
     * @memberof PropsInfo
     * @instance
     * @readonly
     */
    Capacity => this.__InfoIndex.Capacity
    /**
     * @memberof PropsInfo
     * @instance
     * @readonly
     */
    CaseSense => this.__InfoIndex.CaseSense
    /**
     * @memberof PropsInfo
     * @instance
     * @readonly
     */
    Count => this.__InfoIndex.Count
    /**
     * @memberof PropsInfo
     * @instance
     * @readonly
     */
    Default => this.__InfoIndex.Default
    /**
     * @memberof PropsInfo
     * @instance
     * @readonly
     */
    InheritanceDepth => this.__PropsInfoItemBase.InheritanceDepth
    /**
     * @memberof PropsInfo
     * @instance
     * @readonly
     */
    Length => this.__InfoItems.Length
    /**
     * @memberof PropsInfo
     * @instance
     * @readonly
     */
    Root => this.__PropsInfoItemBase.Root

    /**
     * Set to a nonzero value to activate the current filter. Set to a falsy value to deactivate.
     * While a filter is active, the values retured by the `PropsInfo` object's methods and properties
     * will be filtered. See the parameter hint above `PropsInfo.Prototype.FilterActivate` for
     * additional details.
     * @memberof PropsInfo
     * @instance
     */
    FilterActive {
        Get => this.__FilterActive
        Set {
            if Value {
                this.FilterActivate()
            } else {
                this.FilterDeactivate()
            }
        }
    }

    /**
     * Set to a nonzero value to activate string mode. Set to a falsy value to deactivate.
     * While string mode is active, the `PropsInfo` object emulates the behavior of an array of
     * strings. The following properties and methods are influenced by string mode:
     * __Enum, Get, __Item
     * By extension, the proxies are also affected.
     * @memberof PropsInfo
     * @instance
     */
    StringMode {
        Get => this.__StringMode
        Set {
            if this.__FilterActive {
                if Value {
                    this.DefineProp('__StringMode', { Value: 1 })
                    this.DefineProp('Get', { Call: this.__FilteredGet_StringMode })
                } else {
                    this.DefineProp('__StringMode', { Value: 0 })
                    this.DefineProp('Get', { Call: this.__FilteredGet_Bitypic })
                }
            } else {
                if Value {
                    this.DefineProp('__StringMode', { Value: 1 })
                    this.DefineProp('Get', { Call: this.__ItemGet_StringMode })
                } else {
                    this.DefineProp('__StringMode', { Value: 0 })
                    this.DefineProp('Get', { Call: this.__ItemGet_Bitypic })
                }
            }
        }
    }

    /**
     * @description - `__Enum` is influenced by both string mode and any active filters. It can
     * be called in either 1-param mode or 2-param mode.
     */
    __Enum(VarCount) {
        i := 0
        if this.__FilterActive {
            Index := this.__FilteredIndex
            FilteredItems := this.__FilteredItems
            return this.__StringMode ? _Filtered_Enum_StringMode_%VarCount% : _Filtered_Enum_%VarCount%
        } else {
            InfoItems := this.__InfoItems
            return this.__StringMode ? _Enum_StringMode_%VarCount% : _Enum_%VarCount%
        }
        _Enum_1(&InfoItem) {
            if ++i > InfoItems.Length {
                return 0
            }
            InfoItem := InfoItems[i]
            return 1
        }
        _Enum_2(&Prop, &InfoItem) {
            if ++i > InfoItems.Length {
                return 0
            }
            InfoItem := InfoItems[i]
            Prop := InfoItem.Name
            return 1
        }
        _Enum_StringMode_1(&Prop) {
            if ++i > InfoItems.Length {
                return 0
            }
            Prop := InfoItems[i].Name
            return 1
        }
        _Enum_StringMode_2(&Index, &Prop) {
            if ++i > InfoItems.Length {
                return 0
            }
            Index := i
            Prop := InfoItems[i].Name
            return 1
        }
        _Filtered_Enum_1(&InfoItem) {
            if ++i > Index.Length {
                return 0
            }
            InfoItem := FilteredItems[Index[i]]
            return 1
        }
        _Filtered_Enum_2(&Prop, &InfoItem) {
            if ++i > Index.Length {
                return 0
            }
            InfoItem := FilteredItems[Index[i]]
            Prop := InfoItem.Name
            return 1
        }
        _Filtered_Enum_StringMode_1(&Prop) {
            if ++i > Index.Length {
                return 0
            }
            Prop := FilteredItems[Index[i]].Name
            return 1
        }
        _Filtered_Enum_StringMode_2(&Index, &Prop) {
            if ++i > Index.Length {
                return 0
            }
            Index := i
            Prop := FilteredItems[Index[i]].Name
            return 1
        }
    }

    /**
     * @description - Allows access to the `PropsInfoItem` objects using `Obj[Key]` syntax. Forwards
     * the `Key` to the `Get` method. {@link PropsInfo#Get}.
     */
    __Item[Key] => this.Get(Key)

    __ItemGet_StringMode(Index) {
        if !IsNumber(Index) {
            this.__ThrowTypeError()
        }
        return this.__InfoItems[Index].Name
    }

    __ItemGet_Bitypic(Key) {
        return this.__InfoItems[IsNumber(Key) ? Key : this.__InfoIndex.Get(Key)]
    }

    __FilteredGet_StringMode(Index) {
        if !IsNumber(Index) {
            this.__ThrowTypeError()
        }
        return this.__InfoItems[this.__FilteredIndex[Index]].Name
    }

    __FilteredGet_Bitypic(Key) {
        if IsNumber(Key) {
            return this.__InfoItems[this.__FilteredIndex[Key]]
        } else {
            return this.__FilteredItems.Get(this.__InfoIndex.Get(Key))
        }
    }

    __FilteredHas(Key) {
        if IsNumber(Key) {
            return this.__FilteredItems.Has(this.__InfoIndex.Get(this.__InfoItems[Key].Name))
        } else {
            return this.__FilteredItems.Has(this.__InfoIndex.Get(Key))
        }
    }

    __FilteredToArray(NamesOnly := false) {
        Result := []
        Result.Capacity := this.__FilteredItems.Count
        if NamesOnly {
            for i, InfoItem in this.__FilteredItems {
                Result.Push(InfoItem.Name)
            }
        } else {
            for i, InfoItem in this.__FilteredItems {
                Result.Push(InfoItem)
            }
        }
        return Result
    }

    __FilteredToMap(NamesOnly := false) {
        Result := Map()
        Result.Capacity := this.__FilteredItems.Count
        for i, InfoItem in this.__FilteredItems {
            Result.Set(InfoItem.Name, InfoItem)
        }
        return Result
    }

    __FilterSwitchProps(Value) {
        Proto := PropsInfo.Prototype
        if Value {
            for Name in this.__OnFilterProperties {
                this.DefineProp(Name, Proto.GetOwnPropDesc('__Filtered' Name))
            }
            this.DefineProp('Get', Proto.GetOwnPropDesc(this.__StringMode ? '__FilteredGet_StringMode' : '__FilteredGet_Bitypic'))
        } else {
            for Name in this.__OnFilterProperties {
                this.DefineProp(Name, Proto.GetOwnPropDesc(Name))
            }
            this.DefineProp('Get', Proto.GetOwnPropDesc(this.__StringMode ? '__ItemGet_StringMode' : '__ItemGet_Bitypic'))
        }
    }

    __RefreshAdd(Index, Prop, Obj) {
        if this.Has(Prop) {
            b := InfoItem := this.Get(Prop)
            while !b.HasOwnProp('Name') {
                b := b.Base
            }
            ObjSetBase(Item := ObjGetOwnPropDesc(Obj, InfoItem.Name), b)
            Item.Index := Index
            InfoItem.__SetAlt(Item)
            b.Count++
        } else {
            ObjSetBase(ItemBase := { Name: Prop, Count: 1 }, this.__PropsInfoItemBase)
            ObjSetBase(Item := ObjGetOwnPropDesc(Obj, Prop), ItemBase)
            Item.Index := Index
            this.__InfoItems.Push(Item)
            this.__InfoIndex.Set(Prop, this.__InfoItems.Length)
        }
    }

    __RefreshBaseProp(Index, Obj) {
        if this.Has('Base') {
            b := InfoItem := this.Get('Base')
            while !b.HasOwnProp('Name') {
                b := b.Base
            }
            ObjSetBase(Item := { Value: Obj.Base, Index: Index }, b)
            InfoItem.__SetAlt(Item)
            b.Count++
        } else {
            ObjSetBase(ItemBase := { Name: 'Base', Count: 1 }, this.__PropsInfoItemBase)
            ObjSetBase(InfoItem := { Value: Obj.Base, Index: Index }, ItemBase)
            this.__InfoItems.Push(InfoItem)
            this.__InfoIndex.Set('Base', this.__InfoItems.Length)
        }
    }

    __RefreshIncrementCount(InfoItem, Count) {
        loop this.InheritanceDepth {
            if InfoItem.HasOwnProp('Count') {
                InfoItem.Count += Count
                return
            } else {
                InfoItem := InfoItem.Base
            }
        }
        throw Error('Failed to increment the count.', -1, '``InfoItem.Name == ' InfoItem.Name)
    }

    __RefreshProcess(ActivePropsList, AltMap, Index, Prop, Obj) {
        if ActivePropslist && ActivePropsList.Has(Prop) {
            ActivePropsList.Delete(Prop)
        }
        if this.Has(Prop) {
            InfoItem := this.Get(Prop)
            if !AltMap.Has(InfoItem.Name) {
                indexList := ',' InfoItem.Index ','
                if InfoItem.HasOwnProp('Alt') {
                    for AltInfoItem in InfoItem.Alt {
                        indexList .= AltInfoItem.Index ','
                    }
                }
                AltMap.Set(InfoItem.Name, indexList)
            }
            if InStr(AltMap.Get(InfoItem.Name), ',' Index ',') {
                AltMap.Set(InfoItem.Name, StrReplace(AltMap.Get(InfoItem.Name), ',' Index, ''))
                InfoItem.Refresh()
            } else {
                if Index < InfoItem.Index {
                    this.__RefreshSwap(Index, InfoItem, Obj)
                } else {
                    if Prop == 'Base' {
                        this.__RefreshBaseProp(Index, Obj)
                    } else {
                        this.__RefreshAdd(Index, Prop, Obj)
                    }
                }
            }
        } else {
            if Prop == 'Base' {
                this.__RefreshBaseProp(Index, Obj)
            } else {
                this.__RefreshAdd(Index, Prop, Obj)
            }
        }
    }

    __RefreshSwap(Index, InfoItem, Obj) {
        if InfoItem.Name = 'Base' {
            if Type(Obj) == 'Prototype' && Obj.__Class == 'Any' {
                return
            }
            Item := { Value: Obj.Base, Index: Index }
        } else {
            Item := ObjGetOwnPropDesc(Obj, InfoItem.Name)
            Item.Index := InfoItem.Index
        }
        InfoItem.Index := Index
        switch InfoItem.KindIndex {
            case 1: _SwapProps(['Call'], ['Get', 'Set', 'Value'])
            case 2: _SwapProps(['Get'], ['Call', 'Set', 'Value'])
            case 3: _SwapProps(['Get', 'Set'], ['Call', 'Value'])
            case 4: _SwapProps(['Set'], ['Call', 'Get', 'Value'])
            case 5: _SwapProps(['Value'], ['Call', 'Get', 'Set'])
        }
        b := InfoItem.Base
        while !b.HasOwnProp('Name') {
            b := b.Base
        }
        ObjSetBase(Item, b)
        b.Count++
        InfoItem.__SetAlt(Item)
        InfoItem.__DefineKindIndex()

        _SwapProps(PrimaryProps, AlternateProps) {
            for Prop in PrimaryProps {
                if Item.HasOwnProp(Prop) {
                    temp := InfoItem.%Prop%
                    InfoItem.DefineProp(Prop, { Value: Item.%Prop% })
                    Item.DefineProp(Prop, { Value: temp })
                } else {
                    Item.DefineProp(Prop, { Value: InfoItem.%Prop% })
                    InfoItem.DeleteProp(Prop)
                }
            }
            for Prop in AlternateProps {
                if Item.HasOwnProp(Prop) {
                    InfoItem.DefineProp(Prop, { Value: Item.%Prop% })
                    Item.DeleteProp(Prop)
                }
            }
        }
    }

    __ThrowTypeError() {
        ; To aid in debugging; if `StringMode == true`, then the object is supposed to behave
        ; like an array of strings, and so accessing an item by name is invalid and represents
        ; an error in the code.
        throw TypeError('Invalid input. While the ``PropsInfo`` object is in string mode,'
        ' items can only be accessed using numeric indices.', -2)
    }

    __FilteredCapacity => this.__FilteredItems.Capacity
    __FilteredCount => this.__FilteredItems.Count
    __FilteredLength => this.__FilteredItems.Count

    /**
     * `PropsInfo.Filter` constructs the filter objects when a filter is added using
     * `PropsInfo.Prototype.FilterAdd`. Filter objects have four properties:
     * - Index: The object's index which can be used to access or delete the object from the filter.
     * - Function: The function object.
     * - Call: The `Call` method which redirects the input parameter to the function and returns
     * the return value.
     * - Name: Returns the function's built-in name.
     * @classdesc
     */
    class Filter {
        __New(Function, Index) {
            this.DefineProp('Call', { Call: _Filter })
            this.Function := Function
            this.Index := Index

            _Filter(Self, Item) {
                Function := this.Function
                return Function(Item)
            }
        }
        Name => this.Function.Name
    }

    class FilterGroup extends Map {
        __New(Filters*) {
            this.Exclude := ''
            this.__Index := 5
            if Filters.Length {
                this.Add(Filters*)
            }
        }

        /**
         * @see {@link PropsInfo#FilterAdd}
         */
        Add(Filters*) {
            for filter in Filters {
                if IsObject(filter) {
                    if filter is Func || HasMethod(filter, 'Call') || HasMethod(filter, '__Call') {
                        if !IsSet(Start) {
                            Start := this.__Index
                        }
                        this.Set(this.__Index, PropsInfo.Filter(filter, this.__Index++))
                    } else {
                        throw ValueError('A value passed to the ``Filters`` parameter is invalid.', -1
                        , 'Type(Value): ' Type(filter))
                    }
                } else {
                    switch filter, 0 {
                        case '1', '2', '3', '4':
                            this.Set(filter, PropsInfo.Filter(_filter_%filter%, filter))
                        default:
                            if SubStr(this.Exclude, -1, 1) == ',' {
                                this.Exclude .= filter
                            } else {
                                this.Exclude .= ',' filter
                            }
                            Flag_Exclude := true
                    }
                }
            }
            if IsSet(Flag_Exclude) {
                ; By ensuring every name has a comma on both sides, we can check the names by
                ; using `InStr(Filter.Exclude, ',' Prop ',')` which should perform better than RegExMatch.
                this.Exclude .= ','
                this.Set(0, PropsInfo.Filter(_Exclude, 0))
            }

            ; If a custom filter is added, return the start index so the caller function can keep track.
            return Start ?? ''

            _Exclude(InfoItem) {
                return InStr(this.Exclude, ',' InfoItem.Name ',')
            }
            _Filter_1(InfoItem) => InfoItem.Index
            _Filter_2(InfoItem) => !InfoItem.Index
            _Filter_3(InfoItem) => InfoItem.HasOwnProp('Alt')
            _Filter_4(InfoItem) => !InfoItem.HasOwnProp('Alt')
        }

        /**
         * @see {@link PropsInfo#FilterDelete}
         */
        Delete(Key) {
            local r
            if Key is Func {
                ptr := ObjPtr(Key)
                for Index, FilterObj in this {
                    if ObjPtr(FilterObj.Function) == ptr {
                        r := FilterObj
                        break
                    }
                }
                if IsSet(r) {
                    this.__MapDelete(r.Index)
                } else {
                    throw UnsetItemError('The function passed to ``Key`` is not in the filter.', -1)
                }
            } else if IsObject(Key) {
                r := this.Get(Key.Index)
                this.__MapDelete(Key.Index)
            } else if IsNumber(Key) {
                r := this.Get(Key)
                this.__MapDelete(Key)
            } else {
                for Fn in this {
                    if Fn.Name == Key {
                        r := Fn
                        break
                    }
                }
                if IsSet(r) {
                    this.__MapDelete(r.Index)
                } else {
                    throw UnsetItemError('The filter does not contain a function with that name.', -2, Key)
                }
            }
            return r
        }

        /**
         * @see {@link PropsInfo#FilterRemoveFromExclude}
         */
        RemoveFromExclude(Name) {
            for _name in StrSplit(Name, ',') {
                this.Exclude := RegExReplace(this.Exclude, ',' _name '(?=,)', '')
            }
        }

        static __New() {
            this.DeleteProp('__New')
            this.Prototype.DefineProp('__MapDelete', Map.Prototype.GetOwnPropDesc('Delete'))
        }
    }

    class Options {
        static __New() {
            this.DeleteProp('__New')
            proto := this.Prototype
            proto.BaseProp := false
            proto.Call := false
            proto.Exclude := ''
            proto.Get := true
            proto.Props := ''
            proto.Set := false
            proto.StopAt := ''
            proto.Value := true
            proto.List := [ 'Exclude', 'BaseProp', 'Call', 'Get', 'Props', 'Set', 'Value', 'StopAt' ]
            proto.__StopAtDefaultList := ',Object,Array,Buffer,Class,Map,Any,'
        }
        __New(Options?) {
            if IsSet(Options) {
                for prop in this.List {
                    if HasProp(Options, prop) {
                        this.%prop% := Options.%prop%
                    }
                }
            }
        }
    }

    /**
     * `PropsInfo.Proxy_Array` constructs a proxy that can be passed to an external function as an
     * iterable object. Use `PropsInfo.Proxy_Array` when an external function expects an iterable Array
     * object. Using a proxy is slightly more performant than calling `PropsInfo.Prototype.ToArray` in
     * cases where the object will only be iterated once.
     * The function should not try to set or change the items in the collection. If this is necessary,
     * use `PropsInfo.Prototype.ToArray`.
     * @classdesc
     */
    class Proxy_Array extends Array {
        static __New() {
            if this.Prototype.__Class == 'PropsInfo.Proxy_Array' {
                this.Prototype.DefineProp('__Class', { Value: 'Array' })
            }
        }
        __New(Client) {
            this.DefineProp('Client', { Value: Client })
        }
        Get(Index) => this.Client.Get(Index)
        Has(Index) => this.Client.__InfoItems.Has(Index)
        __Enum(VarCount) => this.Client.__Enum(VarCount)
        Capacity {
            Get => this.Client.__InfoItems.Capacity
            Set => this.Client.__InfoItems.Capacity := Value
        }
        Default {
            Get => this.Client.__InfoItems.Default
            Set => this.Client.__InfoItems.Default := Value
        }
        Length {
            Get => this.Client.__InfoItems.Length
            Set => this.Client.__InfoItems.Length := Value
        }
        __Item[Index] {
            Get => this.Client.__Item[Index]
            ; `PropsInfo` is not compatible with addint new items to the collection.
            ; Set => this.Client.__Item[Index] := Value
        }
        __Get(Name, Params) {
            if Params.Length {
                return this.Client.%Name%[Params*]
            } else {
                return this.Client.%Name%
            }
        }
        __Set(Name, Params, Value) {
            if Params.Length {
                return this.Client.%Name%[Params*] := Value
            } else {
                return this.Client.%Name% := Value
            }
        }
        __Call(Name, Params) {
            if Params.Length {
                return this.Client.%Name%(Params*)
            } else {
                return this.Client.%Name%()
            }
        }
    }

    /**
     * `PropsInfo.Proxy_Map` constructs a proxy that can be passed to an external function as an
     * iterable object. Use `PropsInfo.Proxy_Map` when an external function expects an iterable Map
     * object. Using a proxy is slightly more performant than calling `PropsInfo.Prototype.ToMap` in
     * cases where the object will only be iterated once.
     * The function should not try to set or change the items in the collection. If this is necessary,
     * use `PropsInfo.Prototype.ToMap`.
     * @classdesc
     */
    class Proxy_Map extends Map {
        static __New() {
            if this.Prototype.__Class == 'PropsInfo.Proxy_Map' {
                this.Prototype.DefineProp('__Class', { Value: 'Map' })
            }
        }
        __New(Client) {
            this.DefineProp('Client', { Value: Client })
        }
        Get(Key) => this.Client.Get(Key)
        Has(Key) => this.Client.__InfoIndex.Has(Key)
        __Enum(VarCount) => this.Client.__Enum(VarCount)
        Capacity {
            Get => this.Client.__InfoIndex.Capacity
            Set => this.Client.___InfoIndex.Capacity := Value
        }
        CaseSense => this.Client.__InfoIndex.CaseSense
        Count => this.Client.__InfoIndex.Count
        Default {
            Get => this.Client.__InfoIndex.Default
            Set => this.Client.__InfoIndex.Default := Value
        }
        __Item[Key] {
            Get => this.Client.__Item[Key]
            ; `PropsInfo` is not compatible with addint new items to the collection.
            ; Set => this.Client.__Item[Key] := Value
        }
        __Get(Name, Params) {
            if Params.Length {
                return this.Client.%Name%[Params*]
            } else {
                return this.Client.%Name%
            }
        }
        __Set(Name, Params, Value) {
            if Params.Length {
                return this.Client.%Name%[Params*] := Value
            } else {
                return this.Client.%Name% := Value
            }
        }
        __Call(Name, Params) {
            if Params.Length {
                return this.Client.%Name%(Params*)
            } else {
                return this.Client.%Name%()
            }
        }
    }
}

PropsInfo_SetConstants() {
    global ObjGetOwnPropDesc := Object.Prototype.GetOwnPropDesc
}

/**
 * @classdesc - For each base object in the input object's inheritance chain (up to the stopping
 * point), the base object's own properties are iterated, generating a `PropsInfoItem` object for
 * each property (unless the property is excluded).
 */
class PropsInfoItem {
    static __New() {
        if this.Prototype.__Class == 'PropsInfoItem' {
            this.Prototype.__KindNames := ['Call', 'Get', 'Get_Set', 'Set', 'Value']
        }
    }

    /**
     * @description - Each time `GetPropsInfo` is called, a new `PropsInfoItem` is created.
     * The `PropsInfoItem` object is used as the base object for all further `PropsInfoItem`
     * instances generated within that `GetPropsInfo` function call (and only that function call),
     * allowing properties to be defined once on the base and shared by the rest.
     * `PropsInfoItem.Prototype.__New` is not intended to be called directly.
     * @param {Object} Root - The object that was passed to `GetPropsInfo`.
     * @param {Integer}InheritanceDepth - The number of base objects traversed during the `GetPropsInfo`
     * call.
     * @returns {PropsInfoItem} - The `PropsInfoItem` instance.
     * @class
     */
    __New(Root, InheritanceDepth) {
        this.Root := Root
        this.InheritanceDepth := InheritanceDepth
    }

    /**
     * @description - Returns the function object, optionally binding an object to the hidden `this`
     * parameter. See {@link https://www.autohotkey.com/docs/v2/Objects.htm#Custom_Classes_method}
     * for information about the hidden `this`.
     * @param {VarRef} [OutSet] - A variable that will receive the `Set` function if this object
     * has both `Get` and `Set`. If this object only has a `Set` property, the `Set` function object
     * is returned as the return value and `OutSet` remains unset.
     * @param {Integer} Flag_Bind - One of the following values:
     * - 0: The function objects are returned as-is, with the hidden `this` parameter still exposed.
     * - 1: The object that was passed to `GetPropsInfo` is bound to the function object(s).
     * - 2: The owner of the property that produced this `PropsInfoItem` object is bound to the
     * function object(s).
     * @returns {Func|BoundFunc} - The function object.
     * @throws {ValueError} - If `Flag_Bind` is not 0, 1, or 2.
     */
    GetFunc(&OutSet?, Flag_Bind := 0) {
        switch Flag_Bind, 0 {
            case '0':
                switch this.KindIndex {
                    case 1: return this.Call
                    case 2: return this.Get
                    case 3:
                        OutSet := this.Set
                        return this.Get
                    case 4: return this.Set
                    case 5: return ''
                }
            case '1': return _Proc(this.Root)
            case '2': return _Proc(this.Owner)
            default: throw ValueError('Invalid value passed to the ``Flag_Bind`` parameter.', -1
            , IsObject(Flag_Bind) ? 'Type(Flag_Bind) == ' Type(Flag_Bind) : Flag_Bind)
        }

        _Proc(Obj) {
            switch this.KindIndex {
                case 1: return this.Call.Bind(Obj)
                case 2: return this.Get.Bind(Obj)
                case 3:
                    OutSet := this.Set.Bind(Obj)
                    return this.Get.Bind(Obj)
                case 4: return this.Set.Bind(Obj)
                case 5: return ''
            }
        }
    }

    /**
     * @description - `PropsInfoItem.Prototye.GetOwner` travels up the root object's inheritance chain
     * for `InfoItem.Index` objects, and if that object owns a property named `InfoItem.Name`, the
     * object is returned. If it does not own a property with that name,`PropsInfoItem.Prototype.GetOwner`
     * returns `0`.
     * The `InfoItem.Index` value represents the position in the inheritance chain of the object
     * that produced this `PropsInfoItem` object, beginning with the root object passed to
     * `GetPropsInfo`. Unless something has changed, the object at `InfoItem.Index` will be the
     * original owner of the property `InfoItem.Name`
     *
     * This example depicts a scenario in which the value returned by `PropsInfoItem.Prototype.GetOwner`
     * is not the original owner of the property that produced the `PropsInfoItem` object.
     * @example
     *  class a {
     *      __SomeProp := 0
     *      SomeProp => this.__SomeProp
     *  }
     *  class b extends a {
     *
     *  }
     *  class c {
     *      __SomeOtherProp := 1
     *      SomeProp => this.__SomeOtherProp
     *  }
     *  Obj := b()
     *  PropsInfoObj := GetPropsInfo(Obj)
     *  InfoItem := PropsInfoObj.Get('SomeProp')
     *  OriginalOwner := InfoItem.GetOwner()
     *  Obj.Base.Base := c.Prototype
     *  NewOwner := InfoItem.GetOwner()
     *  MsgBox(ObjPtr(OriginalOwner) == ObjPtr(NewOwner)) ; 0
     * @
     *
     * @returns {*} - If the object owns the property, the object. Else, returns 0.
     */
    GetOwner() {
        b := this.Root
        loop this.Index {
            b := b.Base
        }
        if this.Name = 'Base' || b.HasOwnProp(this.Name) {
            return b
        }
        return 0
    }

    /**
     * @description - If this is associated with a value property, provides the value that the property
     * had at the time this `PropsInfoItem` object was created. If this is associated with a dynamic
     * property with a `Get` accessor, attempts to access and provide the value.
     * @param {VarRef} OutValue - Because `GetValue` is expected to sometimes fail, the property's
     * value is set to the `OutValue` variable, and a status code is returned by the function.
     * @param {Boolean} [FromOwner=false] - When true, the object that produced this `PropsInfoItem`
     * object is passed as the first parameter to the `Get` accessor. When false, the root object
     * (the object passed to the `GetPropsInfo` call) is passed as the first parameter to the `Get`
     * accessor.
     * @returns {Integer} - One of these status codes:
     * - An empty string: The value was successfully accessed and `OutValue` is the value.
     * - 1: This `PropsInfoItem` object does not have a `Get` or `Value` property and the `OutValue`
     * variable remains unset.
     * - 2: An error occurred while calling the `Get` function, and `OutValue` is the error object.
     */
    GetValue(&OutValue?, FromOwner := false) {
        switch this.KindIndex {
            case 1, 4: return 1 ; Call, Set
            case 2, 3:
                try {
                    if FromOwner {
                        OutValue := this.Get.Call(this.Owner)
                    } else {
                        OutValue := this.Get.Call(this.Root)
                    }
                } catch Error as err {
                    OutValue := err
                    return 2
                }
            case 5:
                OutValue := this.Value
        }
    }

    /**
     * @description - Calls `PropsInfo.Prototype.GetOwner` to retrieve the owner of the property that
     * produced this `PropsInfoItem` object, then calls `Object.Prototype.GetOwnPropDesc` and updates
     * this `PropsInfoItem` object according to the return value, replacing or removing the existing
     * properties as needed.
     *
     * If the property is "Base", calls `this.DefineProp('Value', { Value: Owner })` and returns `5`.
     * @returns {Integer} - The kind index, which indicates the kind of property. They are:
     * - 1: Callable property
     * - 2: Dynamic property with only a getter
     * - 3: Dynamic property with both a getter and setter
     * - 4: Dynamic property with only a setter
     * - 5: Value property
     *
     * If the object returned by `PropsInfoItem.Prototype.GetOwner` no longer owns a property by
     * the name `InfoItem.Name`, then `PropsInfoItem.Prototype.Refresh` returns 0. You can call
     * `PropsInfo.Prototype.RefreshProp` to adjust the collection to reflect the objects' current
     * state.
     */
    Refresh() {
        if !(Owner := this.Owner) {
            return 0
        }
        if this.Name = 'Base' {
            this.DefineProp('Value', { Value: Owner })
            return 5
        }
        desc := Owner.GetOwnPropDesc(this.Name)
        n := 0
        KindIndex := this.KindIndex
        for Prop, Val in desc.OwnProps() {
            if this.HasOwnProp(Prop) {
                n++
            }
            this.DefineProp(Prop, { Value: Val })
        }
        switch KindIndex {
            case 1,2,4,5:
                ; The type of property changed
                if !n {
                    this.DeleteProp(this.Type)
                }
            case 3:
                ; One of the accessors no longer exists
                if n == 1 {
                    if desc.HasOwnProp('Get') {
                        this.DeleteProp('Set')
                    } else {
                        this.DeleteProp('Get')
                    }
                ; The type of property changed
                } else if !n {
                    this.DeleteProp('Get')
                    this.DeleteProp('Set')
                }
        }
        return this.__DefineKindIndex()
    }

    /**
     * Returns the owner of the property which produced this `PropsInfoItem` object.
     * @memberof PropsInfoItem
     * @instance
     */
    Owner => this.GetOwner()
    /**
     * A string representation of the kind of property which produced this `PropsInfoItem` object.
     * The possible values are:
     * - Call
     * - Get
     * - Get_Set
     * - Set
     * - Value
     * @memberof PropsInfoItem
     * @instance
     */
    Kind => this.__KindNames[this.KindIndex]
    /**
     * An integer that indicates the kind of property which produced this `PropsInfoItem` object.
     * The possible values are:
     * - 1: Callable property
     * - 2: Dynamic property with only a getter
     * - 3: Dynamic property with both a getter and setter
     * - 4: Dynamic property with only a setter
     * - 5: Value property
     * @memberof PropsInfoItem
     * @instance
     */
    KindIndex => this.__DefineKindIndex()

    /**
     * @description - The first time `KindIndex` is accessed, evaluates the object to determine
     * the property kind, then overrides `KindIndex`.
     */
    __DefineKindIndex() {
        ; Override with a value property so this is only processed once
        if this.HasOwnProp('Call') {
            this.DefineProp('KindIndex', { Value: 1 })
        } else if this.HasOwnProp('Get') {
            if this.HasOwnProp('Set') {
                this.DefineProp('KindIndex', { Value: 3 })
            } else {
                this.DefineProp('KindIndex', { Value: 2 })
            }
        } else if this.HasOwnProp('Set') {
            this.DefineProp('KindIndex', { Value: 4 })
        } else if this.HasOwnProp('Value') {
            this.DefineProp('KindIndex', { Value: 5 })
        } else {
            throw Error('Unable to process an unexpected value.')
        }
        return this.KindIndex
    }
    /**
     * @description - The first time `PropsInfoItem.Prototype.__SetAlt` is called, it sets the `Alt`
     * property with an array, then overrides `__SetAlt` to a function which just add items to the
     * array.
     */
    __SetAlt(Item) {
        /**
         * An array of `PropsInfoItem` objects, each sharing the same name. The property associated
         * with the `PropsInfoItem` object that has the `Alt` property is the property owned by
         * or inherited by the object passed to the `GetPropsInfo` function call. Exactly zero of
         * the `PropsInfoItem` objects contained within the `Alt` array will have an `Alt` property.
         * The below example illustrates this concept but expressed in code:
         * @example
         * Obj := [1, 2]
         * OutputDebug('`n' A_LineNumber ': ' Obj.Length) ; 2
         * ; Ordinarily when we access the `Length` property from an array
         * ; instance, the `Array.Prototype.Length.Get` function is called.
         * OutputDebug('`n' A_LineNumber ': ' Obj.Base.GetOwnPropDesc('Length').Get.Name) ; Array.Prototype.Length.Get
         * ; We override the property for some reason.
         * Obj.DefineProp('Length', { Value: 'Arbitrary' })
         * OutputDebug('`n' A_LineNumber ': ' Obj.Length) ; Arbitrary
         * ; GetPropsInfo
         * PropsInfoObj := GetPropsInfo(Obj)
         * ; Get the `PropsInfoItem` for "Length".
         * InfoItem_Length := PropsInfoObj.Get('Length')
         * if code := InfoItem_Length.GetValue(&Value) {
         *     throw Error('GetValue failed.', -1, 'Code: ' code)
         * } else {
         *     OutputDebug('`n' A_LineNumber ': ' Value) ; Arbitrary
         * }
         * ; Checking if the property was overridden (we already know
         * ; it was, but just for example)
         * OutputDebug('`n' A_LineNumber ': ' InfoItem_Length.Count) ; 2
         * OutputDebug('`n' A_LineNumber ': ' (InfoItem_Length.HasOwnProp('Alt'))) ; 1
         * InfoItem_Length_Alt := InfoItem_Length.Alt[1]
         * ; Calling `GetValue()` below returns the true length because
         * ; `Obj` is passed to `Array.Prototype.Length.Get`, producing
         * ; the same result as `Obj.Length` if we never overrode the
         * ; property.
         * if code := InfoItem_Length_Alt.GetValue(&Value) {
         *     throw Error('GetValue failed.', -1, 'Code: ' code)
         * } else {
         *     OutputDebug('`n' A_LineNumber ': ' Value) ; 2
         * }
         * ; The objects nested in the `Alt` array never have an `Alt`
         * ; property, but have the other properties.
         * OutputDebug('`n' A_LineNumber ': ' (InfoItem_Length_Alt.HasOwnProp('Alt'))) ; 0
         * OutputDebug('`n' A_LineNumber ': ' InfoItem_Length_Alt.Count) ; 2
         * OutputDebug('`n' A_LineNumber ': ' InfoItem_Length_Alt.Name) ; Length
         * @instance
         */
        if this.HasOwnProp('Alt') {
            this.Alt.Push(Item)
        } else {
            this.Alt := [ Item ]
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/TreeViewEnumDescendents.ahk
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * @description - Recursively enumerates TreeView nodes. This can be called in 1-param or
 * 2-param mode. In 1-param mode, the variable receives the node id. In 2-param mode, the
 * first variable receives the node id and the second variable receives the parent node id.
 *
 * @example
 *  ; Assume an object MyTreeView already was defined
 *  for id, parent in TreeViewEnumDescendents(MyTreeView, MyTreeView.GetSelection(), 1, 0) {
 *      if InStr(MyTreeView.GetText(id), 'Some phrase') {
 *          MsgBox('Found the phrase.')
 *      }
 *  }
 * @
 *
 * @param {Gui.TreeView} TreeViewObj - The TreeView object.
 * @param {Integer} [ItemId = 0] - The node to start enumerating from. Neither this node nor its
 * siblings are included in the enumeration; only descendents.
 * @param {Boolean} [ExpandedOnly = false] - When true, only nodes that are expanded have their
 * children enumerated. When false, a node's expanded state has no effect on the enumeration.
 * @param {Boolean} [NonParentsOnly = false] - When true, parents are skipped. Their children are
 * still enumerated, but the caller never receives the parent. When false, parent nodes are included.
 */
TreeViewEnumDescendents(TreeViewObj, ItemId := 0, ExpandedOnly := false, NonParentsOnly := false, *) {
    Stack := [ItemId]
    flag_first := true
    if ExpandedOnly {
        if NonParentsOnly {
            Enum := _EnumExpandedAndNonParentsOnly
        } else {
            Enum := _EnumExpandedOnly
        }
    } else if NonParentsOnly {
        Enum := _EnumNonParentsOnly
    } else {
        Enum := _Enum
    }
    ObjSetBase(Enum, Enumerator.Prototype)
    Enum.Stack := Stack
    return Enum

    _Enum(&Id, &parent?) {
        if Id := TreeViewObj.GetChild(stack[-1]) {
            parent := stack[-1]
            stack.Push(Id)
            return 1
        } else if stack.Length > 1 {
            loop {
                if Id := TreeViewObj.GetNext(stack[-1]) {
                    stack[-1] := Id
                    parent := stack[-2]
                    return 1
                } else {
                    stack.Pop()
                    if stack.Length <= 1 {
                        return 0
                    }
                }
            }
        } else {
            return 0
        }
    }
    _EnumExpandedOnly(&Id, &parent?) {
        if flag_first {
            if Id := TreeViewObj.GetChild(stack[-1]) {
                parent := 0
                stack.Push(Id)
                flag_first := false
                return 1
            } else {
                return 0
            }
        }
        if TreeViewObj.Get(stack[-1], 'E') {
            Id := TreeViewObj.GetChild(stack[-1])
            parent := stack[-1]
            stack.Push(Id)
            return 1
        } else if stack.Length > 1 {
            loop {
                if Id := TreeViewObj.GetNext(stack[-1]) {
                    stack[-1] := Id
                    parent := stack[-2]
                    return 1
                } else {
                    stack.Pop()
                    if stack.Length <= 1 {
                        return 0
                    }
                }
            }
        } else {
            return 0
        }
    }
    _EnumNonParentsOnly(&Id, &parent?) {
        if flag_first {
            while child := TreeViewObj.GetChild(stack[-1]) {
                stack.Push(child)
            }
            if stack.Length > 1 {
                flag_first := false
                Id := stack[-1]
                Parent := stack[-2]
                return 1
            } else {
                return 0
            }
        }
        if Id := TreeViewObj.GetNext(stack[-1]) {
            stack[-1] := Id
            while child := TreeViewObj.GetChild(stack[-1]) {
                stack.Push(child)
            }
            parent := stack[-2]
            Id := stack[-1]
            return 1
        } else if stack.Length > 1 {
            stack.Pop()
            loop {
                if Id := TreeViewObj.GetNext(stack[-1]) {
                    stack[-1] := Id
                    while child := TreeViewObj.GetChild(stack[-1]) {
                        stack.Push(child)
                    }
                    parent := stack[-2]
                    Id := stack[-1]
                    return 1
                } else {
                    stack.Pop()
                    if stack.Length <= 1 {
                        return 0
                    }
                }
            }
        } else {
            return 0
        }
    }
    _EnumExpandedAndNonParentsOnly(&Id, &parent?) {
        if flag_first {
            if child := TreeViewObj.GetChild(stack[-1]) {
                stack.Push(child)
                flag_first := false
            } else {
                return 0
            }
            if _Skip() {
                return 0
            }
            Id := stack[-1]
            Parent := stack[-2]
            return 1
        }
        if Id := TreeViewObj.GetNext(stack[-1]) {
            stack[-1] := Id
            if _Skip() {
                return 0
            }
            parent := stack[-2]
            Id := stack[-1]
            return 1
        } else if stack.Length > 1 {
            stack.Pop()
            loop {
                if Id := TreeViewObj.GetNext(stack[-1]) {
                    stack[-1] := Id
                    if _Skip() {
                        return 0
                    }
                    parent := stack[-2]
                    Id := stack[-1]
                    return 1
                } else {
                    stack.Pop()
                    if stack.Length <= 1 {
                        return 0
                    }
                }
            }
        } else {
            return 0
        }

        _Skip() {
            loop {
                while TreeViewObj.Get(stack[-1], 'E') {
                    stack.Push(TreeViewObj.GetChild(stack[-1]))
                }
                if Id := TreeViewObj.GetChild(stack[-1]) {
                    if Id := TreeViewObj.GetNext(stack[-1]) {
                        stack[-1] := Id
                    } else if stack.Length > 1 {
                        loop {
                            stack.Pop()
                            if Id := TreeViewObj.GetNext(stack[-1]) {
                                stack[-1] := Id
                                break
                            }
                            if stack.Length <= 1 {
                                return 1
                            }
                        }
                    } else {
                        return 1
                    }
                } else {
                    return
                }
            }
        }
    }
}

TreeViewEnumAll(TreeViewObj, ItemId := 0, *) {
    _id := TreeViewObj.GetNext(ItemId, 'F')
    return Enum

    Enum(&Id) {
        if _id {
            Id := _id
            _id := TreeViewObj.GetNext(Id, 'F')
            return 1
        } else {
            return 0
        }
    }
}

TreeViewEnumChecked(TreeViewObj, ItemId := 0, *) {
    _id := TreeViewObj.Get(ItemId, 'C')
    if !_id {
        _id := TreeViewObj.GetNext(ItemId, 'C')
    }
    return Enum

    Enum(&Id) {
        if _id {
            Id := _id
            _id := TreeViewObj.GetNext(Id, 'C')
            return 1
        } else {
            return 0
        }
    }
}

TreeViewEnumChildren(TreeViewObj, ItemId := 0, *) {
    child := TreeViewObj.GetChild(ItemId)
    return Enum

    Enum(&Id) {
        if child {
            Id := child
            child := TreeViewObj.GetNext(Id)
            return 1
        } else {
            return 0
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/PathObj.ahk
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * @classdesc - This is a solution for tracking object paths using strings.
 * @example
 *  ; Say we are processing this object and need to keep track of the object path somehow.
 *  Obj := {
 *      Prop1: {
 *          NestedProp1: {
 *              NestedMap: Map(
 *                  'Key1 `r`n"`t``', Map(
 *                      'Key2', 'Val1'
 *                  )
 *              )
 *          }
 *        , NestedProp2: [ 1, 2, { Prop: 'Val' }, 4 ]
 *      }
 *  }
 *  ; Get an instance of `PathObj`
 *  Root := PathObj('Obj')
 *  ; Process the properties / items
 *  O1 := Root.MakeProp('Prop1')
 *  O2 := O1.MakeProp('NestedProp1')
 *  O3 := O2.MakeProp('NestedMap')
 *  O4 := O3.MakeItem('Key1 `r`n"`t``')
 *  O5 := O4.MakeItem('Key2')
 *
 *  ; Calling the object produces a path that will apply AHK escape sequences using the backtick as needed.
 *  OutputDebug(O5() '`n') ; Obj.Prop1.NestedProp1.NestedMap["Key1 `r`n`"`t``"]["Key2"]
 *
 *  ; You can start another branch
 *  B1 := O1.MakeProp('NestedProp2')
 *  B2 := B1.MakeItem(3)
 *  B3 := B2.MakeProp('Prop')
 *  OutputDebug(B3() '`n') ; Obj.Prop1.NestedProp2[3].Prop
 *
 *  ; Some operations don't benefit from having the keys escaped. Save processing time by calling
 *  ; the "Unescaped" method.
 *  OutputDebug(O5.Unescaped() '`n')
 *  ; Obj.Prop1.NestedProp1.NestedMap["Key1
 *  ; "	   `"]["Key2"]
 *
 *  ; Normally you would use `PathObj` in some type of recursive loop.
 *  Recurse(obj, PathObj('obj'))
 *  Recurse(obj, path) {
 *      OutputDebug(path() '`n')
 *      for p, v in obj.OwnProps() {
 *          if IsObject(v) {
 *              Recurse(v, path.MakeProp(p))
 *          }
 *      }
 *      if HasMethod(obj, '__Enum') {
 *          for k, v in obj {
 *              if IsObject(v) {
 *                  Recurse(v, path.MakeItem(k))
 *              }
 *          }
 *      }
 *  }
 * @
 */
class PathObj {
    static __New() {
        this.DeleteProp('__New')
        PathObj_SetConstants()
        proto := this.Prototype
        proto.propdesc := this.Prototype.GetOwnPropDesc('__GetPathSegmentProp_U')
        proto.Type := PATHOBJ_TYPE_ROOT
    }
    /**
     * An instance of `PathObj` should be used as the root object of the path is being constructed.
     * All child segments should be created by calling `PathObj.Prototype.MakeProp` or
     * `PathObj.Prototype.MakeItem`.
     *
     * @param {String} [Name = "$"] - The name to assign the object.
     * @param {Boolean} [EscapePropNames = false] - If true, calling `PathObj.Prototype.Call` will
     * apply AHK escape sequences to property names using the backtick where appropriate. In AHK
     * syntax, there are no characters which have AHK escape sequences that can be used within a
     * property name, and so this should generally be left `false` to save processing time.
     * `PathObj.Prototype.Unescaped` is unaffected by this option.
     * @param {String} [QuoteChar = "`""] - The quote character to use for item keys.
     */
    __New(Name := '$', EscapePropNames := false, QuoteChar := '"') {
        this.Name := Name
        this.QuoteChar := QuoteChar
        this.DefineProp('GetPathSegment', PathObj_GetPathSegmentRoot1)
        this.DefineProp('GetPathSegment_U', PathObj_GetPathSegmentRoot_U)
        if EscapePropNames {
            this.DefineProp('propdesc', { Value: PathObj_GetPathSegmentProp1 })
        }
        this.Index := 1
    }
    Call(*) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        if !this.HasOwnProp('__Path') {
            o := this
            buf := Buffer(PATHOBJ_INITIAL_BUFFER_SIZE)
            offset := PATHOBJ_INITIAL_BUFFER_SIZE - 2
            NumPut('ushort', 0, buf, offset) ; null terminator
            loop {
                if o.GetPathSegment(buf, &offset) {
                    break
                }
                o := o.Base
            }
            this.DefineProp('__Path', { Value: StrGet(buf.Ptr + offset) })
        }
        return this.__Path
    }
    MakeProp(Name) {
        ObjSetBase(Segment := { Name: Name, Index: this.Index + 1, Type: PATHOBJ_TYPE_PROP }, this)
        Segment.DefineProp('GetPathSegment', this.propdesc)
        Segment.DefineProp('GetPathSegment_U', PathObj_GetPathSegmentProp_U)
        return Segment
    }
    MakeItem(Name) {
        ObjSetBase(Segment := { Name: Name, Index: this.Index + 1, Type: PATHOBJ_TYPE_ITEM }, this)
        if IsNumber(Name) {
            Segment.DefineProp('GetPathSegment', PathObj_GetPathSegmentItem_Number)
            Segment.DefineProp('GetPathSegment_U', PathObj_GetPathSegmentItem_Number)
        } else {
            Segment.DefineProp('GetPathSegment', PathObj_GetPathSegmentItem_String1)
            Segment.DefineProp('GetPathSegment_U', PathObj_GetPathSegmentItem_String_U1)
        }
        return Segment
    }
    /**
     * Creates a {@link PathObj} with type PATHOBJ_TYPE_ROOT from the current object. The name
     * of the new object will be the same as the return value from {@link PathObj.Prototype.Call},
     * i.e. the path string. But, as a root object, its type will be PATHOBJ_TYPE_ROOT and its
     * base will be PathObj.Prototype. Use this if you need a PATHOBJ_TYPE_ROOT object and want
     * to retain the current path string as the name.
     */
    ToRoot(EscapePropNames := false) {
        return PathObj(this(), EscapePropNames, this.QuoteChar)
    }
    Unescaped(*) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        if !this.HasOwnProp('__Path_U') {
            o := this
            buf := Buffer(PATHOBJ_INITIAL_BUFFER_SIZE)
            offset := PATHOBJ_INITIAL_BUFFER_SIZE - 2
            NumPut('ushort', 0, buf, offset) ; null terminator
            loop {
                if o.GetPathSegment_U(buf, &offset) {
                    break
                }
                o := o.Base
            }
            this.DefineProp('__Path_U', { Value: StrGet(buf.Ptr + offset) })
        }
        return this.__Path_U
    }
    __GetPathSegmentItem_Number(buf, &offset) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        bytes := StrPut(this.Name) + 2 ; -2 for null terminator, then +4 for the brackets
        if bytes > offset {
            count := buf.Size - offset
            while bytes > offset {
                PATHOBJ_INITIAL_BUFFER_SIZE *= 2
                buf.Size *= 2
                DllCall(
                    g_msvcrt_memmove
                  , 'ptr', buf.Ptr + buf.Size - count
                  , 'ptr', buf.Ptr + offset
                  , 'int', count
                  , 'ptr'
                )
                offset := buf.Size - count
            }
        }
        offset -= bytes
        StrPut('[' this.Name ']', buf.Ptr + offset, bytes / 2)
    }

    ;@region Escaped
    __GetPathSegmentItem_String1(buf, &offset) {
        this.DefineProp('NameEscaped', { Value: StrReplace(StrReplace(StrReplace(StrReplace(StrReplace(this.Name, '``', '````'), '`n', '``n'), '`r', '``r'), this.QuoteChar, '``' this.QuoteChar), '`t', '``t') })
        this.DefineProp('GetPathSegment', PathObj_GetPathSegmentItem_String2)
        this.GetPathSegment(buf, &offset)
    }
    __GetPathSegmentItem_String2(buf, &offset) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        bytes := StrPut(this.NameEscaped) + 6 ; -2 for null terminator, then +4 for the brackets and +4 for the quotes
        if bytes > offset {
            count := buf.Size - offset
            while bytes > offset {
                PATHOBJ_INITIAL_BUFFER_SIZE *= 2
                buf.Size *= 2
                DllCall(
                    g_msvcrt_memmove
                  , 'ptr', buf.Ptr + buf.Size - count
                  , 'ptr', buf.Ptr + offset
                  , 'int', count
                  , 'ptr'
                )
                offset := buf.Size - count
            }
        }
        offset -= bytes
        StrPut('[' this.QuoteChar this.NameEscaped this.QuoteChar ']', buf.Ptr + offset, bytes / 2)
    }
    __GetPathSegmentProp1(buf, &offset) {
        this.DefineProp('NameEscaped', { Value: StrReplace(StrReplace(StrReplace(StrReplace(StrReplace(this.Name, '``', '````'), '`n', '``n'), '`r', '``r'), this.QuoteChar, '``' this.QuoteChar), '`t', '``t') })
        this.DefineProp('GetPathSegment', PathObj_GetPathSegmentProp2)
        this.GetPathSegment(buf, &offset)
    }
    __GetPathSegmentProp2(buf, &offset) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        bytes := StrPut(this.NameEscaped) ; -2 for null terminator, then +2 for the period
        if bytes > offset {
            count := buf.Size - offset
            while bytes > offset {
                PATHOBJ_INITIAL_BUFFER_SIZE *= 2
                buf.Size *= 2
                DllCall(
                    g_msvcrt_memmove
                  , 'ptr', buf.Ptr + buf.Size - count
                  , 'ptr', buf.Ptr + offset
                  , 'int', count
                  , 'ptr'
                )
                offset := buf.Size - count
            }
        }
        offset -= bytes
        StrPut('.' this.NameEscaped, buf.Ptr + offset, bytes / 2)
    }
    __GetPathSegmentRoot1(buf, &offset) {
        this.DefineProp('NameEscaped', { Value: StrReplace(StrReplace(StrReplace(StrReplace(StrReplace(this.Name, '``', '````'), '`n', '``n'), '`r', '``r'), this.QuoteChar, '``' this.QuoteChar), '`t', '``t') })
        this.DefineProp('GetPathSegment', PathObj_GetPathSegmentRoot2)
        return this.GetPathSegment(buf, &offset)
    }
    __GetPathSegmentRoot2(buf, &offset) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        bytes := StrPut(this.NameEscaped) - 2 ; -2 for null terminator
        if bytes > offset {
            count := buf.Size - offset
            while bytes > offset {
                PATHOBJ_INITIAL_BUFFER_SIZE *= 2
                buf.Size *= 2
                DllCall(
                    g_msvcrt_memmove
                  , 'ptr', buf.Ptr + buf.Size - count
                  , 'ptr', buf.Ptr + offset
                  , 'int', count
                  , 'ptr'
                )
                offset := buf.Size - count
            }
        }
        offset -= bytes
        StrPut(this.NameEscaped, buf.Ptr + offset, bytes / 2)
        return 1
    }
    ;@endregion

    ;@region Unescaped
    __GetPathSegmentItem_String_U1(buf, &offset) {
        this.DefineProp('__NamePartialEscaped', { Value: StrReplace(this.Name, this.QuoteChar, '``' this.QuoteChar) })
        this.DefineProp('GetPathSegment', PathObj_GetPathSegmentItem_String_U2)
        this.GetPathSegment(buf, &offset)
    }
    __GetPathSegmentItem_String_U2(buf, &offset) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        bytes := StrPut(this.__NamePartialEscaped) + 6 ; -2 for null terminator, then +4 for the brackets and +4 for the quotes
        if bytes > offset {
            count := buf.Size - offset
            while bytes > offset {
                PATHOBJ_INITIAL_BUFFER_SIZE *= 2
                buf.Size *= 2
                DllCall(
                    g_msvcrt_memmove
                  , 'ptr', buf.Ptr + buf.Size - count
                  , 'ptr', buf.Ptr + offset
                  , 'int', count
                  , 'ptr'
                )
                offset := buf.Size - count
            }
        }
        offset -= bytes
        StrPut('[' this.QuoteChar this.__NamePartialEscaped this.QuoteChar ']', buf.Ptr + offset, bytes / 2)
    }
    __GetPathSegmentProp_U(buf, &offset) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        bytes := StrPut(this.Name) ; -2 for null terminator, then +2 for the period
        if bytes > offset {
            count := buf.Size - offset
            while bytes > offset {
                PATHOBJ_INITIAL_BUFFER_SIZE *= 2
                buf.Size *= 2
                DllCall(
                    g_msvcrt_memmove
                  , 'ptr', buf.Ptr + buf.Size - count
                  , 'ptr', buf.Ptr + offset
                  , 'int', count
                  , 'ptr'
                )
                offset := buf.Size - count
            }
        }
        offset -= bytes
        StrPut('.' this.Name, buf.Ptr + offset, bytes / 2)
    }
    __GetPathSegmentRoot_U(buf, &offset) {
        global PATHOBJ_INITIAL_BUFFER_SIZE
        bytes := StrPut(this.Name) - 2 ; -2 for null terminator
        if bytes > offset {
            count := buf.Size - offset
            while bytes > offset {
                PATHOBJ_INITIAL_BUFFER_SIZE *= 2
                buf.Size *= 2
                DllCall(
                    g_msvcrt_memmove
                  , 'ptr', buf.Ptr + buf.Size - count
                  , 'ptr', buf.Ptr + offset
                  , 'int', count
                  , 'ptr'
                )
                offset := buf.Size - count
            }
        }
        offset -= bytes
        StrPut(this.Name, buf.Ptr + offset, bytes / 2)
        return 1
    }
    ;@endregion

    Path => this()
    PathUnescaped => this.Unescaped()
}

PathObj_SetConstants(force := false) {
    global
    if !force && IsSet(g_PathObj_constants_set) {
        return
    }
    local hModule := DllCall('LoadLibrary', 'Str', 'msvcrt.dll', 'Ptr')
    g_msvcrt_memmove := DllCall('GetProcAddress', 'Ptr', hModule, 'AStr', 'memmove', 'Ptr')

    local i := 0
    PATHOBJ_TYPE_ITEM := ++i
    PATHOBJ_TYPE_PROP := ++i
    PATHOBJ_TYPE_ROOT := ++i
    PATHOBJ_TYPE_END := i

    PATHOBJ_INITIAL_BUFFER_SIZE := 256

    local proto := PathObj.Prototype
    PathObj_GetPathSegmentRoot1 := proto.GetOwnPropDesc('__GetPathSegmentRoot1')
    PathObj_GetPathSegmentRoot_U := proto.GetOwnPropDesc('__GetPathSegmentRoot_U')
    PathObj_GetPathSegmentProp1 := proto.GetOwnPropDesc('__GetPathSegmentProp1')
    PathObj_GetPathSegmentProp_U := proto.GetOwnPropDesc('__GetPathSegmentProp_U')
    PathObj_GetPathSegmentItem_Number := proto.GetOwnPropDesc('__GetPathSegmentItem_Number')
    PathObj_GetPathSegmentItem_String1 := proto.GetOwnPropDesc('__GetPathSegmentItem_String1')
    PathObj_GetPathSegmentItem_String_U1 := proto.GetOwnPropDesc('__GetPathSegmentItem_String_U1')
    PathObj_GetPathSegmentItem_String2 := proto.GetOwnPropDesc('__GetPathSegmentItem_String2')
    PathObj_GetPathSegmentProp2 := proto.GetOwnPropDesc('__GetPathSegmentProp2')
    PathObj_GetPathSegmentRoot2 := proto.GetOwnPropDesc('__GetPathSegmentRoot2')
    PathObj_GetPathSegmentItem_String_U2 := proto.GetOwnPropDesc('__GetPathSegmentItem_String_U2')

    g_PathObj_constants_set := 1
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-GetObjectFromString
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * @description - Parses a string object path and returns the value.
 * @param {String} Str - The object path.
 * @param {*} [InitialObj] - If set, the object path will be parsed as a property / item of
 * this object.
 * @returns {*} - The value.
 *
 * @example
 * class test {
 *     static obj := {
 *         prop: Map(
 *             'arr', [ { prop: [ 10, Map('key', { ðŸ˜Š: 'emoji' }) ] } ]
 *         )
 *     }
 * }
 * obj := GetObjectFromString("test.obj.prop[`"arr`"][1].prop[2][`"key`"]")
 * OutputDebug(obj.ðŸ˜Š) ; emoji
 * @
 *
 * Using an initial object.
 * @example
 * Obj := {
 *     Prop1: [1, 2, Map(
 *             'key1', 'value1',
 *             'key2', {prop2: 2, prop3: [3, 4]}
 *         )
 *     ]
 * }
 * Path := '[3]["key2"].prop3'
 * Arr := Obj.Prop1
 * InnerArr := GetObjectFromString(Path, Arr)
 * OutputDebug(InnerArr[2]) ; 4
 * @
 *
 */
GetObjectFromString(Str, InitialObj?) {
    if IsSet(InitialObj) {
        NewObj := InitialObj
        Pos := 1
    } else {
        RegExMatch(Str, '^(?:[\p{L}_0-9]|[^\x00-\x7F\x80-\x9F])+', &InitialSegment)
        Pos := InitialSegment.Pos + InitialSegment.Len
        NewObj := %InitialSegment[0]%
    }
    RegExMatch(
        Str
      , '(?:'
            '(?:\.|^)'
            '\K'
            '(?:'
                '[\p{L}_0-9]'
            '|'
                '[^\x00-\x7F\x80-\x9F]'
            ')+'
            '(?COnProp)'
        '|'
            '\[[ \t]*'
            '(?<quote>[`'"])'
            '(?<quoted>.*?)'
            '(?<!``)'
            '(?:````)*'
            '\g{quote}'
            '(?COnQuoted)'
            '\]'
        '|'
            '\[[ \t]*'
            '(?<key>.+?)'
            '[ \t]*\]'
            '(?COnKey)'
        ')+'
      ,
      , Pos
    )

    return NewObj

    OnProp(Match, *) {
        NewObj := NewObj.%Match[0]%
    }
    OnKey(Match, *) {
        NewObj := NewObj[Match['key']]
    }
    OnQuoted(Match, *) {
        NewObj := NewObj[Match['quoted']]
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/GuiResizer.ahk
    Author: Nich-Cebolla
    Version: 2.0.0
    License: MIT
*/

class GuiResizer {
    static __New() {
        this.DeleteProp('__New')
        hMod := DllCall('GetModuleHandleW', 'wstr', 'user32', 'ptr')
        global g_user32_BeginDeferWindowPos := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'BeginDeferWindowPos', 'ptr')
        , g_user32_ClientToScreen := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'ClientToScreen', 'ptr')
        , g_user32_DeferWindowPos := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'DeferWindowPos', 'ptr')
        , g_user32_EndDeferWindowPos := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'EndDeferWindowPos', 'ptr')
        , g_user32_GetClientRect := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'GetClientRect', 'ptr')
        , g_user32_GetDpiForWindow := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'GetDpiForWindow', 'ptr')
        , g_user32_GetWindowRect := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'GetWindowRect', 'ptr')
        , g_user32_PeekMessageW := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'PeekMessageW', 'ptr')
        , g_user32_RedrawWindow := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'RedrawWindow', 'ptr')
        , g_user32_ScreenToClient := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'ScreenToClient', 'ptr')
        , g_user32_SetWindowPos := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'SetWindowPos', 'ptr')
        , g_user32_SetThreadDpiAwarenessContext := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'SetThreadDpiAwarenessContext', 'ptr')
        , GuiResizer_Swp_Move := 0x0001 | 0x0010 | 0x0200 | 0x0004 ; SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER
        , GuiResizer_Swp_MoveAndSize := 0x0010 | 0x0200 | 0x0004 ; SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER
        , GuiResizer_Swp_Size := 0x0002 | 0x0010 | 0x0200 | 0x0004 ; SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER

        proto := this.Prototype
        proto.flag_noDefer := proto.flag_defer := false
    }

    /**
     * @description
     * Creates an object that acts as a callback function for the Size event. See
     * test\demo-GuiResizer.ahk for a descriptive demo. See test\test-GuiResizer.ahk to test
     * specific setups.
     *
     * In this documentation, "delta" means the change of position or change in size.
     *
     * All references to the parent window's width or height are referring to the **parent window's
     * client area**.
     *
     * # CtrlObj.Resizer
     *
     * To specify how a control should be modified when the parent window's dimensions change, create
     * a property "Resizer" on the Gui.Control object. The property should be an object with one or
     * more of the following properties:
     *
     * @param {Boolean} [CtrlObj.Resizer.Scale = false] - If set to true, and if the W and/or H
     * properties are set, when the width/height of the gui window changes, the respective width/height
     * of the control is changed according to the scale, not the direct value. For example:
     * - My gui window has a client area of 500w x 500h
     * - I set `CtrlObj.Resizer.Scale =: true`
     * - I set `CtrlObj.Resizer.H := 1`
     * - The current height of `CtrlObj` is 100
     *
     * If the height of the window's client area changes to 550, then the height of `CtrlObj` changes
     * to 110. This is because the gui's height delta is 50, which represents a 10% increase.
     * `100 + 100 * 0.1 = 110`.
     *
     * The scale is also multiplied by the respective W / H value. Using the same example scenario,
     * if I instead set `CtrlObj.Resizer.H := 2`, then the height of `CtrlObj` would change to 120.
     * If I set `CtrlObj.Resizer.H := 0.5`, then the height of `CtrlObj` would change to 105.
     *
     * If `CtrlObj.Resizer.Scale = false`, when the width/height of the gui window changes, the
     * respective width/height of the control is changed by the quotient of the value of the
     * respective W/H property and the gui window's width/height delta. Using a similar example scenario:
     * - My gui window has a client area of 500w x 500h
     * - I set `CtrlObj.Resizer.Scale =: false`
     * - I set `CtrlObj.Resizer.H := 1`
     * - The current height of `CtrlObj` is 100
     *
     * If the height of the window's client area changes to 550, then the height of `CtrlObj` changes
     * to 150. This is because the gui's height delta is 50, and 50 * 1 = 50, and 100 + 50 = 150.
     *
     * The delta is multiplied by the respective W / H value. Using the same example scenario,
     * if I instead set `CtrlObj.Resizer.H := 2`, then the height of `CtrlObj` would change to 200.
     * If I set `CtrlObj.Resizer.H := 0.5`, then the height of `CtrlObj` would change to 125.
     *
     * @property {Number} [CtrlObj.Resizer.X] - If set, the control's position along the horizontal axis
     * will be changed when the gui's width changes. The control's position delta is the quotient
     * of the gui's width delta * this value. For example, if the X value is 0.5 and the gui's width
     * changes by +5, then the control is moved 3 pixels to the right.
     *
     * @property {Number} [CtrlObj.Resizer.MaxX] - If set, the control's position along the horizontal axis
     * will not be permitted to exceed this value.
     *
     * @property {Number} [CtrlObj.Resizer.MinX] - If set, the control's position along the horizontal axis
     * will not be permitted to drop below this value.
     *
     * @property {Number} [CtrlObj.Resizer.W] - If set, the control's width will be changed when the
     * gui's width changes. The control's width delta is the quotient of the gui's width delta * this
     * value. For example, if the W value is 1 and the gui's width changes by +5, then the control's
     * width increases by 5 pixels on the right side.
     *
     * @property {Number} [CtrlObj.Resizer.MaxW] - If set, the control's width will not be permitted to
     * exceed this value.
     *
     * @property {Number} [CtrlObj.Resizer.MinW] - If set, the control's width will not be permitted to
     * drop below this value.
     *
     * @property {Number} [CtrlObj.Resizer.Y] - If set, the control's position along the vertical axis
     * will be changed when the gui's height changes. The control's position delta is the quotient
     * of the gui's height delta * this value. For example, if the Y value is 0.3 and the gui's height
     * changes by +10, then the control is moved 3 pixels down.
     *
     * @property {Number} [CtrlObj.Resizer.MaxY] - If set, the control's position along the vertical axis
     * will not be permitted to exceed this value.
     *
     * @property {Number} [CtrlObj.Resizer.MinY] - If set, the control's position along the vertical axis
     * will not be permitted to drop below this value.
     *
     * @property {Number} [CtrlObj.Resizer.H] - If set, the control's height will be changed when the
     * gui's height changes. The control's height delta is the quotient of the gui's height delta * this
     * value. For example, if the H value is 1 and the gui's height changes by +5, then the control's
     * height increases by 5 pixels on bottom.
     *
     * @property {Number} [CtrlObj.Resizer.MaxH] - If set, the control's height will not be permitted to
     * exceed this value.
     *
     * @property {Number} [CtrlObj.Resizer.MinH] - If set, the control's height will not be permitted to
     * drop below this value.
     *
     * @property {Integer} [CtrlObj.Resizer.Flags] - If set, the value to pass to the uFlags parameter
     * of {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-deferwindowpos DeferWindowPos}
     * for that control. If unset, the relevant default is used ({@link GuiResizer_Swp_Move},
     * {@link GuiResizer_Swp_Size}, or {@link GuiResizer_Swp_MoveAndSize}).
     *
     * @property {Boolean} [CtrlObj.Resizer.NoDefer] - If set and if nonzero, the control is resized
     * using {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowpos SetWindowPos}
     * instead of {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-deferwindowpos DeferWindowPos}.
     *
     *
     *
     * @param {Gui} GuiObj - The Gui object.
     *
     * @param {Gui.Control[]} [Controls] - If `Controls` is set, it is an array of `Gui.Control`
     * objects with property "Resizer" with the resize options for that control. See the description
     * above {@link GuiResizer.Prototype.__New} for more information. If `DeferActivation` is true,
     * `Controls` is ignored.
     *
     * @param {Boolean} [DeferActivation = false] - If true, {@link GuiResizer.Prototype.Activate}
     * is not called; your code must call it. If true, `Controls` is ignored. If false,
     * {@link GuiResizer.Prototype.Activate} is called, passing `Controls` as an argument if
     * `Controls` is set.
     *
     * @param {Boolean} [ControlsOnly = false] - If true, the gui object's internal collection is
     * not iterated and only the objects in `Controls` are used. if false, the gui object's internal
     * collection is iterated and the objects with a "Resizer" property are processed in addition
     * to the objects in `Controls`.
     *
     * If `Controls` is unset, `ControlsOnly` is ignored.
     *
     *
     *
     * @param {Object} [Options] - An object with options as property : value pairs.
     *
     * @param {Integer} [Options.AddRemove = 1] - The value to pass to the `AddRemove` parameter
     * of {@link https://www.autohotkey.com/docs/v2/lib/GuiOnEvent.htm Gui.Prototype.OnEvent} when
     * setting the Size event handler.
     *
     * @param {*} [Options.CallbackOnEnd] - A `Func` or callable object that is called when the resize
     * loop ends.
     *
     * Parameters:
     * 1. The {@link GuiResizer} object
     *
     * The return value is ignored.
     *
     * @param {*} [Options.CallbackOnStart] - A `Func` or callable object that is called when the resize
     * loop is about to begin.
     *
     * Parameters:
     * 1. The {@link GuiResizer} object
     *
     * The return value is ignored.
     *
     * @param {Integer} [Options.DpiAwarenessContext] - If set, this must be a valid dpi awareness
     * context. Immediately before each resize cycle, SetThreadDpiAwarenessContext is called with
     * this value. If unset, SetThreadDpiAwarenessContext is not called.
     *
     * @param {Number} [Options.MaxH] - If a number, directs the resize function to stop adjusting
     * the controls' height and vertical position when the gui's client area has exceeded this height.
     *
     * @param {Number} [Options.MaxW] - If a number, directs the resize function to stop adjusting
     * the controls' width and horizontal position when the gui's client area has exceeded this width.
     *
     * @param {Number} [Options.MinH] - If a number, directs the resize function to stop adjusting
     * the controls' height and vertical position when the gui's client area has dropped below this
     * height.
     *
     * @param {Number} [Options.MinW] - If a number, directs the resize function to stop adjusting
     * the controls' width and horizontal position when the gui's client area has dropped below this
     * width.
     *
     * @param {Boolean} [Options.NoDeferAll = false] - If true, all controls are considered to have
     * the `CtrlObj.Resizer.NoDefer` flag set, which directs {@link GuiResizer.Prototype.Resize} to
     * resize / reposition the controls using
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowpos SetWindowPos}
     * instead of {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-deferwindowpos DeferWindowPos}.
     *
     * @param {Number} [Options.WinDelay = 10] - If nonzero, immediately before each resize cycle,
     * {@link https://www.autohotkey.com/docs/v2/lib/SetWinDelay.htm SetWinDelay} is called with
     * this value.
     */
    __New(GuiObj, Options?, Controls?, DeferActivation := false, ControlsOnly := false) {
        GuiResizer.Options(this, Options ?? unset)
        this.HwndGui := GuiObj.Hwnd
        /**
         * One of the following values:
         * - 0 : The {@link GuiResizer} is not currently a callback for the Size event.
         * - 1 : The {@link GuiResizer} is activating.
         * - 2 : The {@link GuiResizer} is updating.
         * - 3 : The {@link GuiResizer} is set as a callback for the Size event and is idle.
         * - 4 : The {@link GuiResizer} has been called in response to the Size event.
         * - 5 : The {@link GuiResizer} is active in the core resize loop and is adjusting the controls.
         * @memberof GuiResizer
         * @instance
         * @type {Integer}
         */
        this.Status := 0
        this.Rect := GuiResizer_Rect()
        constructor := this.Constructor := Class()
        constructor.Base := GuiResizer_Item
        constructor.Prototype := { GuiResizer: this, __Class: constructor.Base.Prototype.__Class }
        ObjRelease(ObjPtr(this))
        ObjSetBase(constructor.Prototype, constructor.Base.Prototype)
        if !DeferActivation {
            this.Activate(Controls ?? unset, ControlsOnly)
        }
    }

    /**
     * Performs initial calculations and creates the {@link GuiResizer_Item} objects for each
     * control with a "Resizer" property. Also sets the Size event handler.
     *
     * {@link GuiResizer.Prototype.Activate} cannot be called when the gui is minimized.
     *
     * {@link GuiResizer.Prototype.Activate} must be called once before using the {@link GuiResizer}.
     *
     * {@link GuiResizer.Prototype.Activate} can be called multiple times to update the controls
     * that are adjusted when the Size event is raised, and/or change individual controls' resizer
     * options.
     *
     * @param {Gui.Control[]|Gui.Control} [Controls] - If `Controls` is not set, all of the controls
     * in the gui object's internal collection are iterated, and any with a "Resizer" property are
     * processed to create a {@link GuiResizer_Item} object.
     *
     * If `Controls` is set, it is a `Gui.Control` object or an array of `Gui.Control` objects with
     * property "Resizer" with the resize options for that control. See the description above
     * {@link GuiResizer.Prototype.__New} for more information.
     *
     * @param {Boolean} [ControlsOnly = false] - If true, the gui object's internal collection is
     * not iterated and only the objects in `Controls` are used. if false, the gui object's internal
     * collection is iterated and the objects with a "Resizer" property are processed in addition
     * to the objects in `Controls`.
     *
     * If `Controls` is unset, `ControlsOnly` is ignored.
     */
    Activate(Controls?, ControlsOnly := false) {
        flag_status := this.Status
        this.Status := 1
        if this.DpiAwarenessContext {
            DllCall(g_user32_SetThreadDpiAwarenessContext, 'ptr', this.DpiAwarenessContext, 'ptr')
        }
        this.MinMax := WinGetMinMax(this.HwndGui)
        if this.MinMax = -1 {
            throw Error('The window may not be minimized when calling ``' A_ThisFunc '``.')
        }
        this.Rect.Client(this.HwndGui)
        this.BaseW := this.LastW := this.Rect.W
        this.BaseH := this.LastH := this.Rect.H
        move := this.Move := []
        size := this.Size := []
        moveAndSize := this.MoveAndSize := []
        noDefer := this.NoDefer := { Move: [], Size: [], MoveAndSize: [] }
        constructor := this.Constructor
        ; To keep track of hwnds so none are duplicated.
        list := Map()
        list.CaseSense := false
        proc := this.NoDeferAll ? _ProcNoDefer : _Proc
        if IsSet(Controls) {
            if Controls is Array {
                proc(Controls)
            } else {
                proc([ Controls ])
            }
            if !ControlsOnly {
                proc(this.Gui)
            }
        } else {
            proc(this.Gui)
        }
        if !flag_status {
            this.Gui.OnEvent('Size', this, this.AddRemove)
        }
        this.Status := 3
        if noDefer.Move.Length || noDefer.Size.Length || noDefer.MoveAndSize.Length {
            this.flag_noDefer := true
        } else if this.HasOwnProp('flag_noDefer') {
            this.DeleteProp('flag_noDefer')
        }
        if move.Length || size.Length || moveAndSize.Length {
            this.flag_defer := true
        } else if this.HasOwnProp('flag_defer') {
            this.DeleteProp('flag_defer')
        }

        _Proc(obj) {
            for ctrl in obj {
                if !HasProp(ctrl, 'Resizer') || list.Has(ctrl.Hwnd) {
                    continue
                }
                list.Set(ctrl.Hwnd, 1)
                item := constructor(ctrl.Resizer, ctrl.Hwnd)
                if item.NoDefer {
                    if item.Move {
                        if item.Size {
                            noDefer.MoveAndSize.Push(item)
                        } else {
                            noDefer.Move.Push(item)
                        }
                    } else if item.Size {
                        noDefer.Size.Push(item)
                    } else {
                        _Throw(ctrl)
                    }
                } else if item.Move {
                    if item.Size {
                        moveAndSize.Push(item)
                    } else {
                        move.Push(item)
                    }
                } else if item.Size {
                    size.Push(item)
                } else {
                    _Throw(ctrl)
                }
            }
        }
        _ProcNoDefer(obj) {
            for ctrl in obj {
                if !HasProp(ctrl, 'Resizer') || list.Has(ctrl.Hwnd) {
                    continue
                }
                list.Set(ctrl.Hwnd, 1)
                item := constructor(ctrl.Resizer, ctrl.Hwnd)
                if item.Move {
                    if item.Size {
                        noDefer.MoveAndSize.Push(item)
                    } else {
                        noDefer.Move.Push(item)
                    }
                } else if item.Size {
                    noDefer.Size.Push(item)
                } else {
                    _Throw(ctrl)
                }
            }
        }
        _Throw(ctrl) {
            throw Error('The control`'s resizer parameters are invalid.', -1, HasProp(ctrl, 'Name') ? 'Control`'s name: ' ctrl.Name : unset)
        }
    }
    /**
     * Called when the Size event is raised. This disables the Size event handler, overrides the
     * "Call" property with the "Resize" method, then calls {@link GuiResizer.Prototype.Resize} to
     * start the core resize loop.
     */
    Call(GuiObj, MinMax, w, h) {
        this.Status := 4
        if MinMax = 1 {
            this.MinMax := 1
            if w = this.LastW && h = this.LastH {
                this.Status := 3
                return
            }
        } else if MinMax = -1 {
            this.MinMax := -1
            this.Status := 3
            return
        }
        if this.CallbackOnStart {
            this.CallbackOnStart.Call(this)
        }
        this.Status := 5
        if this.DpiAwarenessContext {
            DllCall(g_user32_SetThreadDpiAwarenessContext, 'ptr', this.DpiAwarenessContext, 'ptr')
        }
        if this.WinDelay {
            SetWinDelay(this.WinDelay)
        }
        if IsNumber(this.MinH) {
            if h >= this.MinH {
                if IsNumber(this.MaxH) {
                    h := Min(this.MaxH, h)
                }
            } else {
                h := this.MinH
            }
        } else if IsNumber(this.MaxH) {
            h := Min(this.MaxH, h)
        }
        if IsNumber(this.MinW) {
            if w >= this.MinW {
                if IsNumber(this.MaxW) {
                    w := Min(this.MaxW, w)
                }
            } else {
                w := this.MinW
            }
        } else if IsNumber(this.MaxW) {
            w := Min(this.MaxW, w)
        }
        diffH := h - this.BaseH
        diffW := w - this.BaseW
        if this.flag_defer {
            if hDwp := DllCall(g_user32_BeginDeferWindowPos, 'int', this.Move.Length + this.Size.Length + this.MoveAndSize.Length, 'ptr') {
                for item in this.Move {
                    if hDwp := DllCall(g_user32_DeferWindowPos
                        , 'ptr', hDwp
                        , 'ptr', item.Hwnd
                        , 'ptr', 0                              ; hWndInsertAfter
                        , 'int', item.GetX(diffW)               ; X
                        , 'int', item.GetY(diffH)               ; Y
                        , 'int', 0                              ; W
                        , 'int', 0                              ; H
                        , 'uint', item.Flags_Move               ; flags
                        , 'ptr'
                    ) {
                        continue
                    } else {
                        throw OSError()
                    }
                }
                for item in this.Size {
                    if hDwp := DllCall(g_user32_DeferWindowPos
                        , 'ptr', hDwp
                        , 'ptr', item.Hwnd
                        , 'ptr', 0                              ; hWndInsertAfter
                        , 'int', 0                              ; X
                        , 'int', 0                              ; Y
                        , 'int', item.GetW(diffW)               ; W
                        , 'int', item.GetH(diffH)               ; H
                        , 'uint', item.Flags_Size               ; flags
                        , 'ptr'
                    ) {
                        continue
                    } else {
                        throw OSError()
                    }
                }
                for item in this.MoveAndSize {
                    if hDwp := DllCall(g_user32_DeferWindowPos
                        , 'ptr', hDwp
                        , 'ptr', item.Hwnd
                        , 'ptr', 0                              ; hWndInsertAfter
                        , 'int', item.GetX(diffW)               ; X
                        , 'int', item.GetY(diffH)               ; Y
                        , 'int', item.GetW(diffW)               ; W
                        , 'int', item.GetH(diffH)               ; H
                        , 'uint', item.Flags_MoveAndSize        ; flags
                        , 'ptr'
                    ) {
                        continue
                    } else {
                        throw OSError()
                    }
                }
                if !DllCall(g_user32_EndDeferWindowPos, 'ptr', hDwp, 'ptr') {
                    throw OSError()
                }
            } else {
                throw OSError()
            }
        }
        if this.flag_noDefer {
            noDefer := this.NoDefer
            for item in noDefer.Move {
                if DllCall(g_user32_SetWindowPos
                    , 'ptr', item.Hwnd
                    , 'ptr', 0                              ; hWndInsertAfter
                    , 'int', item.GetX(diffW)               ; X
                    , 'int', item.GetY(diffH)               ; Y
                    , 'int', 0                              ; W
                    , 'int', 0                              ; H
                    , 'uint', item.Flags_Move               ; flags
                    , 'ptr'
                ) {
                    continue
                } else {
                    throw OSError()
                }
            }
            for item in noDefer.Size {
                if DllCall(g_user32_SetWindowPos
                    , 'ptr', item.Hwnd
                    , 'ptr', 0                              ; hWndInsertAfter
                    , 'int', 0                              ; X
                    , 'int', 0                              ; Y
                    , 'int', item.GetW(diffW)               ; W
                    , 'int', item.GetH(diffH)               ; H
                    , 'uint', item.Flags_Size               ; flags
                    , 'ptr'
                ) {
                    continue
                } else {
                    throw OSError()
                }
            }
            for item in noDefer.MoveAndSize {
                if DllCall(g_user32_SetWindowPos
                    , 'ptr', item.Hwnd
                    , 'ptr', 0                              ; hWndInsertAfter
                    , 'int', item.GetX(diffW)               ; X
                    , 'int', item.GetY(diffH)               ; Y
                    , 'int', item.GetW(diffW)               ; W
                    , 'int', item.GetH(diffH)               ; H
                    , 'uint', item.Flags_MoveAndSize        ; flags
                    , 'ptr'
                ) {
                    continue
                } else {
                    throw OSError()
                }
            }
        }
        if this.CallbackOnEnd {
            this.CallbackOnEnd.Call(this)
        }
        this.Status := 3
    }
    /**
     * Disables the Size event callback.
     */
    Deactivate() {
        this.Gui.OnEvent('Size', this, 0)
        this.Status := 0
    }
    /**
     * Updates the cached size and dimension values for the gui window and the controls to their
     * current values. Call {@link GuiResizer.Prototype.Update} when your code has manually made
     * adjustments to the size / position of the controls. For example, if your code responds to
     * a window DPI change, your code should call {@link GuiResizer.Prototype.Update} when finished
     * making those changes so those changes can be reflected when processing future Size events.
     * If {@link GuiResizer.Prototype.Update} is not called, the next Size event will cause
     * unexpected behavior.
     *
     * Do not use {@link GuiResizer.Prototype.Update} if your intent is to add / remove controls
     * from the collection of controls that will be adjusted when the Size event is raised.
     * Use {@link GuiResizer.Prototype.Activate} instead.
     */
    Update() {
        this.Status := 2
        originalCritical := Critical(-1)
        if this.DpiAwarenessContext {
            DllCall(g_user32_SetThreadDpiAwarenessContext, 'ptr', this.DpiAwarenessContext, 'ptr')
        }
        this.MinMax := WinGetMinMax(this.HwndGui)
        if this.MinMax = -1 {
            throw Error('The window may not be minimized when calling ``' A_ThisFunc '``.')
        }
        enum := IsSet(Controls) ? Controls.__Enum : this.Gui.__Enum
        rc := GuiResizer_Rect()
        rc.Client(this.HwndGui)
        this.BaseW := this.LastW := rc.W
        this.BaseH := this.LastH := rc.H
        for list in [ this.Move, this.Size, this.MoveAndSize ] {
            for item in list {
                item.Update()
            }
        }
        this.Status := 3
        Critical(originalCritical)
        this.Gui.OnEvent('Size', this, 1)
    }
    __Delete() {
        if this.HasOwnProp('Constructor') && this.Constructor.HasOwnProp('Prototype') {
            proto := this.Constructor.Prototype
            if proto.HasOwnProp('GuiResizer') && proto.GuiResizer = this {
                ObjPtrAddRef(this)
                proto.DeleteProp('GuiResizer')
            }
        }
    }

    Gui => GuiFromHwnd(this.HwndGui)

    class Options {
        static Default := {
            AddRemove: -1
          , CallbackOnEnd: ''
          , CallbackOnStart: ''
          , DpiAwarenessContext: ''
          , MaxH: ''
          , MaxW: ''
          , MinH: ''
          , MinW: ''
          , NoDeferAll: false
          , WinDelay: 10
        }
        static Call(GuiResizerObj, Options?) {
            d := this.Default
            if IsSet(Options) {
                if HasProp(Options, 'Delay') && options.Delay > 0 {
                    throw ValueError('``Options.Delay`` must be <= 0.', , options.Delay)
                }
                if HasProp(Options, 'StopCount') && options.StopCount <= 1 {
                    throw ValueError('``Options.StopCount`` must be > 1.', , options.StopCount)
                }
                for prop in d.OwnProps() {
                    GuiResizerObj.%prop% := HasProp(Options, prop) ? Options.%prop% : d.%prop%
                }
            } else {
                for prop, val in d.OwnProps() {
                    GuiResizerObj.%prop% := val
                }
            }
        }
    }
}


class GuiResizer_Item {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.X := proto.MaxX := proto.MinX :=
        proto.Y := proto.MaxY := proto.MinY :=
        proto.W := proto.MaxW := proto.MinW :=
        proto.H := proto.MaxH := proto.MinH :=
        proto.MinMaxX := proto.MinMaxY := proto.MinMaxW := proto.MinMaxH :=
        proto.Scale := proto.Move := proto.Size := proto.Group := proto.NoDefer := 0
        proto.SharedRect := GuiResizer_Rect()
    }
    __New(obj, hwnd) {
        if HasProp(obj, 'X') && obj.X {
            this.X := obj.X
            this.Move := 1
            if HasProp(obj, 'MaxX') {
                this.MaxX := obj.MaxX
                this.MinMaxX := 1
            }
            if HasProp(obj, 'MinX') {
                this.MinX := obj.MinX
                this.MinMaxX := this.MinMaxX + 2
            }
        }
        if HasProp(obj, 'Y') && obj.Y {
            this.Y := obj.Y
            this.Move := this.Move + 2
            if HasProp(obj, 'MaxY') {
                this.MaxY := obj.MaxY
                this.MinMaxY := 1
            }
            if HasProp(obj, 'MinY') {
                this.MinY := obj.MinY
                this.MinMaxY := this.MinMaxY + 2
            }
        }
        if HasProp(obj, 'W') && obj.W {
            this.W := obj.W
            this.Size := 1
            if HasProp(obj, 'MaxW') {
                this.MaxW := obj.MaxW
                this.MinMaxW := 1
            }
            if HasProp(obj, 'MinW') {
                this.MinW := obj.MinW
                this.MinMaxW := this.MinMaxW + 2
            }
        }
        if HasProp(obj, 'H') && obj.H {
            this.H := obj.H
            this.Size := this.Size + 2
            if HasProp(obj, 'MaxH') {
                this.MaxH := obj.MaxH
                this.MinMaxH := 1
            }
            if HasProp(obj, 'MinH') {
                this.MinH := obj.MinH
                this.MinMaxH := this.MinMaxH + 2
            }
        }
        if HasProp(obj, 'Scale') {
            this.Scale := obj.Scale
        }
        this.Hwnd := hwnd
        proto := GuiResizer_Item.Prototype
        switch this.Move {
            case 1:
                this.Group := 1
                switch this.MinMaxX {
                    case 0: this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_NoMaxNoMin'))
                    case 1: this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_Max'))
                    case 2: this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_Min'))
                    case 3: this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_MaxMin'))
                }
                this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_Base'))
            case 2:
                this.Group := 1
                switch this.MinMaxY {
                    case 0: this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_NoMaxNoMin'))
                    case 1: this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_Max'))
                    case 2: this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_Min'))
                    case 3: this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_MaxMin'))
                }
                this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_Base'))
            case 3:
                this.Group := 1
                switch this.MinMaxX {
                    case 0: this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_NoMaxNoMin'))
                    case 1: this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_Max'))
                    case 2: this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_Min'))
                    case 3: this.DefineProp('GetX', proto.GetOwnPropDesc('GetX_MaxMin'))
                }
                switch this.MinMaxY {
                    case 0: this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_NoMaxNoMin'))
                    case 1: this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_Max'))
                    case 2: this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_Min'))
                    case 3: this.DefineProp('GetY', proto.GetOwnPropDesc('GetY_MaxMin'))
                }
        }
        if this.Scale {
            switch this.Size {
                case 1:
                    this.Group := this.Group + 2
                    switch this.MinMaxW {
                        case 0: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_NoMaxNoMin_Scale'))
                        case 1: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Max_Scale'))
                        case 2: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Min_Scale'))
                        case 3: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_MaxMin_Scale'))
                    }
                    this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Base'))
                case 2:
                    this.Group := this.Group + 2
                    switch this.MinMaxH {
                        case 0: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_NoMaxNoMin_Scale'))
                        case 1: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Max_Scale'))
                        case 2: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Min_Scale'))
                        case 3: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_MaxMin_Scale'))
                    }
                    this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Base'))
                case 3:
                    this.Group := this.Group + 2
                    switch this.MinMaxW {
                        case 0: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_NoMaxNoMin_Scale'))
                        case 1: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Max_Scale'))
                        case 2: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Min_Scale'))
                        case 3: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_MaxMin_Scale'))
                    }
                    switch this.MinMaxH {
                        case 0: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_NoMaxNoMin_Scale'))
                        case 1: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Max_Scale'))
                        case 2: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Min_Scale'))
                        case 3: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_MaxMin_Scale'))
                    }
            }
        } else {
            switch this.Size {
                case 1:
                    this.Group := this.Group + 2
                    switch this.MinMaxW {
                        case 0: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_NoMaxNoMin'))
                        case 1: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Max'))
                        case 2: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Min'))
                        case 3: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_MaxMin'))
                    }
                    this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Base'))
                case 2:
                    this.Group := this.Group + 2
                    switch this.MinMaxH {
                        case 0: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_NoMaxNoMin'))
                        case 1: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Max'))
                        case 2: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Min'))
                        case 3: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_MaxMin'))
                    }
                    this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Base'))
                case 3:
                    this.Group := this.Group + 2
                    switch this.MinMaxW {
                        case 0: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_NoMaxNoMin'))
                        case 1: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Max'))
                        case 2: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_Min'))
                        case 3: this.DefineProp('GetW', proto.GetOwnPropDesc('GetW_MaxMin'))
                    }
                    switch this.MinMaxH {
                        case 0: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_NoMaxNoMin'))
                        case 1: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Max'))
                        case 2: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_Min'))
                        case 3: this.DefineProp('GetH', proto.GetOwnPropDesc('GetH_MaxMin'))
                    }
            }
        }
        this.Update()
        if HasProp(obj, 'Flags') {
            switch this.Group {
                case 1: this.DefineProp('Flags_Move', { Value: obj.Flags })
                case 2: this.DefineProp('Flags_Size', { Value: obj.Flags })
                case 3: this.DefineProp('Flags_MoveAndSize', { Value: obj.Flags })
            }
        }
        if HasProp(obj, 'NoDefer') && obj.NoDefer {
            this.NoDefer := true
        }
    }
    Update() {
        rc := this.SharedRect
        rc(this.Hwnd)
        rc.ToClient(this.GuiResizer.HwndGui)
        this.BaseX := rc.X
        this.BaseY := rc.Y
        this.BaseW := rc.W
        this.BaseH := rc.H
        this.BaseR := rc.R
        this.BaseB := rc.B
    }
    GetX_Base(*) => this.BaseX
    GetX_NoMaxNoMin(diffW) => this.BaseX + diffW * this.X
    GetX_Max(diffW) => Min(this.BaseX + diffW * this.X, this.MaxX)
    GetX_Min(diffW) => Max(this.BaseX + diffW * this.X, this.MinX)
    GetX_MaxMin(diffW) {
        x := this.BaseX + diffW * this.X
        if x >= this.MinX {
            return Min(x, this.MaxX)
        } else {
            return Max(x, this.MinX)
        }
    }
    GetY_Base(*) => this.BaseY
    GetY_NoMaxNoMin(diffH) => this.BaseY + diffH * this.Y
    GetY_Max(diffH) => Min(this.BaseY + diffH * this.Y, this.MaxY)
    GetY_Min(diffH) => Max(this.BaseY + diffH * this.Y, this.MinY)
    GetY_MaxMin(diffH) {
        y := this.BaseY + diffH * this.Y
        if y >= this.MinY {
            return Min(y, this.MaxY)
        } else {
            return Max(y, this.MinY)
        }
    }
    GetW_Base(*) => this.BaseW
    GetW_NoMaxNoMin(diffW) => this.BaseW + diffW * this.W
    GetW_Max(diffW) => Min(this.BaseW + diffW * this.W, this.MaxW)
    GetW_Min(diffW) => Max(this.BaseW + diffW * this.W, this.MinW)
    GetW_MaxMin(diffW) {
        w := this.BaseW + diffW * this.W
        if w >= this.MinW {
            return Min(w, this.MaxW)
        } else {
            return Max(w, this.MinW)
        }
    }
    GetH_Base(*) => this.BaseH
    GetH_NoMaxNoMin(diffH) => this.BaseH + diffH * this.H
    GetH_Max(diffH) => Min(this.BaseH + diffH * this.H, this.MaxH)
    GetH_Min(diffH) => Max(this.BaseH + diffH * this.H, this.MinH)
    GetH_MaxMin(diffH) {
        h := this.BaseH + diffH * this.H
        if h >= this.MinH {
            return Min(h, this.MaxH)
        } else {
            return Max(h, this.MinH)
        }
    }
    GetW_NoMaxNoMin_Scale(diffW) => this.BaseW * (1 + diffW / this.GuiResizer.BaseW) * this.W
    GetW_Max_Scale(diffW) => Min(this.BaseW * (1 + diffW / this.GuiResizer.BaseW) * this.W, this.MaxW)
    GetW_Min_Scale(diffW) => Max(this.BaseW * (1 + diffW / this.GuiResizer.BaseW) * this.W, this.MinW)
    GetW_MaxMin_Scale(diffW) {
        w := this.BaseW * (1 + diffW / this.GuiResizer.BaseW) * this.W
        if w >= this.MinW {
            return Min(w, this.MaxW)
        } else {
            return Max(w, this.MinW)
        }
    }
    GetH_NoMaxNoMin_Scale(diffH) => this.BaseH * (1 + diffH / this.GuiResizer.BaseH) * this.H
    GetH_Max_Scale(diffH) => Min(this.BaseH * (1 + diffH / this.GuiResizer.BaseH) * this.H, this.MaxH)
    GetH_Min_Scale(diffH) => Max(this.BaseH * (1 + diffH / this.GuiResizer.BaseH) * this.H, this.MinH)
    GetH_MaxMin_Scale(diffH) {
        h := this.BaseH * (1 + diffH / this.GuiResizer.BaseH) * this.H
        if h >= this.MinH {
            return Min(h, this.MaxH)
        } else {
            return Max(h, this.MinH)
        }
    }

    Flags_Move => GuiResizer_Swp_Move
    Flags_MoveAndSize => GuiResizer_Swp_MoveAndSize
    Flags_Size => GuiResizer_Swp_Size
}

class GuiResizer_Rect extends Buffer {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.offset_left    := 0
        proto.offset_top     := 4
        proto.offset_right   := 8
        proto.offset_bottom  := 12
    }
    __New() {
        this.Size := 16
    }
    Call(hwnd) {
        if !DllCall(g_user32_GetWindowRect, 'ptr', hwnd, 'ptr', this, 'int') {
            throw OSError()
        }
    }
    Client(hwnd) {
        if !DllCall(g_user32_GetClientRect, 'ptr', hwnd, 'ptr', this, 'int') {
            throw OSError()
        }
    }
    ToClient(hwndParent) {
        if !DllCall(g_user32_ScreenToClient, 'ptr', hwndParent, 'ptr', this, 'int') {
            throw OSError()
        }
        if !DllCall(g_user32_ScreenToClient, 'ptr', hwndParent, 'ptr', this.Ptr + 8, 'int') {
            throw OSError()
        }
    }
    ToScreen(hwndParent) {
        if !DllCall(g_user32_ClientToScreen, 'ptr', hwndParent, 'ptr', this, 'int') {
            throw OSError()
        }
        if !DllCall(g_user32_ClientToScreen, 'ptr', hwndParent, 'ptr', this.Ptr + 8, 'int') {
            throw OSError()
        }
    }
    L {
        Get => NumGet(this, this.offset_left, 'uint')
        Set {
            NumPut('uint', Value, this, this.offset_left)
        }
    }
    T {
        Get => NumGet(this, this.offset_top, 'uint')
        Set {
            NumPut('uint', Value, this, this.offset_top)
        }
    }
    R {
        Get => NumGet(this, this.offset_right, 'uint')
        Set {
            NumPut('uint', Value, this, this.offset_right)
        }
    }
    B {
        Get => NumGet(this, this.offset_bottom, 'uint')
        Set {
            NumPut('uint', Value, this, this.offset_bottom)
        }
    }
    X {
        Get => NumGet(this, this.offset_left, 'uint')
        Set {
            NumPut('uint', Value, this, this.offset_left)
        }
    }
    Y {
        Get => NumGet(this, this.offset_top, 'uint')
        Set {
            NumPut('uint', Value, this, this.offset_top)
        }
    }
    H => NumGet(this, 12, 'int') - NumGet(this, 4, 'int')
    W => NumGet(this, 8, 'int') - NumGet(this, 0, 'int')
}

class TabEx_TcItem {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.cbSize :=
        ; Size      Type        Symbol         Offset                Padding
        4 +         ; UINT      mask           0
        4 +         ; DWORD     dwState        4
        A_PtrSize + ; DWORD     dwStateMask    8                     +4 on x64 only
        A_PtrSize + ; LPWSTR    pszText        8 + A_PtrSize * 1
        4 +         ; int       cchTextMax     8 + A_PtrSize * 2
        4 +         ; int       iImage         12 + A_PtrSize * 2
        A_PtrSize   ; LPARAM    lParam         16 + A_PtrSize * 2
        proto.offset_mask := 0
        proto.offset_dwState := 4
        proto.offset_dwStateMask := 8
        proto.offset_pszText := 8 + A_PtrSize * 1
        proto.offset_cchTextMax := 8 + A_PtrSize * 2
        proto.offset_iImage := 12 + A_PtrSize * 2
        proto.offset_lParam := 16 + A_PtrSize * 2
    }
    /**
     * @param {Integer} mask - One or more of the following values. To combine values, use the bitwise
     * "|", e.g. `TabEx_TcItemObj.mask := 16 | 2`.
     * <pre>
     * |  Symbol             Value    Meaning                                                   |
     * |  ------------------------------------------------------------------------------------  |
     * |  TCIF_IMAGE         1        The iImage member is valid.                               |
     * |  TCIF_PARAM         2        The lParam member is valid.                               |
     * |  TCIF_RTLREADING    4        The string pointed to by pszText will be displayed in     |
     * |                              the direction opposite to the text in the parent window.  |
     * |  TCIF_STATE         8        The dwState member is valid.                              |
     * |  TCIF_TEXT          16       The pszText member is valid.                              |
     * </pre>
     *
     * @param {Integer} [dwState] - Either 1 or 0 to enable or disable the state flag indicated by
     * `dwStateMask`.
     *
     * @param {Integer} [dwStateMask] - One of the following values:
     * <pre>
     * |  Symbol                Value    Meaning                                                   |
     * |  ---------------------------------------------------------------------------------------  |
     * |  TCIS_BUTTONPRESSED    1        The tab control item is selected. This state is only      |
     * |                                 meaningful if the TCS_BUTTONS style flag has been set.    |
     * |  TCIS_HIGHLIGHTED      2        The tab control item is highlighted, and the tab and      |
     * |                                 text are drawn using the current highlight color. When    |
     * |                                 using high-color, this will be a true interpolation,      |
     * |                                 not a dithered color.                                     |
     * </pre>
     *
     * @param {String} [pszText] - If using the `TabEx_TcItem` structure to set a tab's text, pass
     * the text as string to `pszText` and leave `cchTextMatch` unset.
     *
     * @param {Integer} [cchTextMatch] - If using the `TabEx_TcItem` structure to get information about
     * a tab, pass the maximum string length to `cchTextMax` as integer and leave `pszText` unset.
     *
     * @param {Integer} [iImage] - Index in the tab control's image list, or -1 if there is no
     * image for the tab.
     *
     * @param {Integer} [lParam] - An integer to associate with the tab.
     *
     */
    __New(mask?, dwState?, dwStateMask?, pszText?, cchTextMax?, iImage?, lParam?) {
        this.Buffer := Buffer(this.cbSize)
        if IsSet(mask) {
            this.mask := mask
        }
        if IsSet(dwState) {
            this.dwState := dwState
        }
        if IsSet(dwStateMask) {
            this.dwStateMask := dwStateMask
        }
        if IsSet(pszText) {
            this.pszText := pszText
        }
        if IsSet(cchTextMax) {
            this.cchTextMax := cchTextMax
        }
        if IsSet(iImage) {
            this.iImage := iImage
        }
        if IsSet(lParam) {
            this.lParam := lParam
        }
    }
    mask {
        Get => NumGet(this.Buffer, this.offset_mask, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_mask)
        }
    }
    dwState {
        Get => NumGet(this.Buffer, this.offset_dwState, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwState)
        }
    }
    dwStateMask {
        Get => NumGet(this.Buffer, this.offset_dwStateMask, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwStateMask)
        }
    }
    pszText {
        Get {
            if ptr := NumGet(this.Buffer, this.offset_pszText, 'ptr') {
                return StrGet(ptr, 'cp1200')
            } else {
                return ''
            }
        }
        Set {
            if this.HasOwnProp('__pszText') {
                bytes := StrPut(Value, 'UTF-16')
                if this.__pszText.Size < bytes {
                    this.__pszText.Size := bytes
                    NumPut('ptr', this.__pszText.Ptr, this.Buffer, this.offset_pszText)
                    NumPut('int', this.__pszText.Size / 2, this.Buffer, this.offset_cchTextMax)
                }
            } else {
                this.__pszText := Buffer(StrPut(Value, 'UTF-16'))
                NumPut('ptr', this.__pszText.Ptr, this.Buffer, this.offset_pszText)
                NumPut('int', this.__pszText.Size / 2, this.Buffer, this.offset_cchTextMax)
            }
            StrPut(Value, this.__pszText, 'UTF-16')
        }
    }
    cchTextMax {
        Get => NumGet(this.Buffer, this.offset_cchTextMax, 'int')
        Set {
            this.__pszText := Buffer(Value * 2)
            NumPut('ptr', this.__pszText.Ptr, this.Buffer, this.offset_pszText)
            NumPut('int', Value, this.Buffer, this.offset_cchTextMax)
        }
    }
    iImage {
        Get => NumGet(this.Buffer, this.offset_iImage, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iImage)
        }
    }
    lParam {
        Get => NumGet(this.Buffer, this.offset_lParam, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lParam)
        }
    }
    Ptr => this.Buffer.Ptr
    Size => this.Buffer.Size
}

/**
 * The display area is the area within which the tab's controls are visible.
 *
 * The window area is the window's entire area, including tabs and margins.
 */
class TabEx extends Gui.Tab {
    static __New() {
        this.DeleteProp('__New')
        this.SetConstants()
        this.SetDpiAwarenessContext()
    }

    /**
     * Creates a new tab control and associated `TabEx` object.
     * @param {Gui} GuiObj - The Gui to which to add the tab control.
     * @param {String} Which - One of the following: "Tab", "Tab2", or "Tab3" (first parameter
     * of `Gui.Add`).
     * @param {String} [Opt] - The options to use when creating the tab control (second parameter
     * of `Gui.Add`).
     * @param {String[]} [Text] - The tab labels to create when instantiating the tab control
     * (third parameter of `Gui.Add`).
     */
    static Call(GuiObj, Which, Opt?, Text?) {
        tab := GuiObj.Add(Which, Opt ?? unset, Text ?? unset)
        ObjSetBase(tab, this.Prototype)
        return tab
    }

    /**
     * @param {Gui.Tab} TabCtrl - The `Gui.Tab` object to convert to {@link TabEx}. This sets
     * `TabCtrl.Base := TabEx.Prototype`.
     * @returns {TabEx} - The same object but with the base changed.
     */
    static Convert(TabCtrl) {
        ObjSetBase(TabCtrl, this.Prototype)
        return TabCtrl
    }

    static SetConstants() {
        global
        TABEX_DEFAULT_TEXT_MAX := 256
        TCM_FIRST := 0x1300

        TCM_ADJUSTRECT := TCM_FIRST + 40
        TCM_DELETEALLITEMS := TCM_FIRST + 9
        ; TCM_DELETEITEM := TCM_FIRST + 8
        TCM_DESELECTALL := TCM_FIRST + 50
        TCM_GETCURFOCUS := TCM_FIRST + 47
        TCM_GETCURSEL := TCM_FIRST + 11
        TCM_GETEXTENDEDSTYLE := TCM_FIRST + 53
        TCM_GETIMAGELIST := TCM_FIRST + 2
        TCM_GETITEMW := TCM_FIRST + 60
        ; TCM_GETITEMA := TCM_FIRST + 5
        TCM_GETITEMCOUNT := TCM_FIRST + 4
        TCM_GETITEMRECT := TCM_FIRST + 10
        TCM_GETROWCOUNT := TCM_FIRST + 44
        ; TCM_GETTOOLTIPS := TCM_FIRST + 45
        TCM_HIGHLIGHTITEM := TCM_FIRST + 51
        TCM_HITTEST := TCM_FIRST + 13
        ; TCM_INSERTITEM := TCM_INSERTITEMW := TCM_FIRST + 62
        ; TCM_INSERTITEMA := TCM_FIRST + 7
        TCM_REMOVEIMAGE := TCM_FIRST + 42
        TCM_SETCURFOCUS := TCM_FIRST + 48
        TCM_SETCURSEL := TCM_FIRST + 12
        TCM_SETEXTENDEDSTYLE := TCM_FIRST + 52
        TCM_SETIMAGELIST := TCM_FIRST + 3
        TCM_SETITEMW := TCM_FIRST + 61
        ; TCM_SETITEMA := TCM_FIRST + 6
        ; TCM_SETITEMEXTRA := TCM_FIRST + 14
        TCM_SETITEMSIZE := TCM_FIRST + 41
        TCM_SETMINTABWIDTH := TCM_FIRST + 49
        TCM_SETPADDING := TCM_FIRST + 43
        ; TCM_SETTOOLTIPS := TCM_FIRST + 46

        ; TCHT_NOWHERE := 0x0001
        ; TCHT_ONITEMICON := 0x0002
        ; TCHT_ONITEMLABEL := 0x0004
        ; TCHT_ONITEM := TCHT_ONITEMICON | TCHT_ONITEMLABEL


        TCS_EX_FLATSEPARATORS    := 0x00000001
        TCS_EX_REGISTERDROP      := 0x00000002

        TCIF_TEXT                := 0x0001
        TCIF_IMAGE               := 0x0002
        TCIF_RTLREADING          := 0x0004
        TCIF_PARAM               := 0x0008
        TCIF_STATE               := 0x0010

        TCIS_BUTTONPRESSED       := 0x0001
        TCIS_HIGHLIGHTED         := 0x0002
    }

    /**
     * Sets the dpi awareness context value used when calling a method with the "_S" suffix.
     * See {@link TabEx.Prototype.__Call}.
     */
    static SetDpiAwarenessContext(Value := -4) {
        this.Prototype.DpiAwarenessContext := Value
    }

    /**
     * @description - Delets all tabs.
     */
    DeleteAll() {
        return SendMessage(TCM_DELETEALLITEMS, 0, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @param {Boolean} [Scope=false] - Flag that specifies the scope of the item deselection. If this
     * parameter is set to FALSE, all tab items will be reset. If it is set to TRUE, then all tab
     * items except for the one currently selected will be reset.
     */
    DeselectAll(Scope := false) {
        SendMessage(TCM_DESELECTALL, Scope, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - The input is a display rectangle, and the output is the window rectangle
     * necessary for a tab control to have a display rectangle of the input dimensions.
     * @param {Rect} rc - The display rectangle.
     * @returns {Rect} - The window rectangle (same object with new values)
     */
    DisplayToWindow(rc) {
        SendMessage(TCM_ADJUSTRECT, true, rc, this.hWnd, this.Gui.hWnd)
        return rc
    }

    /**
     * @description - Returns the control's display rectangle relative to the parent window.
     * @returns {Rect}
     */
    GetClientDisplayRect() {
        rc := Rect()
        if !DllCall('GetWindowRect', 'ptr', this.hWnd, 'ptr', rc, 'int') {
            throw OSError()
        }
        rc.ToClient(this.Gui.hWnd, true)
        SendMessage(TCM_ADJUSTRECT, false, rc, this.hWnd, this.Gui.hWnd)
        return rc
    }

    /**
     * @description - Returns the control's window rectangle relative to the parent window.
     * @returns {Rect}
     */
    GetClientWindowRect() {
        rc := Rect()
        if !DllCall('GetWindowRect', 'ptr', this.hWnd, 'ptr', rc, 'int') {
            throw OSError()
        }
        rc.ToClient(this.Gui.hWnd, true)
        return rc
    }

    /**
     * @description - Returns the index of the item that has the focus in a tab control.
     * @returns {Integer}
     */
    GetCurFocus() {
        return SendMessage(TCM_GETCURFOCUS, 0, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Determines the currently selected tab in a tab control.
     * @returns {Integer} - Returns the index of the selected tab if successful, or -1 if no tab is
     * selected.
     */
    GetCurSel() {
        return SendMessage(TCM_GETCURSEL, 0, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Calculates the top-left corner of a tab control's display area relative to the
     * gui window.
     *
     * The display area is the area within which the tab's controls are visible.
     *
     * @param {VarRef} [OutTabDisplayRect] - A variable that will receive the `RECT` object representing
     * the tab's display area that is generated by the function.
     * @returns {POINT}
     */
    GetDisplayTopLeft(&OutTabDisplayRect?) {
        this.GetPos(&tabx, &taby, &tabw, &tabh)
        OutTabDisplayRect := Rect(tabx, taby, tabw + tabx, taby + tabh)
        SendMessage(TCM_ADJUSTRECT, false, OutTabDisplayRect, this.hWnd, this.Gui.hWnd)
        return POINT(tabx + OutTabDisplayRect.l, taby + OutTabDisplayRect.t)
    }

    /**
     * @description - Retrieves the extended styles that are currently in use for the tab control.
     * @returns {Integer} - Returns a DWORD value that represents the extended styles currently in
     * use for the tab control. This value is a combination of tab control extended styles.
     */
    GetExtendedStyle() {
        return SendMessage(TCM_GETEXTENDEDSTYLE, 0, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Retrieves the image list associated with a tab control.
     * @returns {Integer} - Returns the handle to the image list if successful, or NULL otherwise.
     */
    GetImageList() {
        return SendMessage(TCM_GETIMAGELIST, 0, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Retrieves the number of tabs in the tab control.
     * @returns {Integer} - Returns the number of items if successful, or zero otherwise.
     */
    GetItemCount() {
        return SendMessage(TCM_GETITEMCOUNT, 0, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Retrieves the bounding rectangle for a tab in a tab control. The index is 1-based.
     * @returns {Rect}
     * @throws {OSError} - If the `SendMessage` call fails.
     */
    GetItemRect(Index) {
        rc := Rect()
        if !SendMessage(TCM_GETITEMRECT, Index - 1, rc, this.hWnd, this.Gui.hWnd) {
            throw OSError('Failed to get item rect.', -1)
        }
        return rc
    }

    /**
     * @description - Retrieves the current number of rows of tabs in a tab control.
     * @returns {Integer} - The number of rows of tabs.
     */
    GetRowCount() {
        return SendMessage(TCM_GETROWCOUNT, 0, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Returns the control's display rectangle relative to the screen.
     * @returns {Rect}
     */
    GetScreenDisplayRect() {
        rc := Rect()
        if !DllCall('GetWindowRect', 'ptr', this.hWnd, 'ptr', rc, 'int') {
            throw OSError()
        }
        SendMessage(TCM_ADJUSTRECT, false, rc, this.hWnd, this.Gui.hWnd)
        return rc
    }

    /**
     * @description - Returns the control's window rectangle relative to the screen.
     * @returns {Rect}
     */
    GetScreenWindowRect() {
        rc := Rect()
        if !DllCall('GetWindowRect', 'ptr', this.hWnd, 'ptr', rc, 'int') {
            throw OSError()
        }
        return rc
    }

    /**
     * @param {Integer} Index - The index of the tab for which to get the text. The index is 1-based.
     * @param {Integer} [MaxChars = TABEX_DEFAULT_TEXT_MAX] - The maximum characters to copy to the buffer. This can be an
     * overestimate.
     * @returns {String} - The tab's text, or an empty string if the operation failed.
     */
    GetTabText(Index, MaxChars := TABEX_DEFAULT_TEXT_MAX) {
        tcitem := TabEx_TcItem(TCIF_TEXT, , , , MaxChars)
        if SendMessage(TCM_GETITEMW, Index - 1, tcitem.Ptr, this.hWnd, this.Gui.hWnd) {
            return tcitem.pszText
        } else {
            return ''
        }
    }

    /**
     * @param {Integer} Index - The index of the tab to highlight / remove higlighting. The index is 1-based.
     * @param {Boolean} [Value = true] - If true, activates the highlight state. If false, deactivates
     * the highlight state.
     * @returns {Integer} - 1 if successful, 0 if unsuccessful.
     */
    HighlightItem(Index, Value := true) {
        return SendMessage(TCM_HIGHLIGHTITEM, Index - 1, (0 & 0xFFFF) << 16 | (Value & 0xFFFF), this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Determines if a tab is at the input coordinate.
     * @param {Integer} X - The x-coordinate.
     * @param {Integer} Y - The y-coordinate.
     * @returns {Integer} - One of the following values:
     * - 1: The position is not over a tab.
     * - 2: The position is over a tab's icon.
     * - 4: The position is over a tab's text.
     * - 6: The position is over a tab but not over its icon or its text. For owner-drawn tab
     * controls, this value is specified if the position is anywhere over a tab.
     */
    HitTest(X, Y) {
        HitTest := Buffer(12)
        NumPut('int', X, 'int', Y, HitTest, 0)
        SendMessage(TCM_HITTEST, 0, HitTest.ptr, this.hWnd, this.Gui.hWnd)
        return NumGet(HitTest, 8, 'uint')
    }

    /**
     * Returns the index position of the first tab with a label that is the same as the input `Text`.
     * The index position is 1-based.
     *
     * @param {String} Text - The text to compare with the tab labels.
     * @param {Integer} [StartIndex = 1] - The index at which to begin searching.
     * @param {Integer} [EndIndex] - The index at which to stop searching. If unset, all tabs beginning
     * from `StartIndex` are searched.
     * @param {Boolean} [CaseSensitive] - If true, the search is case sensitive.
     * @param {Integer} [MaxChars = TABEX_DEFAULT_TEXT_MAX] - The maximum characters to copy to the buffer.
     * @returns {Integer} - If found, the index. If not found, 0.
     */
    FindTab(Text, StartIndex := 1, EndIndex?, CaseSensitive := false, MaxChars := TABEX_DEFAULT_TEXT_MAX) {
        if !IsSet(EndIndex) {
            EndIndex := this.GetItemCount()
        }
        tcitem := TabEx_TcItem(TCIF_TEXT, , , , MaxChars)
        compare := CaseSensitive ? () => Text == tcitem.pszText : () => Text = tcitem.pszText
        loop EndIndex - StartIndex + 1 {
            SendMessage(TCM_GETITEMW, StartIndex - 1, tcitem.Ptr, this.hWnd, this.Gui.hWnd)
            if compare() {
                return StartIndex
            }
            StartIndex++
        }
        return 0
    }

    /**
     * Returns the index position of the first tab with a label that matches with the input `Pattern`.
     * The index position is 1-based.
     *
     * @param {String} Pattern - RegEx pattern.
     * @param {Integer} [StartIndex = 1] - The index at which to begin searching.
     * @param {Integer} [EndIndex] - The index at which to stop searching. If unset, all tabs beginning
     * from `StartIndex` are searched.
     * @param {Integer} [MaxChars = TABEX_DEFAULT_TEXT_MAX] - The maximum characters to copy to the buffer.
     * @param {VarRef} [OutMatch] - A variable that will receive the `RegExMatchInfo` object if a
     * match is found.
     * @returns {Integer}
     */
    FindTabRegEx(Pattern, StartIndex := 1, EndIndex?, MaxChars := TABEX_DEFAULT_TEXT_MAX, &OutMatch?) {
        if !IsSet(EndIndex) {
            EndIndex := this.GetItemCount()
        }
        tcitem := TabEx_TcItem(TCIF_TEXT, , , , MaxChars)
        loop EndIndex - StartIndex + 1 {
            SendMessage(TCM_GETITEMW, StartIndex - 1, tcitem.Ptr, this.hWnd, this.Gui.hWnd)
            if RegExMatch(tcitem.pszText, Pattern, &OutMatch) {
                return StartIndex
            }
            StartIndex++
        }
        return 0
    }

    /**
     * @description - Adjusts the size and position of the control to produce a display area with
     * the input dimensions. If a value is not provided, the current value is used.
     * @param {Integer} [X] - The x-coordinate.
     * @param {Integer} [Y] - The y-coordinate.
     * @param {Integer} [W] - The width.
     * @param {Integer} [H] - The height.
     * @returns {Rect} - The window rectangle.
     */
    MoveEx(X?, Y?, W?, H?) {
        rc := Rect()
        if !DllCall('GetWindowRect', 'ptr', this.hWnd, 'ptr', rc, 'int') {
            throw OSError()
        }
        rc.ToClient(this.Gui.hWnd, true)
        SendMessage(TCM_ADJUSTRECT, false, rc, this.hWnd, this.Gui.hWnd)
        rc := Rect(X ?? rc.X, Y ?? rc.Y, (W ?? rc.W) + (X ?? rc.X), (H ?? rc.H) + (Y ?? rc.Y))
        SendMessage(TCM_ADJUSTRECT, true, rc, this.hWnd, this.Gui.hWnd)
        this.Move(rc.X, rc.Y, rc.W, rc.H)
        return rc
    }

    /**
     * @description - Removes an image from a tab control's image list.
     * @param {Integer} Index - The index of the image to remove.
     */
    RemoveImage(Index) {
        SendMessage(TCM_REMOVEIMAGE, Index, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Sets the focus to a specified tab in a tab control.
     * @param {Integer} Index - The index of the tab to focus. The index is 1-based.
     */
    SetCurFocus(Index) {
        SendMessage(TCM_SETCURFOCUS, Index - 1, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Selects a tab in a tab control.
     * @param {Integer} Index - The index of the tab to select. The index is 1-based.
     */
    SetCurSel(Index) {
        SendMessage(TCM_SETCURSEL, Index - 1, 0, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @param {Integer} Style - One of the following:
     * - 1: TCS_EX_FLATSEPARATORS
     * - 2: TCS_EX_REGISTERDROP
     * @param {Integer} Value - Either 1 or 0 to enable or clear the style, respectively.
     */
    SetExtendedStyle(Style, Value) {
        return SendMessage(TCM_SETEXTENDEDSTYLE, Style, Value, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Assigns an image list to a tab control.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tcm-setimagelist}
     * @param {Integer} Index - The index of the image to remove.
     * @returns {Integer} - Returns the handle to the previous image list, or NULL if there is no
     * previous image list.
     */
    SetImageList(Handle) {
        SendMessage(TCM_SETIMAGELIST, 0, Handle, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - Sets the width and height of tabs in a fixed-width or owner-drawn tab control.
     * @param {Integer} Width - The width in pixels.
     * @param {Integer} Height - The height in pixels.
     * @param {VarRef} [OutOldWidth] - A variable that will receive the previous width in pixels
     * @param {VarRef} [OutOldHeight] - A variable that will receive the previous height in pixels
     */
    SetItemSize(Width, Height, &OutOldWidth?, &OutOldHeight?) {
        old := SendMessage(TCM_SETITEMSIZE, 0, (Height & 0xFFFF) << 16 | (Width & 0xFFFF), this.hWnd, this.Gui.hWnd)
        OutOldWidth := old & 0xFFFF
        OutOldHeight := (old >> 16)
    }

    /**
     * @description - Sets the minimum tab width.
     * @param {Integer} Width - The minimum tab width in pixels.
     * @returns {Integer} - The previous minimum tab width.
     */
    SetMinTabWidth(Width) {
        return SendMessage(TCM_SETMINTABWIDTH, 0, Width, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @param {Integer} Index - The index of the tab which will have its text changed. The index is 1-based.
     * @param {String} NewText - The new text.
     * @returns {Integer} - 1 if successful, 0 otherwise.
     */
    SetTabText(Index, NewText) {
        tcitem := TabEx_TcItem(TCIF_TEXT, , , NewText)
        return SendMessage(TCM_SETITEMW, Index - 1, tcitem.Ptr, this.hWnd, this.Gui.hWnd)
    }

    /**
     * @description - The input is a window rectangle, and the output is the display rectangle
     * area for a tab control with the input dimensions.
     * @param {Rect} rc - The window rectangle. If unset, the control's current dimensions
     * are used.
     * @returns {Rect} - The display rectangle (same object with new values)
     */
    WindowToDisplay(rc) {
        SendMessage(TCM_ADJUSTRECT, false, rc, this.hWnd, this.Gui.hWnd)
        return rc
    }

    /**
     * Enables the usage of the "_S" suffix.
     *
     * When calling a method, you can add "_S" or "_S<n>" (where <n> is an integer representing a
     * dpi awareness context constant 1, 2, 3 or 4) to set the dpi awareness context to that value
     * (multiplied by -1) prior to calling the method.
     */
    __Call(Name, Params) {
        Split := StrSplit(Name, '_')
        if Split.Length == 2 && this.HasMethod(Split[1]) && SubStr(Split[2], 1, 1) = 'S' {
            if StrLen(Split[2]) == 2 {
                DllCall('SetThreadDpiAwarenessContext', 'ptr', -SubStr(Split[2], 2, 1), 'ptr')
            } else {
                DllCall('SetThreadDpiAwarenessContext', 'ptr', this.DpiAwarenessContext, 'ptr')
            }
            if Params.Length {
                return this.%Split[1]%(Params*)
            } else {
                return this.%Split[1]%()
            }
        } else {
            throw PropertyError('Property not found.', -1, Name)
        }
    }
}

class TreeViewEx_Tab {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.NodeConstructor := proto.DefaultPropsInfoTreeOptions := proto.DefaultUIATreeOptions :=
        proto.PropsInfoTreeContextMenu := proto.UIATreeContextMenu := proto.PropsInfoTree_NodeConstructor :=
        proto.ContextMenu := proto.DefaultAddOptions := proto.DefaultTreeViewExOptions :=
        proto.UIATree_NodeConstructor :=
        ''
        this.Collection := TreeViewExTabCollection()
    }
    static Add(TreeViewExTabObj) {
        if !this.Collection.Has(TreeViewExTabObj.Id) {
            this.Collection.Set(TreeViewExTabObj.Id, TreeViewExTabObj)
        }
    }
    static Delete(Id) {
        this.Collection.Delete(Number(Id))
    }
    static Get(Id) {
        return this.Collection.Get(Number(Id))
    }
    static GetUid() {
        loop 100 {
            n := Random(1, 2 ** 32 - 1)
            if !this.Collection.Has(n) {
                return n
            }
        }
        throw Error('Failed to generate a unique id.')
    }
    /**
     * Creates a new {@link TreeViewEx_Tab} object. The purpose of {@link TreeViewEx_Tab} is to
     * create a tab control that's primary purpose is for displaying multiple {@link TreeViewEx}
     * controls.
     *
     * @param {Gui} GuiObj - The `Gui` on which to add the tab.
     *
     * @param {Object} [Options] - An object with zero or more options as property : value pairs.
     *
     * @param {*} [Options.CallbackAdd] - If set, a `Func` or callable object that is called for every
     * new {@link TreeViewEx} control. The function can have up to two parameters:
     * 1. The new {@link TreeViewEx} control.
     * 2. The {@link TreeViewEx_Tab} object.
     *
     * The return value is ignored.
     *
     * @param {*} [Options.CallbackDelete] - If set, a `Func` or callable object that is called for
     * every {@link TreeViewEx} control associated with a tab when the tab is deleted.
     *
     * The function can have up to two parameters:
     * 1. {TreeViewEx_Tab.Item} - The new {@link TreeViewEx_Tab.Item} object. Retrieve the control object
     *   from property {@link TreeViewEx_Tab.Item#tvex}.
     * 2. {Boolean} - If the tab being deleted is the currently active tab, this parameter is set with
     *   `1`. Else, this parameter is set with `0`.
     * 3. {Boolean} - If the tab being deleted is the last tab in tab control's internal collection,
     *   this parameter is set with `1`. Else, this parameter is set with `0`.
     * 4. {TreeViewEx_Tab} - The {@link TreeViewEx_Tab} object.
     *
     * The return value is ignored.
     *
     * When `Options.CallbackDelete` is set, the method {@link TreeViewEx_Tab.Prototype.DeleteTab}
     * does **not** call {@link TreeViewEx.Prototype.Dispose}. This is to permit your function the
     * choice whether or not to destroy the control.
     *
     * When `Options.CallbackDelete` is not set, the method does call {@link TreeViewEx.Prototype.Dispose}.
     *
     * @param {*} [Options.CallbackOnChangeBefore] - If set, a `Func` or callable object that is called
     * every time the tab changes. The function can have up to three parameters:
     * 1. The {@link TreeViewEx_Tab} object.
     * 2. An array of the previously active {@link TreeViewEx} controls.
     * 3. An array of the newly active {@link TreeViewEx} controls.
     *
     * The return value is ignored.
     *
     * The function is called before any the previously active controls are disabled.
     *
     * @param {*} [Options.CallbackOnChangeAfter] - If set, a `Func` or callable object that is called
     * every time the tab changes. The function can have up to three parameters:
     * 1. The {@link TreeViewEx_Tab} object.
     * 2. An array of the previously active {@link TreeViewEx} controls.
     * 3. An array of the newly active {@link TreeViewEx} controls.
     *
     * The return value is ignored.
     *
     * The function is called after the previously active controls are disabled, the newly active controls
     * are enabled and the newly active controls are resized.
     *
     * @param {Boolean} [Options.CaseSense = false] - If true, any operations using the `TvexName`
     * value (first parameter of {@link TreeViewEx_Tab.Prototype.Add}) are performed using case
     * sensitivity. If false, they are performed without case sensitivity.
     *
     * @param {Boolean|MenuEx} [Options.ContextMenu = true] - If true, sets property
     * {@link TreeViewEx_Tab#ContextMenu} with an instance of {@link TreeViewEx_ContextMenu}. This
     * requires that file src\TreeViewEx_ContextMenu.ahk is included in the script, and requires
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-MenuEx MenuEx}.
     *
     * Your code can also set `Options.ContextMenu` with an object that inherits from {@link MenuEx}
     * See the demo file test\demo-context-menu.ahk for an example context menu. The context
     * menu can be added to new {@link TreeViewEx} controls.
     *
     * Also see option {@link TreeViewEx_Tab.Prototype.Add~AddOptions.SetContextMenu} which is `true`
     * by default.
     *
     * @param {Object} [Options.DefaultPropsInfoTreeOptions] - An object with zero or more
     * options as property : value pairs. The options are for
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-PropsInfoTree PropsInfoTree}. For more
     * information see {@link PropsInfoTree.Prototype.__New} and
     * {@link TreeViewEx_Tab.Prototype.SetDefaultPropsInfoTreeOptions}.
     *
     * @param {Object} [Options.DefaultUIATreeOptions] - An object with zero or more
     * options as property : value pairs. The options are for
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-UIATree UIATree}. For more
     * information see {@link UIATree.Prototype.__New} and
     * {@link TreeViewEx_Tab.Prototype.SetDefaultUIATreeOptions}.
     *
     * @param {String} [Options.Name] - If set, the name assigned to the tab control.
     *
     * @param {Class} [Options.NodeClass] - If set, the node class that will be passed to
     * {@link TreeViewEx.Prototype.SetNodeConstructor}. By providing the node class with this option,
     * this enables the ability to make changes that effect all node objects associated with all
     * {@link TreeViewEx} objects associated with this {@link TreeViewEx_Tab}. This is done
     * through the {@link TreeViewEx_Tab#NodeConstructor} property, which is an instance of
     * {@link TreeViewEx_NodeConstructor}. You can use the {@link TreeViewEx_NodeConstructor}
     * instance methods to make changes to the prototype object from which all nodes associated
     * with this {@link TreeViewEx_Tab} inherit. These changes would not be seen on other node
     * objects or other {@link TreeViewEx} objects which are NOT associated with this {@link TreeViewEx_Tab}.
     *
     * Also see {@link TreeViewEx_Tab.Prototype.Add~AddOptions.SetNodeConstructor} which is `true`
     * by default.
     *
     * @param {String} [Options.Opt = "w100 h100"] - The options to pass to the first parameter
     * of {@link https://www.autohotkey.com/docs/v2/lib/Gui.htm#Add Gui.Prototype.Add} when creating
     * the tab control.
     *
     * @param {Boolean|MenuEx} [Options.PropsInfoTreeContextMenu = true] - If true, sets property
     * {@link TreeViewEx_Tab#PropsInfoTreeContextMenu} with an instance of
     * {@link PropsInfoTree_ContextMenu}. This is only relevant if you are using
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-PropsInfoTree PropsInfoTree}. When a
     * {@link PropsInfoTree} instance is created by calling {@link TreeViewEx_Tab.Prototype.Add}, the
     * value {@link TreeViewEx_Tab#PropsInfoTreeContextMenu} is set to option
     * `PropsInfoTreeOptions.ContextMenu`.
     *
     * Your code can also set `Options.PropsInfoTreeContextMenu` with an object that inherits from
     * {@link MenuEx} to use that instead of {@link PropsInfoTree_ContextMenu}.
     *
     * @param {Boolean} [Options.SetPropsInfoTreeNodeConstructor = true] - If true, and if the
     * class {@link PropsInfoTree} exists, calls
     * {@link TreeViewEx_Tab.Prototype.SetPropsInfoTreeNodeConstructor} which defines
     * {@link TreeViewEx_Tab#PropsInfoTreeCollection_NodeConstructor} which is a collection of
     * {@link TreeViewEx_NodeConstructor} objects used by {@link PropsInfoTree} to construct
     * the various node objects. This enables the ability to make changes that are seen across
     * each of the {@link PropsInfoTree_Node} objects associated with this {@link TreeViewEx_Tab}
     * object. See the section "TreeViewEx_Tab" in README.md for more information.
     *
     * @param {Boolean} [Options.SetUIATreeNodeConstructor = true] - If true, and if the
     * class {@link UIATree} exists, calls
     * {@link TreeViewEx_Tab.Prototype.SetUIATreeNodeConstructor} which sets
     * {@link TreeViewEx_Tab#UIATree_NodeConstructor} with a {@link TreeViewEx_NodeConstructor}
     * object. When a {@link UIATree} instance is created by calling
     * {@link TreeViewEx_Tab.Prototype.Add}, the value {@link TreeViewEx_Tab#UIATree_NodeConstructor}
     * is assigned to option `UIATreeOptions.NodeClass`. This enables the ability to make changes that
     * are seen across each of the {@link UIATree_Node} objects associated with this
     * {@link TreeViewEx_Tab} object. See the section "TreeViewEx_Tab" in README.md for more information.
     *
     * @param {String[]} [Options.Tabs] - If set, an array of strings to pass to the third parameter
     * of {@link https://www.autohotkey.com/docs/v2/lib/Gui.htm#Add Gui.Prototype.Add} when creating
     * the tab control.
     *
     * @param {Boolean|MenuEx} [Options.UIATreeContextMenu = true] - If true, sets property
     * {@link TreeViewEx_Tab#UIATreeContextMenu} with an instance of
     * {@link UIATree_ContextMenu}. This is only relevant if you are using
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-UIATree UIATree}. When a {@link UIATree}
     * instance is created by calling {@link TreeViewEx_Tab.Prototype.Add}, the value
     * {@link TreeViewEx_Tab#UIATreeContextMenu} is set to option `UIATreeOptions.ContextMenu`.
     *
     * Your code can also set `Options.UIATreeContextMenu` with an object that inherits from
     * {@link MenuEx} to use that instead of {@link UIATree_ContextMenu}.
     *
     * @param {String} [Options.Which = "Tab3"] - One of
     * {@link https://www.autohotkey.com/docs/v2/lib/GuiControls.htm#Tab_vs "Tab", "Tab2", or "Tab3"}.
     *
     * @param {Object} [DefaultAddOptions] - Options to use as the defaults when calling
     * {@link TreeViewEx_Tab.Prototype.Add}. See the parameter hint for
     * {@link TreeViewEx_Tab.Prototype.Add} for information about the options.
     *
     * @param {Object} [DefaultTreeViewExOptions] - An object with zero or more options as
     * property : value pairs. See the parameter hint for {@link TreeViewEx.Prototype.__New} for
     * information about the options.
     */
    __New(GuiObj, Options?, DefaultAddOptions := '', DefaultTreeViewExOptions := '') {
        this.Id := TreeViewEx_Tab.GetUid()
        TreeViewEx_Tab.Add(this)
        options := TreeViewEx_Tab.Options(Options ?? unset)
        this.Tab := TabEx(GuiObj, options.Which, options.Opt, options.Tabs || unset)
        this.HwndGui := GuiObj.Hwnd
        this.Collection := Container.CbString(TreeViewEx_Tab_CallbackValue_Name, , options.CaseSense ? 0 : LINGUISTIC_IGNORECASE)
        this.DefaultAddOptions := TreeViewEx_Tab.AddOptions(DefaultAddOptions)
        this.DefaultTreeViewExOptions := DefaultTreeViewExOptions
        this.Tab.TvexTab := this
        ObjRelease(ObjPtr(this))
        this.Tab.OnEvent('Change', TreeViewEx_Tab_OnChange)
        this.Tab.UseTab()
        this.ActiveControls := []
        this.CallbackAdd := options.CallbackAdd
        this.CallbackOnChangeBefore := options.CallbackOnChangeBefore
        this.CallbackOnChangeAfter := options.CallbackOnChangeAfter
        this.CallbackDelete := options.CallbackDelete
        if IsObject(options.ContextMenu) {
            this.ContextMenu := options.ContextMenu
        } else if options.ContextMenu && IsSet(TreeViewEx_ContextMenu) {
            this.ContextMenu := TreeViewEx_ContextMenu()
        }
        if options.Name {
            this.Tab.Name := options.Name
        }
        if options.NodeClass {
            this.SetNodeConstructor(options.NodeClass)
        }
        if IsSet(PropsInfoTree) {
            if options.PropsInfoTreeContextMenu {
                this.SetPropsInfoTreeContextMenu(IsObject(options.PropsInfoTreeContextMenu) ? options.PropsInfoTreeContextMenu : unset)
            }
            if options.DefaultPropsInfoTreeOptions {
                this.SetDefaultPropsInfoTreeOptions(options.DefaultPropsInfoTreeOptions, options.SetPropsInfoTreeNodeConstructor)
            } else if options.SetPropsInfoTreeNodeConstructor {
                this.SetDefaultPropsInfoTreeOptions()
            }
        }
        if IsSet(UIATree) {
            if options.UIATreeContextMenu {
                this.SetUIATreeContextMenu(IsObject(options.UIATreeContextMenu) ? options.UIATreeContextMenu : unset)
            }
            if options.DefaultUIATreeOptions {
                this.SetDefaultUIATreeOptions(options.DefaultUIATreeOptions,  options.SetUIATreeNodeConstructor)
            } else if options.SetUIATreeNodeConstructor {
                this.SetDefaultUIATreeOptions()
            }
        }
    }
    /**
     * Adds a {@link TreeViewEx} control to the gui, optionally creating a new tab. This returns
     * a {@link TreeViewEx_Tab.Item} object.
     *
     * If both `Options.CreateTab` and `Options.UseTab` are false, the currently active tab is used.
     * If there are no tabs, an error is thrown.
     *
     * @param {String} TvexName - The name to assign to the control.
     *
     * @param {Object} [AddOptions] - An object with zero or more options as property : value pairs.
     * The options passed to the {@link TreeViewEx_Tab.Prototype.__New~DefaultAddOptions DefaultAddOptions}
     * parameter of {@link TreeViewEx_Tab.Prototype.__New} are used as the base, and these `AddOptions`
     * supersede those.
     *
     * @param {Boolean} [AddOptions.Autosize = true] - If true, whenever the {@link TreeViewEx} control
     * is enabled, its dimensions are adjusted to maintain its position relative to the tab's borders.
     * For example, If another row of tabs is added / removed, the {@link TreeViewEx} control's height
     * is adjusted accordingly. If false, no resizing occurs. This option can be changed by calling
     * {@link TreeViewEx_Tab.Item.Prototype.SetAutosize}.
     *
     * @param {Boolean} [AddOptions.CopyActiveFont = true] - If true, whenever a control is added
     * using {@link TreeViewEx_Tab.Prototype.Add}, the font object from the first control in the arraay
     * {@link TreeViewEx_Tab#ActiveControls} is cloned and applied to the new control. This option
     * has no effect when the first control is added and when {@link TreeViewEx_Tab#ActiveControls}
     * is empty.
     *
     * @param {Integer|String} [AddOptions.CreateTab = true] - If a numeric 1, a new tab is created
     * using `TvexName` as the name. If a string, a new tab is created using `AddOptions.CreateTab`
     * as the name. If false, a new tab is not created.
     *
     * @param {Boolean} [AddOptions.FitTab = true] - If true, fits the {@link TreeViewEx} control
     * evenly in the center of the tab's client area with padding separating the {@link TreeViewEx}
     * control's edge with the tab's edge. The size of the padding is determined by the "MarginX"
     * and "MarginY" properties of the `Gui` object.
     *
     * @param {Boolean} [AddOptions.SetContextMenu = true] - If true, and if a value is set to
     * {@link TreeViewEx_Tab#ContextMenu} (usually by including it with
     * {@link TreeViewEx_Tab.Prototype.__New~Options.ContextMenu}), this calls
     * {@link TreeViewEx.Prototype.SetContextMenu}
     * passing {@link TreeViewEx_Tab#ContextMenu} as the argument. If false or if
     * {@link TreeViewEx_Tab#ContextMenu} is not set with a value, this does not occur.
     *
     * @param {Boolean} [AddOptions.SetNodeConstructor = true] - If true, and if a value is set to
     * {@link TreeViewEx_Tab#NodeConstructor} (usually by including it with
     * {@link TreeViewEx_Tab.Prototype.__New~Options.NodeClass}), this calls
     * {@link TreeViewEx.Prototype.SetNodeConstructor}
     * passing {@link TreeViewEx_Tab#NodeConstructor} as the argument. If false or if
     * {@link TreeViewEx_Tab#NodeConstructor} is not set with a value, this does not occur.
     *
     * @param {Integer|String} [AddOptions.UseTab] - If set, and if `AddOptions.CreateTab` is not in use,
     * the {@link TreeViewEx} control is associated with `AddOptions.UseTab`. `AddOptions.UseTab`
     * can be the tab index as a 1-based integer, or it can be the name of the tab. If
     * `AddOptions.CreateTab` is used, `AddOptions.UseTab` is ignored.
     *
     * @param {Boolean} [AddOptions.UseTabCaseSense = true] - If true, and if `AddOptions.UseTab`
     * is set with a string, case sensitivity is used when using the tab name to get the tab index.
     * If false, case sensitivity is not used. If `AddOptions.UseTab` is not set,
     * `AddOptions.UseTabCaseSense` is ignored.
     *
     * @param {Object} [TreeViewExOptions] - An object with zero or more options as
     * property : value pairs. See the parameter hint for {@link TreeViewEx.Prototype.__New} for
     * information about the options. The options passed to the
     * {@link TreeViewEx_Tab.Prototype.__New~DefaultTreeViewExOptions DefaultTreeViewExOptions}
     * parameter of {@link TreeViewEx_Tab.Prototype.__New} are used as the base, and these
     * `TreeViewExOptions` supersede those.
     *
     * @param {*} [ConstructorParams] - Any additional parameters to pass to the tree-view object's
     * constructor.
     * - If `AddOptions.TreeViewClass` is {@link TreeViewEx}, `ConstructorParams` is ignored.
     * - If `AddOptions.TreeViewClass` is {@link PropsInfoTree}, `ConstructorParams` is assumed
     *   to be the value to pass to the parameter `PropsInfoTreeParams`. If
     *   {@link TreeViewEx_Tab.Prototype.SetDefaultPropsInfoTreeOptions} has been called, the base
     *   of `ConstructorParams` is set to {@link TreeViewEx_Tab#DefaultPropsInfoTreeOptions} before calling
     *   {@link PropsInfoTree.Prototype.__New}.
     * - If `AddOptions.TreeViewClass` is {@link UIATree}, `ConstructorParams` is assumed
     *   to be the value to pass to the parameter `UIATreeParams`. If
     *   {@link TreeViewEx_Tab.Prototype.SetDefaultUIATreeOptions} has been called, the base
     *   of `ConstructorParams` is set to {@link TreeViewEx_Tab#DefaultUIATreeOptions} before calling
     *   {@link UIATree.Prototype.__New}.
     * - If `AddOptions.TreeViewClass` is another class, and if `ConstructorParams` is an array,
     *   and if `AddOptions.TreeViewClass.Prototype.__New.MaxParams > 4`,
     *   the variadic operator ( * ) will be applied to the value when calling the constructor.
     *   In other cases, the value is passed as-is.
     *
     * @returns {TreeViewEx_Tab.Item} - The {@link TreeViewEx_Tab.Item} object. The control is on
     * property {@link TreeViewEx_Tab.Item#tvex}.
     */
    Add(TvexName, AddOptions?, TreeViewExOptions?, ConstructorParams?) {
        tvexOptions := { Name: TvexName }
        if IsSet(TreeViewExOptions) {
            if this.DefaultTreeViewExOptions {
                ObjSetBase(TreeViewExOptions, this.DefaultTreeViewExOptions)
            }
            ObjSetBase(tvexOptions, TreeViewExOptions)
        } else if this.DefaultTreeViewExOptions {
            ObjSetBase(tvexOptions, this.DefaultTreeViewExOptions)
        }
        if HasProp(tvexOptions, 'Style') {
            if tvexOptions.Style & WS_CLIPSIBLINGS {
                throw ValueError('The TreeViewEx options cannot have the WS_CLIPSIBLINGS style flag.')
            }
        } else {
            tvexOptions.Style := TreeViewEx.Options.Default.Style & ~WS_CLIPSIBLINGS
        }
        if IsSet(AddOptions) {
            if this.DefaultAddOptions {
                ObjSetBase(AddOptions, this.DefaultAddOptions)
            } else {
                addOptions := TreeViewEx_Tab.AddOptions(AddOptions)
            }
        } else if this.DefaultAddOptions {
            addOptions := this.DefaultAddOptions
        } else {
            addOptions := TreeViewEx_Tab.AddOptions()
        }
        tab := this.Tab
        if addOptions.CreateTab {
            tab.Add([addOptions.CreateTab == 1 ? TvexName : addOptions.CreateTab])
            tabValue := tab.GetItemCount()
        } else if addOptions.UseTab {
            if addOptions.UseTab is Integer {
                tabValue := addOptions.UseTab
            } else {
                tabValue := tab.FindTab(addOptions.UseTab, , , addOptions.UseTabCaseSense)
                if !tabValue {
                    throw ValueError('Tab not found.', , addOptions.UseTab)
                }
            }
        } else if tab.Value {
            tabValue := tab.Value
        } else {
            throw Error('Unable to create the TreeViewEx control because no tabs currently exist.')
        }
        ; If the new control will be added to the active tab
        if tabValue = tab.Value {
            if tvexOptions.Style & WS_DISABLED {
                tvexOptions.Style := tvexOptions.Style & ~WS_DISABLED
            }
            if !(tvexOptions.Style & WS_VISIBLE) {
                tvexOptions.Style := tvexOptions.Style | WS_VISIBLE
            }
        } else {
            if !(tvexOptions.Style & WS_DISABLED) {
                tvexOptions.Style := tvexOptions.Style | WS_DISABLED
            }
            if tvexOptions.Style & WS_VISIBLE {
                tvexOptions.Style := tvexOptions.Style & ~WS_VISIBLE
            }
        }
        g := this.Gui
        if addOptions.FitTab {
            rc := tab.GetClientDisplayRect()
            tvexOptions.Width := rc.W - g.MarginX * 2
            tvexOptions.Height := rc.H - g.MarginY * 2
            tvexOptions.X := rc.L + g.MarginX
            tvexOptions.Y := rc.T + g.MarginY
        }
        cls := addOptions.TreeViewClass
        switch cls.Prototype.__Class, 0 {
            case 'PropsInfoTree':
                if !IsSet(ConstructorParams) {
                    ConstructorParams := {}
                }
                if this.DefaultPropsInfoTreeOptions {
                    ObjSetBase(ConstructorParams, this.DefaultPropsInfoTreeOptions)
                }
                if this.PropsInfoTreeContextMenu {
                    ConstructorParams.ContextMenu := this.PropsInfoTreeContextMenu
                }
                tvex := cls(g, tvexOptions, ConstructorParams)
            case 'TreeViewEx':
                tvex := cls(g, tvexOptions)
                if addOptions.SetContextMenu && this.ContextMenu {
                    tvex.SetContextMenu(this.ContextMenu)
                }
                if addOptions.SetNodeConstructor && IsObject(this.NodeConstructor) {
                    tvex.SetNodeConstructor(this.NodeConstructor)
                }
            case 'UIATree':
                if !IsSet(ConstructorParams) {
                    ConstructorParams := {}
                }
                if this.DefaultUIATreeOptions {
                    ObjSetBase(ConstructorParams, this.DefaultUIATreeOptions)
                }
                if this.UIATreeContextMenu {
                    ConstructorParams.ContextMenu := this.UIATreeContextMenu
                }
                tvex := cls(g, tvexOptions, ConstructorParams)

                if this.DefaultUIATreeOptions {
                    if !IsSet(ConstructorParams) {
                        ConstructorParams := {}
                    }
                    ObjSetBase(ConstructorParams, this.DefaultUIATreeOptions)
                }
                tvex := cls(g, tvexOptions, ConstructorParams ?? unset)
            default:
                if IsSet(ConstructorParams) {
                    if ConstructorParams is Array && cls.Prototype.__New.MaxParams > 4 {
                        tvex := cls(g, tvexOptions, ConstructorParams*)
                    } else {
                        tvex := cls(g, tvexOptions, ConstructorParams)
                    }
                } else {
                    tvex := cls(g, tvexOptions)
                }
        }
        item := TreeViewEx_Tab.Item(tvex, tab, tabValue, addOptions.Autosize)
        item.tvex.SetTvexTabId(this.Id)
        if this.ActiveControls.Length && addOptions.CopyActiveFont {
            lfNew := item.tvex.GetFont()
            this.ActiveControls[1].tvex.GetFont().Clone(lfNew, , false)
            lfNew.Apply()
        }
        if tabValue = tab.Value {
            this.ActiveControls.Push(item)
            if !DllCall(
                g_user32_SetWindowPos
              , 'ptr', tvex.Hwnd
              , 'ptr', tab.Hwnd
              , 'int', 0, 'int', 0, 'int', 0, 'int', 0
              , 'uint', SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE
              , 'int'
            ) {
                throw OSError()
            }
            tvex.Redraw()
        } else {
            item.Disable()
        }
        this.Collection.Insert(item)
        if IsObject(this.CallbackAdd) {
            this.CallbackAdd.Call(tvex, this)
        }
        return item
    }
    /**
     * Deletes a tab and any {@link TreeViewEx} controls associated with it.
     * @param {Integer|String} Value - Either the string name of the tab, or the integer tab index
     * (1-based) of the tab.
     * @param {Boolean} [ValueIsName = true] - If true, `Value` is the name. If false, `Value` is
     * the index.
     * @param {Boolean} [CaseSense = true] - If true, and if `ValueIsName` is true, case sensitivity
     * is used when using the name to get the tab index. If false, case sensitivity is not used.
     * If `ValueIsName` is false, `CaseSense` is ignored.
     */
    DeleteTab(Value, ValueIsName := true, CaseSense := true) {
        tab := this.Tab
        if ValueIsName {
            tabValue := tab.FindTab(Value, , , CaseSense)
        } else {
            tabValue := Value
        }
        if !tabValue {
            throw ValueError('Tab not found.')
        }
        flag_isLastTab := tabValue = tab.GetItemCount()
        flag_isCurrentTab := tabValue = tab.Value
        collection := this.Collection
        list := []
        i := 0
        if callbackDelete := this.CallbackDelete {
            loop collection.Length {
                item := collection[++i]
                if tabValue = item.tabValue {
                    list.Push(item)
                    collection.RemoveAt(i--)
                    callbackDelete(item, flag_isCurrentTab, flag_isLastTab, this)
                } else if item.tabValue > tabValue {
                    item.tabValue--
                }
            }
        } else {
            loop collection.Length {
                item := collection[++i]
                if tabValue = item.tabValue {
                    list.Push(item)
                    collection.RemoveAt(i--)
                    item.tvex.Dispose()
                } else if item.tabValue > tabValue {
                    item.tabValue--
                }
            }
        }
        tab.Delete(tabValue)
        if flag_isCurrentTab {
            this.ActiveControls.Length := 0
            if flag_isLastTab {
                if tab.GetItemCount() {
                    tab.Value := tabValue - 1
                }
            } else {
                tab.Value := tabValue
            }
        }
        TreeViewEx_Tab_OnChange(tab)
        return list
    }
    /**
     * Deletes a {@link TreeViewEx} control but does not delete the tab it is associated with.
     * @param {String} TvexName - The name of the control.
     * @returns {TreeViewEx_Tab.Item} - The deleted item. The control is on property
     * {@link TreeViewEx_Tab.Item#tvex}.
     */
    DeleteTreeViewEx(TvexName) {
        this.Collection.Remove(TvexName, &item)
        item.tvex.Dispose()
        if item.tabValue = this.Tab.Value {
            active := this.ActiveControls
            if active.Length == 1 {
                item := active[1]
                active.Length := 0
                return item
            } else {
                for _item in active {
                    if item == _item {
                        active.RemoveAt(A_Index)
                        return item
                    }
                }
            }
        }
    }
    Dispose() {
        TreeViewEx_Tab.Delete(this.Id)
        props := []
        props.Capacity := ObjOwnPropCount(this)
        for prop in this.OwnProps() {
            props.Push(prop)
        }
        for prop in props {
            this.DeleteProp(prop)
        }
    }
    /**
     * Gets a {@link TreeViewEx_Tab.Item} object using the name.
     * @param {String} Name - The name associated with the item.
     * @returns {TreeViewEx_Tab.Item}
     */
    Get(Name) => this.Collection.GetValue(Name)
    /**
     * Returns the array index of the item if an item associated with the name exists in the
     * collection. Else, returns 0.
     * @param {String} Name - The name associated with the item.
     * @returns {Integer}
     */
    Has(Name) => this.Collection.Find(Name)
    /**
     * {@link TreeViewEx_Tab} has built-in support for
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-PropsInfoTree}. {@link PropsInfoTree} has its
     * own set of options. By calling {@link TreeViewEx_Tab.Prototype.SetDefaultPropsInfoTreeOptions},
     * you define an options object that will be used for all instances of {@link PropsInfoTree}
     * associated with this {@link TreeViewEx_Tab} object.
     *
     * The object is set to property {@link TreeViewEx_Tab#PropsInfoTreeOptions}. You can change the
     * values of that object and the change will be seen by all instances of
     * {@link PropsInfoTree} associated with this {@link TreeViewEx_Tab} object unless an individual
     * instance overrides the option with a value on its own options object. You can access the
     * individual options objects from the {@link PropsInfoTree#PropsInfoTreeOptions} property.
     *
     * If parameter `PrepareNodeConstructor` is true, this function will do the following:
     * - Call {@link TreeViewEx_Tab.Prototype.SetPropsInfoTreeNodeConstructor}.
     * - Set `PropsInfoTreeOptions.CallbackSetNodeConstructor` with
     * {@link TreeViewEx_Tab_Pit_CallbackSetNodeConstructor}, binding the collection to the first parameter.
     * - Set `PropsInfoTreeOptions.NodeClass` with {@link TreeViewEx_Tab#PropsInfoTree_NodeConstructor}.
     *
     * This makes it possible to make changes to all node objects of a specific type associated with
     * this {@link TreeViewEx_Tab}. For example, to change the text that is displayed for tree-view
     * items associated with {@link PropsInfoTree_Node_Object} nodes:
     * @example
     * tvexTab := TreeViewEx_Tab()
     * tvexTab.SetDefaultPropsInfoTreeOptions()
     * constructor := tvexTab.PropsInfoTreeCollection_NodeConstructor.Get('Object')
     * prototype := constructor.Prototype
     * MyCustomLabelFunc(Node) {
     *     ; custom logic
     * }
     * prototype.DefineProp('Label', { Get: MyCustomLabelFunc })
     * @
     *
     * @param {Object} [PropsInfoTreeOptions] - The default options to pass to
     * {@link PropsInfoTree.Prototype.__New~PropsInfoTreeOptions}.
     *
     * @param {Boolean} [PrepareNodeConstructor = true] - If true, prepares the options
     * `PropsInfoTreeOptions.CallbackSetNodeConstructor` and `PropsInfoTreeOptions.NodeClass` as
     * described in the description of this method. `PrepareNodeConstructor` should be left true
     * to make it possible to make changes to the node objects' collective behavior.
     */
    SetDefaultPropsInfoTreeOptions(PropsInfoTreeOptions?, PrepareNodeConstructor := true) {
        if PrepareNodeConstructor {
            if !IsSet(PropsInfoTreeOptions) {
                PropsInfoTreeOptions := {}
            }
            this.SetPropsInfoTreeNodeConstructor(HasProp(PropsInfoTreeOptions, 'NodeClass') ? PropsInfoTreeOptions.NodeClass : unset)
            PropsInfoTreeOptions.CallbackSetNodeConstructor := TreeViewEx_Tab_Pit_CallbackSetNodeConstructor.Bind(this.PropsInfoTreeCollection_NodeConstructor)
            PropsInfoTreeOptions.NodeClass := this.PropsInfoTree_NodeConstructor
        }
        this.DefaultPropsInfoTreeOptions := PropsInfoTreeOptions ?? {}
    }
    /**
     * {@link TreeViewEx_Tab} has built-in support for
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-UIATree}. {@link UIATree} has its own
     * set of options. By calling {@link TreeViewEx_Tab.Prototype.SetDefaultUIATreeOptions}, you
     * define an options object that will be used for all instances of {@link UIATree} associated
     * with this {@link TreeViewEx_Tab} object.
     *
     * The object is set to property {@link TreeViewEx_Tab#UIATreeOptions}. You can change the
     * values of that object and the change will be seen by all instances of
     * {@link UIATree} associated with this {@link TreeViewEx_Tab} object unless an individual
     * instance overrides the option with a value on its own options object. You can access the
     * individual options objects from the {@link UIATree#UIATreeOptions} property.
     *
     * @param {Object} [UIATreeOptions] - The default options to pass to
     * {@link UIATree.Prototype.__New~UIATreeOptions}.
     *
     * @param {Boolean} [PrepareNodeConstructor = true] - If true, prepares the options
     * `UIATreeOptions.NodeClass` as described in the description of this method.
     * `PrepareNodeConstructor` should be left true to make it possible to make changes to the node
     * objects' collective behavior.
     */
    SetDefaultUIATreeOptions(UIATreeOptions?, PrepareNodeConstructor := true) {
        if PrepareNodeConstructor {
            if !IsSet(UIATreeOptions) {
                UIATreeOptions := {}
            }
            this.SetUIATreeNodeConstructor(HasProp(UIATreeOptions, 'NodeClass') ? UIATreeOptions.NodeClass : unset)
            UIATreeOptions.NodeClass := this.UIATree_NodeConstructor
        }
        this.DefaultUIATreeOptions := UIATreeOptions ?? {}
    }
    SetNodeConstructor(NodeClass) {
        this.NodeConstructor := TreeViewEx_NodeConstructor()
        this.NodeConstructor.Prototype := { __Class: NodeClass.Prototype.__Class }
        ObjSetBase(this.NodeConstructor.Prototype, NodeClass.Prototype)
    }
    SetPropsInfoTreeNodeConstructor(NodeClass?) {
        if IsSet(PropsInfoTree_Node) && IsSet(PropsInfoTree) {
            if !IsSet(NodeClass) {
                NodeClass := PropsInfoTree_Node
            }
            /**
             * A collection of {@link TreeViewEx_NodeConstructor} objects.
             * @memberof TreeViewEx_Tab
             * @instance
             * @type {PropsInfoTreeCollection_NodeConstructor}
             */
            this.PropsInfoTreeCollection_NodeConstructor := PropsInfoTreeCollection_NodeConstructor()
            collectionNodeConstructor := this.PropsInfoTreeCollection_NodeConstructor
            /**
             * @memberof TreeViewEx_Tab
             * @instance
             * @type {TreeViewEx_NodeConstructor}
             */
            this.PropsInfoTree_NodeConstructor := TreeViewEx_NodeConstructor()
            collectionNodeConstructor.Primary := this.PropsInfoTree_NodeConstructor
            primaryProto := this.PropsInfoTree_NodeConstructor.Prototype := { __Class: NodeClass.Prototype.__Class }
            ObjSetBase(primaryProto, NodeClass.Prototype)
            inheritsFrom := Map()
            for obj in PropsInfoTree.NodeTypes {
                ; Each of these individual constructor properties can be used to make changes that affect
                ; just the relevant nodes associated with this PropsInfoTree object. These are also used
                ; to construct new node objects.
                constructor := TreeViewEx_NodeConstructor()
                collectionNodeConstructor.Set(obj.Name, constructor)
                proto := obj.Class.Prototype
                _proto := constructor.Prototype := { }
                for prop in proto.OwnProps() {
                    _proto.DefineProp(prop, proto.GetOwnPropDesc(prop))
                }
                baseName := proto.Base.__Class
                if !inheritsFrom.Has(baseName) {
                    inheritsFrom.Set(baseName, [])
                }
                inheritsFrom.Get(baseName).Push(constructor)
            }
            for baseName, list in inheritsFrom {
                if baseName = primaryProto.__Class {
                    for constructor in list {
                        ObjSetBase(constructor.Prototype, primaryProto)
                    }
                } else {
                    proto := collectionNodeConstructor.Get(SubStr(baseName, InStr(baseName, '_', , , -1) + 1)).Prototype
                    for constructor in list {
                        ObjSetBase(constructor.Prototype, proto)
                    }
                }
            }
        } else {
            throw Error('PropsInfoTree.ahk must be included in the script to use this method.')
        }
    }
    SetPropsInfoTreeContextMenu(MenuExObj?) {
        if IsSet(MenuExObj) {
            this.PropsInfoTreeContextMenu := MenuExObj
        } else if IsSet(PropsInfoTree_ContextMenu) {
            this.PropsInfoTreeContextMenu := PropsInfoTree_ContextMenu()
        } else {
            throw Error('PropsInfoTree_ContextMenu.ahk must be included in the script to use this method.', , A_ThisFunc)
        }
    }
    SetUIATreeNodeConstructor(NodeClass?) {
        if IsSet(UIATree_Node) {
            if !IsSet(NodeClass) {
                NodeClass := UIATree_Node
            }
            this.UIATree_NodeConstructor := TreeViewEx_NodeConstructor()
            this.UIATree_NodeConstructor.Prototype := { __Class: NodeClass.Prototype.__Class }
            ObjSetBase(this.UIATree_NodeConstructor.Prototype, NodeClass.Prototype)
        } else {
            throw Error('UIATree.ahk must be included in the script to use this method.', , A_ThisFunc)
        }
    }
    SetUIATreeContextMenu(MenuExObj?) {
        if IsSet(MenuExObj) {
            this.UIATreeContextMenu := MenuExObj
        } else if IsSet(UIATree_ContextMenu) {
            this.UIATreeContextMenu := UIATree_ContextMenu()
        } else {
            throw Error('UIATree_ContextMenu.ahk must be included in the script to use this method.', , A_ThisFunc)
        }
    }
    __Delete() {
        if this.HasOwnProp('Tab') && this.Tab.HasOwnProp('TvexTab') && this = this.Tab.TvexTab {
            ObjPtrAddRef(this)
            this.Tab.DeleteProp('TvexTab')
            this.DeleteProp('Tab')
        }
    }
    __Enum(VarCount) => this.Collection.__Enum(VarCount)

    Gui => GuiFromHwnd(this.HwndGui)
    Name => this.Tab.Name

    class AddOptions {
        static Default := {
            Autosize: true
          , CopyActiveFont: true
          , CreateTab: true
          , FitTab: true
          , SetContextMenu: true
          , SetNodeConstructor: true
          , TreeViewClass: TreeViewEx
          , UseTab: ''
          , UseTabCaseSense: true
        }
        static Call(Options?) {
            if IsSet(Options) {
                o := {}
                d := this.Default
                for prop in d.OwnProps() {
                    o.%prop% := HasProp(Options, prop) ? Options.%prop% : d.%prop%
                }
            } else {
                o := this.Default.Clone()
            }
            return o
        }
    }
    class Item {
        __New(tvex, tab, tabValue, autosize) {
            this.HwndTvex := tvex.Hwnd
            this.tabValue := tabValue
            this.HwndTab := tab.Hwnd
            this.SetAutosize(autosize)
        }
        Disable() {
            this.tvex.SetStatus(false)
        }
        Enable(rc?) {
            if !IsSet(rc) {
                rc := this.Tab.GetClientDisplayRect()
            }
            tvex := this.tvex
            if this.autosize {
                ; If autosize is true, ensure the control's position is consistent relative to the tab's borders.
                diff := this.diff
                WinMove(rc.L + diff.L, rc.T + diff.T, rc.W + diff.W, rc.H + diff.H, tvex.Hwnd)
            }
            ; Display the control
            tvex.SetStatus(true)
            if !DllCall(
                g_user32_SetWindowPos
              , 'ptr', this.HwndTvex
              , 'ptr', this.HwndTab
              , 'int', 0, 'int', 0, 'int', 0, 'int', 0
              , 'uint', SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE
              , 'int'
            ) {
                throw OSError()
            }
            tvex.Redraw()
        }
        SetAutosize(Value) {
            if this.__autosize := Value {
                tvex := this.tvex
                tvex.GetPos(&x, &y, &w, &h)
                rc := this.Tab.GetClientDisplayRect()
                this.diff := {
                    L: x - rc.L
                  , T: y - rc.T
                  , W: w - rc.W
                  , H: h - rc.H
                }
            } else {
                this.diff := ''
            }
        }
        Autosize {
            Get => this.__autosize
            Set => this.SetAutosize(Value)
        }
        Name => this.tvex.Name
        Tab => GuiCtrlFromHwnd(this.HwndTab)
        Tvex => TreeViewEx.Get(this.HwndTvex)
    }
    class Options {
        static Default := {
            CallbackAdd: ''
          , CallbackDelete: ''
          , CallbackOnChangeBefore: ''
          , CallbackOnChangeAfter: ''
          , CaseSense: false
          , ContextMenu: true
          , DefaultPropsInfoTreeOptions: ''
          , DefaultUIATreeOptions: ''
          , Name: ''
          , NodeClass: ''
          , Opt: 'w100 h100'
          , PropsInfoTreeContextMenu: true
          , SetPropsInfoTreeNodeConstructor: true
          , SetUIATreeNodeConstructor: true
          , Tabs: ''
          , UIATreeContextMenu: true
          , Which: 'Tab3'
        }
        static Call(Options?) {
            if IsSet(Options) {
                o := {}
                d := this.Default
                for prop in d.OwnProps() {
                    o.%prop% := HasProp(Options, prop) ? Options.%prop% : d.%prop%
                }
            } else {
                o := this.Default.Clone()
            }
            return o
        }
    }
}

TreeViewEx_Tab_CallbackValue_Name(item) {
    return item.tvex.name
}
TreeViewEx_Tab_OnChange(tab, *) {
    tvexTab := tab.tvexTab
    formerActive := tvexTab.ActiveControls
    tabValue := tab.Value
    ActiveControls := tvexTab.ActiveControls := []
    for item in tvexTab.Collection {
        if tabValue = item.tabValue {
            ActiveControls.Push(item)
        }
    }
    if tvexTab.CallbackOnChangeBefore {
        tvexTab.CallbackOnChangeBefore.Call(tvexTab, formerActive, ActiveControls)
    }
    for item in formerActive {
        item.Disable()
    }
    if !ActiveControls.Length {
        return
    }
    rc := tab.GetClientDisplayRect()
    g := tab.Gui
    for item in ActiveControls {
        item.Enable(rc)
    }
    if tvexTab.CallbackOnChangeAfter {
        tvexTab.CallbackOnChangeAfter.Call(tvexTab, formerActive, ActiveControls)
    }
}
TreeViewEx_Tab_Pit_CallbackSetNodeConstructor(collection, PropsInfoTreeObj, PropsInfoTreeOptions) {
    ObjSetBase(PropsInfoTreeObj.NodeConstructor.Prototype, collection.Primary.Prototype)
    for name, constructor in collection {
        _constructor := PropsInfoTreeObj.NodeConstructor_%name% := TreeViewEx_NodeConstructor()
        _constructor.Prototype := { PropsInfoTreeOptions: PropsInfoTreeOptions, HwndCtrl: PropsInfoTreeObj.Hwnd, __Class: constructor.Prototype.__Class }
        ObjSetBase(_constructor.Prototype, constructor.Prototype)
    }
}

class TreeViewExTabCollection extends Map {
    __New(items*) {
        this.CaseSense := false
        if items.Length {
            this.Set(items*)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-Container/
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * An AHK wrapper for {@link https://learn.microsoft.com/en-us/windows/win32/api/winnls/ns-winnls-nlsversioninfoex}.
 */
class NlsVersionInfoEx {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size    Type       Symbol                  OffsetPadding
        4 +       ; DWORD    dwNlsVersionInfoSize    0
        4 +       ; DWORD    dwNLSVersion            4
        4 +       ; DWORD    dwDefinedVersion        8
        4 +       ; DWORD    dwEffectiveId           12
        A_PtrSize ; GUID     guidCustomVersion       16
        proto.offset_dwNlsVersionInfoSize  := 0
        proto.offset_dwNLSVersion          := 4
        proto.offset_dwDefinedVersion      := 8
        proto.offset_dwEffectiveId         := 12
        proto.offset_guidCustomVersion     := 16
    }
    __New(dwNlsVersionInfoSize?, dwNLSVersion?, dwDefinedVersion?, dwEffectiveId?, guidCustomVersion?) {
        this.Buffer := Buffer(this.cbSizeInstance)
        if IsSet(dwNlsVersionInfoSize) {
            this.dwNlsVersionInfoSize := dwNlsVersionInfoSize
        }
        if IsSet(dwNLSVersion) {
            this.dwNLSVersion := dwNLSVersion
        }
        if IsSet(dwDefinedVersion) {
            this.dwDefinedVersion := dwDefinedVersion
        }
        if IsSet(dwEffectiveId) {
            this.dwEffectiveId := dwEffectiveId
        }
        if IsSet(guidCustomVersion) {
            this.guidCustomVersion := guidCustomVersion
        }
    }
    dwNlsVersionInfoSize {
        Get => NumGet(this.Buffer, this.offset_dwNlsVersionInfoSize, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwNlsVersionInfoSize)
        }
    }
    dwNLSVersion {
        Get => NumGet(this.Buffer, this.offset_dwNLSVersion, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwNLSVersion)
        }
    }
    dwDefinedVersion {
        Get => NumGet(this.Buffer, this.offset_dwDefinedVersion, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwDefinedVersion)
        }
    }
    dwEffectiveId {
        Get => NumGet(this.Buffer, this.offset_dwEffectiveId, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwEffectiveId)
        }
    }
    guidCustomVersion {
        Get => NumGet(this.Buffer, this.offset_guidCustomVersion, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_guidCustomVersion)
        }
    }
    Ptr => this.Buffer.Ptr
    Size => this.Buffer.Size
}

/*
    Original repository:
    Github: https://github.com/Nich-Cebolla/AutoHotkey-DateObj/blob/main/DateObj.ahk
    Author: Nich-Cebolla
    License: MIT
*/

class Container_Date {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.__Year := SubStr(A_Now, 1, 4)
        proto.__Month := '01'
        proto.__Day := '01'
        proto.__Hour := '00'
        proto.__Minute := '00'
        proto.__Second := '00'
        proto.Options := proto.Parser := ''
        proto.DefaultCentury := SubStr(A_Now, 1, 3)
        this.MonthDays := [
            31          ; 1
            ; standard, leap
          , [ 28, 29 ]  ; 2
          , 31          ; 3
          , 30          ; 4
          , 31          ; 5
          , 30          ; 6
          , 31          ; 7
          , 31          ; 8
          , 30          ; 9
          , 31          ; 10
          , 30          ; 11
          , 31          ; 12
        ]
        global CONTAINER_DATE_SECONDS_IN_YEAR := 31536000
        , CONTAINER_DATE_SECONDS_IN_LEAPYEAR := 31622400
    }

    /**
     * @description - Creates a {@link Container_Date} instance from a date string and date format string. The
     * parser is created in the process, and is available from the property `Container_DateInstance.Parser`.
     * @param {String} DateStr - The date string to parse.
     * @param {String} DateFormat - The format of the date string. The format follows the same rules as
     * described on the AHK `FormatTime` page: {@link https://www.autohotkey.com/docs/v2/lib/FormatTime.htm}.
     * - The format string can include any of the following units: 'y', 'M', 'd', 'H', 'h', 'm', 's', 't'.
     * See the link for details.
     * - Only numeric day units are recognized by this function. This function will not match with
     * days like 'Mon', 'Tuesday', etc.
     * - In addition to the units, RegEx is viable within the format string. To permit compatibility
     * between the unit characters and RegEx, please adhere to these guidelines:
     *   - If the format string contains one or more literal "y", "M", "d", "H", "h", "m", "s" or "t"
     * characters, you must escape the date format units using this escape: \t{...}
     * @example
     *  DateStr := '2024-01-28 19:15'
     *  DateFormat := 'yyyy-MM-dd HH:mm'
     *  Date := Container_Date(DateStr, DateFormat)
     *  MsgBox(Date.Year '-' Date.Month '-' Date.Day ' ' Date.Hour ':' Date.Minute) ; 2024-01-28 19:15
     * @
     * @example
     *  DateStr := 'Voicemail From <1-555-555-5555> at 2024-01-28 07:15:20'
     *  DateFormat := 'at \t{yyyy-MM-dd HH:mm:ss}'
     *  Date := Container_Date(DateStr, DateFormat)
     *  MsgBox(Date.Year '-' Date.Month '-' Date.Day ' ' Date.Hour ':' Date.Minute ':' Date.Second) ; 2024-01-28 07:15:20
     * @
     *
     *   - You can include multiple sets of \t escaped format units.
     * @example
     *  DateStr := 'Voicemail From <1-555-555-5555> Received January 28, 2024 at 12:15:20 AM'
     *  DateFormat := 'Received \t{MMMM dd, yyyy} at \t{hh:mm:ss tt}'
     *  Date := Container_Date(DateStr, DateFormat, 'i)') ; Use case insensitive matching when matching a month by name.
     *  MsgBox(Date.Year '-' Date.Month '-' Date.Day ' ' Date.Hour ':' Date.Minute ':' Date.Second) ; 2024-01-28 00:15:20
     * @
     *
     *   - You can use the "?" quantifier.
     * @example
     *  DateStr1 := 'Voicemail From <1-555-555-5555> Received January 28, 2024 at 12:15 AM'
     *  DateStr2 := 'Voicemail From <1-555-555-5555> Received January 28, 2024 at 12:15:12 AM'
     *  DateFormat := 'Received \t{MMMM dd, yyyy} at \t{hh:mm:?ss? tt}'
     *  Date1 := Container_Date(DateStr1, DateFormat, 'i)') ; Use case insensitive matching when matching a month by name.
     *  Date2 := Container_Date(DateStr2, DateFormat, 'i)')
     *  MsgBox(Date1.Year '-' Date1.Month '-' Date1.Day ' ' Date1.Hour ':' Date1.Minute ':' Date1.Second) ; 2024-01-28 00:15:00
     *  Date2 := Container_Date(DateStr2, DateFormat)
     *  MsgBox(Date2.Year '-' Date2.Month '-' Date2.Day ' ' Date2.Hour ':' Date2.Minute ':' Date2.Second) ; 2024-01-28 00:15:12
     * @
     *
     *   - The match object is set to the property `Container_DateInstance.Match`. Include any extra subcapture
     * groups that you are interested in.
     * @example
     *  DateStr := 'The child was born May 2, 1990, the year of the horse'
     *  DateFormat := '\t{MMMM d, yyyy}, the year of the (?<animal>\w+)'
     *  Date := Container_Date(DateStr, DateFormat, 'i)') ; Use case insensitive matching when matching a month by name.
     *  MsgBox(Date.Year '-' Date.Month '-' Date.Day ' ' Date.Hour ':' Date.Minute ':' Date.Second) ; 1990-05-02 00:00:00
     *  MsgBox(Date.Match['animal']) ; horse
     * @
     *
     * @param {String} [RegExOptions=""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     * @param {Boolean} [SubcaptureGroup=true] - When true, each \t escaped format group is captured
     * in an unnamed subcapture group. When false, the function does not include any additional
     * subcapture groups.
     * @param {Boolean} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used.
     * @param {Boolean} [Validate=false] - When true, the values of each property are validated
     * before the function completes. The values are validated numerically, and if any value exceeds
     * the maximum value for that property, an error is thrown. For example, if the month is greater
     * than 12 or the hour is greater than 24, an error is thrown.
     * @returns {Container_Date} - The {@link Container_Date} object.
     */
    static Call(DateStr, DateFormat, RegExOptions := '', SubcaptureGroup := true, Century?, Validate := false) {
        return Container_DateParser(DateFormat, RegExOptions, SubcaptureGroup)(DateStr, Century ?? unset, Validate)
    }

    /**
     * @description - Creates a {@link Container_Date} object from a timestamp string.
     * @param {String} [Timestamp] - The timestamp string from which to create the {@link Container_Date}
     * object. `Timestamp` should at least be 4 characters long containing the year. The rest is
     * optional. If unset, `A_Now` is used.
     * @returns {Container_Date} - The {@link Container_Date} object.
     */
    static FromTimestamp(Timestamp?) {
        if !IsSet(Timestamp) {
            Timestamp := A_Now
        }
        Date := {}
        ObjSetBase(Date, this.Prototype)
        Date.Set(Timestamp)
        return Date
    }

    /**
     * @description - Get the number of days in a month.
     * @param {Integer} Month - The month to get the number of days for.
     * @param {Integer} [Year] - The year to get the number of days for.
     * If not set, the current year is used.
     * @returns {Integer} - The number of days in the month.
     */
    static GetDayCount(Month, Year?) {
        if Month = 2 {
            n := this.IsLeapYear(Year ?? SubStr(A_Now, 1, 4)) + 1
            return this.MonthDays[2][n]
        } else {
            return this.MonthDays[Month]
        }
    }

    /**
     * @description - Returns the month index. Indices are 1-based. (January is 1).
     * @param {String} MonthStr - Three or more of the first characters of the month's name.
     * @param {Boolean} [TwoDigits = false] - When true, the return value is padded to always be 2 digits.
     * @returns {String} - The 1-based index.
     */
    static GetMonthIndex(MonthStr, TwoDigits := false) {
        if TwoDigits {
            switch SubStr(MonthStr, 1, 3), 0 {
                case 'jan': return '01'
                case 'feb': return '02'
                case 'mar': return '03'
                case 'apr': return '04'
                case 'may': return '05'
                case 'jun': return '06'
                case 'jul': return '07'
                case 'aug': return '08'
                case 'sep': return '09'
                case 'oct': return '10'
                case 'nov': return '11'
                case 'dec': return '12'
                default: _Throw()
            }
        } else {
            switch SubStr(MonthStr, 1, 3), 0 {
                case 'jan': return '1'
                case 'feb': return '2'
                case 'mar': return '3'
                case 'apr': return '4'
                case 'may': return '5'
                case 'jun': return '6'
                case 'jul': return '7'
                case 'aug': return '8'
                case 'sep': return '9'
                case 'oct': return '10'
                case 'nov': return '11'
                case 'dec': return '12'
                default: _Throw()
            }
        }
        _Throw() {
            throw ValueError('Unexpected value for ``MonthStr``.', -1, MonthStr)
        }
    }

    static GetSeconds(StartTimestamp, EndTimestamp) {
        start := Container_Date.FromTimestamp(StartTimestamp)
        end := Container_Date.FromTimestamp(EndTimestamp)
        if end.Year < start.Year || (start.Year = end.Year && end.YearSeconds < start.YearSeconds) {
            throw ValueError('``StartTimestamp`` must specify a time value earlier than ``EndTimestamp``.', -1)
        }
        if start.Year = end.Year {
            return end.YearSeconds - start.YearSeconds
        }
        ; Count leap years in (start.Year, end.Year)
        leapYears := this.LeapCountBetween(start.Year, end.Year)
        return start.SecondsRemainingInYear                                     ; remainder of start year
          + end.YearSeconds                                     ; elapsed in end year
          + (end.Year - start.Year - 1 - leapYears) * CONTAINER_DATE_SECONDS_IN_YEAR   ; 365-day years
          + leapYears * CONTAINER_DATE_SECONDS_IN_LEAPYEAR             ; 366-day years
    }

    static IsLeapYear(Year) => (!Mod(Year, 4) && (Mod(Year, 100) || !Mod(Year, 400))) ? 1 : 0

    /**
     * Returns the count of integers between `Year` and 0, excluding `Year`, that satisfy the
     * Gregorian leap rule.
     * @param {Integer} Year - The year.
     * @returns {Integer}
     */
    static LeapCountBefore(Year) {
        k := Year - 1
        return Floor(k / 4) - Floor(k / 100) + Floor(k / 400)
    }

    /**
     * Returns the count of integers between `StartYear` and `EndYear`, excluding both `StartYear`
     * and `EndYear`, that satisfy the Gregorian leap rule.
     * @param {Integer} Year - The year.
     */
    static LeapCountBetween(StartYear, EndYear) => Abs(this.LeapCountBefore(EndYear) - this.LeapCountBefore(StartYear + 1))

    /**
     * @description - Sets the default values that the date objects will use for the timestamp when
     * the value is absent.
     * @param {String|Integer} Value - The default value.
     * @param {String} Name - The name of the property. Specifically, one of the following: Year,
     * Month, Day, Hour, Minute, Second, Options.
     */
    static SetDefault(Value, Name) {
        if Name = 'Options' {
            this.Prototype.Options := Value
        } else if Name = 'Year' {
            this.Prototype.SetYear(Value)
        } else {
            this.Prototype.SetValue(Value, Name)
        }
    }
    /**
     * Sets the default century that is used when the {@link Container_Date#Year} property is updated with
     * a one- or two-digit year value. Though this property is referred to as "default century",
     * you can specify the decade in the default century value if you expect to work with
     * year values that are single digit. For example, if your code sets the default century to "199"
     * and then sets `Date.Year := 1`, the year value will be set as "1991".
     *
     * The default default century is the current year and decade, i.e. `SubStr(A_Now, 1, 3)`.
     *
     * If the default century includes the decade, if your code sets {@link Container_Date#Year} with a
     * two-digit value, the decade from the input value is used. For example, if your code sets
     * the default century to "199" and then sets `Date.Year := 04`, the year value will be set as
     * "1904".
     *
     * @param {String|Integer} Century - The new default century value as either a 2- or 3-character
     * value.
     */
    static SetDefaultCentury(Century) {
        this.Prototype.DefaultCentury := Century
    }

    /**
     * @description - Adds the time to this object's timestamp, modifying this object's time value.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateAdd.htm}
     * @param {Integer} Time - The amount of time to add, as an integer or floating-point number.
     * Specify a negative number to perform subtraction.
     * @param {String} TimeUnits - The meaning of the `Time` parameter. TimeUnits may be one of the
     * following strings (or just the first letter): Seconds, Minutes, Hours or Days.
     * @returns {String} - The new timestamp.
     */
    Add(Time, TimeUnits) => this.Set(DateAdd(this.Timestamp, Time, TimeUnits))

    /**
     * @description - Creates a new {@link Container_Date} by adding the time value to this object's
     * timestamp with {@link https://www.autohotkey.com/docs/v2/lib/DateAdd.htm DateAdd}. Does
     * not modify this object's time value.
     * @param {Integer} Time - The amount of time to add, as an integer or floating-point number.
     * Specify a negative number to perform subtraction.
     * @param {String} TimeUnits - The meaning of the `Time` parameter. TimeUnits may be one of the
     * following strings (or just the first letter): Seconds, Minutes, Hours or Days.
     * @returns {Container_Date} - The new {@link Container_Date} object.
     */
    AddToNew(Time, TimeUnits) => Container_Date.FromTimestamp(DateAdd(this.Timestamp, Time, TimeUnits))

    /**
     * @description - Adds the time value to this object's timestamp with
     * {@link https://www.autohotkey.com/docs/v2/lib/DateAdd.htm DateAdd} and returns the new
     * timestamp. Does not modify this object's time value.
     * @param {Integer} Time - The amount of time to add, as an integer or floating-point number.
     * Specify a negative number to perform subtraction.
     * @param {String} TimeUnits - The meaning of the `Time` parameter. TimeUnits may be one of the
     * following strings (or just the first letter): Seconds, Minutes, Hours or Days.
     * @returns {String} - The return value from {@link https://www.autohotkey.com/docs/v2/lib/DateAdd.htm DateAdd}
     */
    AddToTimestamp(Time, TimeUnits) => DateAdd(this.Timestamp, Time, TimeUnits)

    /**
     * Calls `Container_Date.FromTimestamp(this.Timestamp)`, returning a new {@link Container_Date} with the same
     * time value.
     * @returns {Container_Date}
     */
    Clone() => Container_Date.FromTimestamp(this.Timestamp)

    /**
     * @description - Get the difference between two dates.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm}
     * @param {String} Unit - Units to measure the difference in. TimeUnits may be one of the
     * following strings (or just the first letter): Seconds, Minutes, Hours or Days.
     * @param {String} [Timestamp] - The timestamp to compare to. If not set, the current time is used.
     * @returns {Integer} - The difference between the two dates.
     */
    Diff(Unit, Timestamp?) => DateDiff(this.Timestamp, Timestamp ?? A_Now, Unit)

    Get(FormatStr?) => FormatTime(this.Timestamp ' ' this.Options, FormatStr ?? unset)

    /**
     * @description - Get the number of days in a month.
     * @param {Integer} Month - The month to get the number of days for.
     * @returns {Integer} - The number of days in the month.
     */
    GetDayCount(Month) => Container_Date.GetDayCount(Month, this.Year)

    /**
     * @description - Get the timestamp from the date object. You can pass default values to
     * any of the parameters. Also see {@link Container_Date.SetDefault}.
     * @param {String} [DefaultYear] - The default year to use if the year is not set.
     * @param {String} [DefaultMonth] - The default month to use if the month is not set.
     * @param {String} [DefaultDay] - The default day to use if the day is not set.
     * @param {String} [DefaultHour] - The default hour to use if the hour is not set.
     * @param {String} [DefaultMinute] - The default minute to use if the minute is not set.
     * @param {String} [DefaultSecond] - The default second to use if the second is not set.
     * @returns {String} - The timestamp.
     */
    GetTimestamp(DefaultYear?, DefaultMonth?, DefaultDay?, DefaultHour?, DefaultMinute?, DefaultSecond?) {
        return (
            (this.HasOwnProp('__Year') ? this.Year : DefaultYear ?? this.Year)
            (this.HasOwnProp('__Month') ? this.Month : DefaultMonth ?? this.Month)
            (this.HasOwnProp('__Day') ? this.Day : DefaultDay ?? this.Day)
            (this.HasOwnProp('__Hour') ? this.Hour : DefaultHour ?? this.Hour)
            (this.HasOwnProp('__Minute') ? this.Minute : DefaultMinute ?? this.Minute)
            (this.HasOwnProp('__Second') ? this.Second : DefaultSecond ?? this.Second)
        )
    }

    /**
     * @description - Adds options that get used when accessing any of the time format properties.
     * @param {String} Options - The options to use.
     * @see https://www.autohotkey.com/docs/v2/lib/FormatTime.htm#Additional_Options
     */
    Opt(Options) => this.Options := Options

    /**
     * Adjusts this object's time value using an input timestamp. The input timestamp does not need
     * to be the full 14 characters representing yyyyMMddHHmmss, but the meaning of the characters
     * are interpreted in that order. For example, passing "2004" to {@link Container_Date.Prototype.Set}
     * will only update the year to 2004. Passing "200403" will update the year to 2004 and the month
     * to 03. Passing "20040320" will update the year to 2004, the month to 03, and the day to 20.
     * @param {String|Integer} Timestamp - The new time value.
     * @returns {String} - This object's new timestamp.
     * @throws {ValueError} - "`Timestamp` must be at least 4 characters in length."
     */
    Set(Timestamp) {
        if StrLen(Timestamp) >= 4 {
            this.__Year := SubStr(Timestamp, 1, 4)
        } else {
            throw ValueError('``Timestamp`` must at least be 4 characters in length.', -1, Timestamp)
        }
        if StrLen(Timestamp) >= 6 {
            this.__Month := SubStr(Timestamp, 5, 2)
        }
        if StrLen(Timestamp) >= 8 {
            this.__Day := SubStr(Timestamp, 7, 2)
        }
        if StrLen(Timestamp) >= 10 {
            this.__Hour := SubStr(Timestamp, 9, 2)
        }
        if StrLen(Timestamp) >= 12 {
            this.__Minute := SubStr(Timestamp, 11, 2)
        }
        if StrLen(Timestamp) >= 14 {
            this.__Second := SubStr(Timestamp, 13, 2)
        }
        return this.Timestamp
    }
    /**
     * Updates the year value.
     * @param {String|Integer} Year - The year value
     * @returns {String} - The new timestamp
     * @throws {ValueError} - "The input `Year` is one digit, but the default century value is
     * less than three digits, so the correct year cannot be constructed."
     * @throws {ValueError} - "The input `Year` is two digits, but the default century value is
     * less than two digits, so the correct year cannot be constructed."
     * @throws {ValueError} - "Unexpected `Year`.". This occurs if the length of `Year` is not
     * 1, 2, or 4.
     */
    SetYear(Year) {
        switch StrLen(Year) {
            case 1:
                if StrLen(this.DefaultCentury) >= 3 {
                    this.DefineProp('__Year', { Value: this.DefaultCentury Year })
                } else {
                    ; If you get this error, see static method `Container_Date.SetDefaultCentury`.
                    throw ValueError('The input ``Year`` is one digit, but the default century'
                    ' value is less than three digits, so the correct year cannot be constructed.'
                    , -1, Year)
                }
            case 2:
                if StrLen(this.DefaultCentury) >= 2 {
                    this.DefineProp('__Year', { Value: SubStr(this.DefaultCentury, 1, 2) Year })
                } else {
                    ; If you get this error, see static method `Container_Date.SetDefaultCentury`.
                    throw ValueError('The input ``Year`` is two digits, but the default century'
                    ' value is less than two digits, so the correct year cannot be constructed.'
                    , -1, Year)
                }
            case 4:
                this.DefineProp('__Year', { Value: Year })
            default: throw ValueError('Unexpected ``Year``.', -1, Year)
        }
        return this.Timestamp
    }
    /**
     * Updates a time value, padding the value with a "0" if the input `Value` is 1 character.
     * @param {String|Integer} Value - The new value.
     * @param {String} Unit - The meaning of `Value`.
     * @returns {String} - The new timestamp.
     */
    SetValue(Value, Unit) {
        this.DefineProp('__' Unit, { Value: StrLen(Value) == 1 ? '0' Value : Value })
        return this.Timestamp
    }

    /**
     * @description - Enables the ability to get a numeric value by adding 'N' to the front of a
     * property name.
     * @example
     *  Date := Container_Date('2024-01-28 19:15', 'yyyy-MM-dd HH:mm')
     *  MsgBox(Type(Date.Minute)) ; String
     *  MsgBox(Type(Date.NMinute)) ; Integer
     *
     *  ; AHK handles conversions most of the time anyway.
     *  z := 10
     *  MsgBox(Date.NMinute + z) ; 25
     *  MsgBox(Date.Minute + z) ; 25
     *
     *  ; Map object keys do not convert.
     *  m := Map(15, 'val')
     *  MsgBox(m[Date.NMinute]) ; 'val'
     *  MsgBox(m[Date.Minute]) ; Error: Item has no value.
     * @
     */
    __Get(Name, *) {
        if SubStr(Name, 1, 1) = 'N' && this.HasOwnProp(SubStr(Name, 2)) {
            return Number(this.%SubStr(Name, 2)%||0)
        }
        throw PropertyError('Unknown property.', -1, Name)
    }

    /**
     * The number of seconds from midnight, including the object's current second.
     * @memberof Container_Date
     * @instance
     * @type {Integer}
     */
    DaySeconds => this.Hour * 3600 + this.Minute * 60 + this.Second
    /**
     * Returns 1 if the object's year is a leap year, 0 otherwise.
     * @memberof Container_Date
     * @instance
     * @type {Integer}
     */
    IsLeapYear => Container_Date.IsLeapYear(this.Year)
    /**
     * The number of seconds since January 01, 00:00:00 of the object's millenia. For example, if the
     * object's time value is 20240530182020, then {@link Container_Date.Prototype.MilleniaSeconds} will
     * return the number of seconds from January 01, 2000, 00:00:00.
     * @memberof Container_Date
     * @instance
     * @type {Integer}
     */
    MilleniaSeconds => Container_Date.GetSeconds(SubStr(this.Year, 1, 1) '000' SubStr(this.Timestamp, 5), this.Timestamp)
    /**
     * The total seconds in this object's year. If it is a leap year, returns 31536000. Else,
     * returns 31449600.
     * @memberof Container_Date
     * @instance
     * @type {Integer}
     */
    SecondsInYear => this.IsLeapYear ? CONTAINER_DATE_SECONDS_IN_LEAPYEAR : CONTAINER_DATE_SECONDS_IN_YEAR
    /**
     * The seconds remaining until January 01 of the year following the object's current year.
     * @memberof Container_Date
     * @instance
     * @type {Integer}
     */
    SecondsRemainingInYear => this.SecondsInYear - this.YearSeconds
    /**
     * The timestamp of the date object.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    Timestamp => this.GetTimestamp()
    /**
     * The number of seconds since January 01, 00:00:00 of year 1 in the proleptic Gregorian calendar.
     * @memberof Container_Date
     * @instance
     * @type {Integer}
     */
    TotalSeconds => Container_Date.GetSeconds('00010101000000', this.Timestamp)
    /**
     * The number of days since January 01 of the object's year, including the object's current day.
     * @memberof Container_Date
     * @instance
     * @type {Integer}
     */
    YearDays {
        Get {
            d := 0
            monthDays := Container_Date.MonthDays
            loop this.Month - 1 {
                if A_Index == 2 {
                    d += Mod(this.Year, 4) ? 28 : 29
                } else {
                    d += monthDays[A_Index]
                }
            }
            return d + this.Day
        }
    }
    /**
     * The number of seconds since January 01, 00:00:00 of the object's year, including the object's
     * current second.
     * @memberof Container_Date
     * @instance
     * @type {Integer}
     */
    YearSeconds {
        Get {
            s := 0
            loop this.Month - 1 {
                s += this.GetDayCount(A_Index) * 86400
            }
            return s + (this.Day - 1) * 86400 + this.DaySeconds
        }
    }

    /**
     * {@link https://www.autohotkey.com/docs/v2/lib/FormatTime.htm#Standalone_Formats}
     */

    /**
     * Long date representation for the current user's locale, such as Friday, April 23, 2004.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    LongDate => FormatTime(this.Timestamp ' ' this.Options, 'LongDate')
    /**
     * Short date representation for the current user's locale, such as 02/29/04.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    ShortDate => FormatTime(this.Timestamp ' ' this.Options, 'ShortDate')
    /**
     * Time representation for the current user's locale, such as 5:26 PM.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    Time => FormatTime(this.Timestamp ' ' this.Options, 'Time')
    /**
     * "Leave Format blank to produce the time followed by the long date. For example, in some
     * locales it might appear as 4:55 PM Saturday, November 27, 2004"
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    ToLocale => FormatTime(this.Timestamp)
    /**
     * Day of the week (1 – 7). Sunday is 1.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    WDay => FormatTime(this.Timestamp ' ' this.Options, 'WDay')
    /**
     * Day of the year without leading zeros (1 – 366).
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    YDay => FormatTime(this.Timestamp ' ' this.Options, 'YDay')
    /**
     * Day of the year with leading zeros (001 – 366).
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    YDay0 => FormatTime(this.Timestamp ' ' this.Options, 'YDay0')
    /**
     * Year and month format for the current user's locale, such as February, 2004.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    YearMonth => FormatTime(this.Timestamp ' ' this.Options, 'YearMonth')
    /**
     * The ISO 8601 full year and week number.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    YWeek => FormatTime(this.Timestamp ' ' this.Options, 'YWeek')

    /**
     * The year value.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    Year {
        Get => this.__Year
        Set => this.SetYear(Value)
    }
    /**
     * The month value.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    Month {
        Get => this.__Month
        Set => this.SetValue(Value, 'Month')
    }
    /**
     * The day value.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    Day {
        Get => this.__Day
        Set => this.SetValue(Value, 'Day')
    }
    /**
     * The hour value.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    Hour {
        Get => this.__Hour
        Set => this.SetValue(Value, 'Hour')
    }
    /**
     * The minute value.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    Minute {
        Get => this.__Minute
        Set => this.SetValue(Value, 'Minute')
    }
    /**
     * The second value.
     * @memberof Container_Date
     * @instance
     * @type {String}
     */
    Second {
        Get => this.__Second
        Set => this.SetValue(Value, 'Second')
    }
}

class Container_DateParser {
    static __New() {
        this.DeleteProp('__New')
        this.Prototype.12hour := false
    }

    /**
     * @description - Contains three built-in patterns to parse date strings. These are the literal patterns:
     * @example
     *  p1 := '(?<Year>\d{4}).(?<Month>\d{1,2}).(?<Day>\d{1,2})(?:.+?(?<Hour>\d{1,2}).(?<Minute>\d{1,2})(?:.(?<Second>\d{1,2}))?)?'
     *  p2 := '(?<Month>\d{1,2}).(?<Day>\d{1,2}).(?<Year>(?:\d{4}|\d{2}))(?:.+?(?<Hour>\d{1,2}).(?<Minute>\d{1,2})(?:.(?<Second>\d{1,2}))?)?'
     *  p3 := '(?<Hour>\d{1,2}):(?<Minute>\d{1,2})(?::(?<Second>\d{1,2}))?'
     * @
     *
     * The patterns represent strings like these. This is not an exhaustive list:
     * "yyyy-M-d H:m:s" - the time units are optional, seconds optional within the time units
     * "M/d/yyyy H:m:s" - the time units are optional, seconds optional within the time units
     * "M/d/yy H:m:s" - the time units are optional, seconds optional within the time units
     * "h:m:s" - time by itself, the seconds optional
     *
     * @param {String} DateStr - The date string to parse.
     * @returns {Container_Date} - The {@link Container_Date} object.
     */
    static Parse(DateStr) {
        if RegExMatch(DateStr, '(?<Year>\d{4}).(?<Month>\d{1,2}).(?<Day>\d{1,2})(?:.+?(?<Hour>\d{1,2}).(?<Minute>\d{1,2})(?:.(?<Second>\d{1,2}))?)?', &match)
        || RegExMatch(DateStr, '(?<Month>\d{1,2}).(?<Day>\d{1,2}).(?<Year>(?:\d{4}|\d{2}))(?:.+?(?<Hour>\d{1,2}).(?<Minute>\d{1,2})(?:.(?<Second>\d{1,2}))?)?', &match) {
            ObjSetBase(Date := {
                Year: match.Len['Year'] == 2 ? SubStr(A_Now, 1, 2) match['Year'] : match['Year']
              , Month: (match.Len['Month'] == 1 ? '0' : '') match['Month']
              , Day: (match.Len['Day'] == 1 ? '0' : '') match['Day']
              , Hour: match.Len['Hour'] ? (match.Len['Hour'] == 1 ? '0' : '') match['Hour'] : unset
              , Minute: match.Len['Minute'] ? (match.Len['Minute'] == 1 ? '0' : '') match['Minute'] : unset
              , Second: match.Len['Second'] ? (match.Len['Second'] == 1 ? '0' : '') match['Second'] : unset
            }, Container_Date.Prototype)
        } else if RegExMatch(DateStr, '(?<Hour>\d{1,2}):(?<Minute>\d{1,2})(?::(?<Second>\d{1,2}))?', &match) {
            ObjSetBase(Date := {
                Hour: (match.Len['Hour'] == 1 ? '0' : '') match['Hour']
              , Minute: (match.Len['Minute'] == 1 ? '0' : '') match['Minute']
              , Second: match['Second'] ? (match.Len['Second'] == 1 ? '0' : '') match['Second'] : unset
            }, Container_Date.Prototype)
        }
        Date.Match := match
        return Date
    }

    /**
     * @description - Creates a `Container_DateParser` object that can be reused to create {@link Container_Date} objects.
     * @param {String} DateFormat - The format of the date string. See the {@link Container_Date.Call}
     * description for details.
     * @param {String} [RegExOptions=""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     * @param {Boolean} [SubcaptureGroup=true] - When true, each \t escaped format group is captured
     * in an unnamed subcapture group. When false, the function does not include any additional
     * subcapture groups.
     * @returns {Container_DateParser} - The `Container_DateParser` object.
     */
    __New(DateFormat, RegExOptions := '', SubcaptureGroup := true) {
        this.DateFormat := DateFormat
        rc := Chr(0xFFFD) ; replacement character
        replacement := []
        replacement.Capacity := 20
        flag_period := false
        pos := 1
        i := 0
        while RegExMatch(DateFormat, '\\t\{([^}]+)\}', &matchgroup, pos) {
            copy := matchgroup[1]
            pos := matchgroup.Pos + matchgroup.Len
            _Proc(&copy)
            if SubcaptureGroup {
                DateFormat := StrReplace(DateFormat, matchgroup[0], '(' copy ')', , , 1)
            } else {
                DateFormat := StrReplace(DateFormat, matchgroup[0], '(?:' copy ')', , , 1)
            }
        }
        if !i {
            _Proc(&DateFormat)
        }
        if this.12hour && !flag_period {
            throw Error('The date format string indicates 12-hour time format, but does not include an AM/PM indicator')
        }
        for r in replacement {
            DateFormat := StrReplace(DateFormat, r.temp, r.pattern, , , 1)
        }
        this.RegExOptions := RegExOptions
        this.Pattern := DateFormat

        _Proc(&p) {
            if RegExMatch(p, '(y+)(\??)', &match) {
                replacement.Push({ pattern: '(?<Year>\d{' (match.Len[1] == 1 ? '1,2' : match.Len[1]) '})' match[2], temp: rc (++i) rc })
                p := StrReplace(p, match[0], replacement[-1].temp, true, , 1)
            }
            if RegExMatch(p, '(M+)(\??)', &match) {
                if match.Len[1] == 1 {
                    pattern := '(?<Month>\d{1,2})'
                } else if match.Len[1] == 2 {
                    pattern := '(?<Month>\d{2})'
                } else if match.Len[1] == 3 {
                    pattern := '(?<Month>(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))'
                } else if match.Len[1] == 4 {
                    pattern := '(?<Month>(?:january|february|march|april|may|june|july|august|september|october|november|december))'
                }
                replacement.Push({ pattern: pattern match[2], temp: rc (++i) rc })
                p := StrReplace(p, match[0], replacement[-1].temp, true, , 1)
            }
            if RegExMatch(p, '(h+)(\??)', &match) {
                replacement.Push({ pattern: '(?<Hour>\d{' (match.Len[1] == 1 ? '1,2' : '2') '})' match[2], temp: rc (++i) rc })
                p := StrReplace(p, match[0], replacement[-1].temp, true, , 1)
                this.12hour := true
            }
            if RegExMatch(p, '(t+)(\??)', &match) {
                if match.Len[1] == 1 {
                    pattern := '(?<Period>[ap])'
                } else {
                    pattern := '(?<Period>[ap]m)'
                }
                replacement.Push({ pattern: pattern match[2], temp: rc (++i) rc })
                p := StrReplace(p, match[0], replacement[-1].temp, true, , 1)
                flag_period := true
            }
            for ch, name in Map('d', 'Day', 'H', 'Hour', 'm', 'Minute', 's', 'Second') {
                if RegExMatch(p, '(' ch '+)(\??)', &match) {
                    replacement.Push({ pattern: '(?<' name '>\d{' (match.Len[1] == 1 ? '1,2' : '2') '})' match[2], temp: rc (++i) rc })
                    p := StrReplace(p, match[0], replacement[-1].temp, true, , 1)
                }
            }
        }
    }

    /**
     * @description - Parses the input date string and returns a {@link Container_Date} object.
     * @param {String} DateStr - The date string to parse.
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used.
     * @param {Boolean} [Validate=false] - When true, the values of each property are validated
     * before the function completes. The values are validated numerically, and if any value exceeds
     * the maximum value for that property, an error is thrown. For example, if the month is greater
     * than 13 or the hour is greater than 24, an error is thrown.
     * @returns {Container_Date} - The {@link Container_Date} object.
     */
    Call(DateStr, Century?, Validate := false) {
        local Match
        if !RegExMatch(DateStr, this.RegExOptions this.Pattern, &match) {
            return ''
        }
        ObjSetBase(Date := {}, Container_Date.Prototype)
        Date.DefineProp('Parser', { Value: this })
        Date.DefineProp('Match', { Value: match })
        for unit, str in match {
            switch unit {
                case 'Year':
                    if match.Len['Year'] {
                        switch match.Len['Year'] {
                            case 1: Date.DefineProp('__Year', { Value: (Century ?? SubStr(A_Now, 1, 3)) match['Year'] })
                            case 2: Date.DefineProp('__Year', { Value: (Century ?? SubStr(A_Now, 1, 2)) match['Year'] })
                            case 4: Date.DefineProp('__Year', { Value: match['Year'] })
                        }
                    }
                case 'Month':
                    if match.Len['Month'] {
                        if IsNumber(match['Month']) {
                            if match.Len['Month'] == 1 {
                                Date.DefineProp('__Month', { Value: '0' match['Month'] })
                            } else {
                                Date.DefineProp('__Month', { Value: match['Month'] })
                            }
                        } else {
                            Date.DefineProp('__Month', { Value: Container_Date.GetMonthIndex(match['Month'], true) })
                        }
                    }
                case 'Hour':
                    if match.Len['Hour'] {
                        if this.12hour {
                            n := Number(match['Hour'])
                            switch SubStr(match['Period'], 1, 1), 0 {
                                case 'a':
                                    if n == 12 {
                                        Date.DefineProp('__Hour', { Value: '00' })
                                    } else if Match.Len['Hour'] == 1 {
                                        Date.DefineProp('__Hour', { Value: '0' match['Hour'] })
                                    } else {
                                        Date.DefineProp('__Hour', { Value: match['Hour'] })
                                    }
                                case 'p':
                                    if n == 12 {
                                        Date.DefineProp('__Hour', { Value: '12' })
                                    } else {
                                        Date.DefineProp('__Hour', { Value: String(n + 12) })
                                    }
                            }
                        } else {
                            if match.Len['Hour'] == 1 {
                                Date.DefineProp('__Hour', { Value: '0' match['Hour'] })
                            } else if match.Len['Hour'] == 2 {
                                Date.DefineProp('__Hour', { Value: match['Hour'] })
                            }
                        }
                    }
                case 'Minute', 'Second', 'Day':
                    if match.Len[unit] {
                        if match.Len[unit] == 1 {
                            Date.DefineProp('__' unit, { Value: '0' match[unit] })
                        } else if match.Len[unit] == 2 {
                            Date.DefineProp('__' unit, { Value: match[unit] })
                        }
                    }
            }
        }
        if Validate {
            if Date.NMonth > 12
                _ThrowInvalidResultError('Month: ' Date.Month)
            ; If we don't know the year and the month is February, use 29 as the value by default
            if Date.Month == '02' && !Date.Year {
                if Date.NDay > 29
                    _ThrowInvalidResultError('Day: ' Date.Day)
            } else if Date.NDay > Container_Date.GetDayCount(Date.NMonth, Date.NYear)
                _ThrowInvalidResultError('Day: ' Date.Day)
            if Date.NHour > 24
                _ThrowInvalidResultError('Hour: ' Date.Hour)
            if Date.NMinute > 60
                _ThrowInvalidResultError('Minute: ' Date.Minute)
            if Date.NSecond > 60
                _ThrowInvalidResultError('Second: ' Date.Second)
        }
        return Date

        _ThrowInvalidResultError(Value) {
            throw ValueError('The result produced an invalid date.', -2, Value)
        }
    }
}

/*
List of sort types
CONTAINER_SORTTYPE_CB_DATE
CONTAINER_SORTTYPE_CB_DATESTR
CONTAINER_SORTTYPE_CB_NUMBER
CONTAINER_SORTTYPE_CB_STRING
CONTAINER_SORTTYPE_CB_STRINGPTR
CONTAINER_SORTTYPE_DATE
CONTAINER_SORTTYPE_DATESTR
CONTAINER_SORTTYPE_DATEVALUE
CONTAINER_SORTTYPE_MISC
CONTAINER_SORTTYPE_NUMBER
CONTAINER_SORTTYPE_STRING
CONTAINER_SORTTYPE_STRINGPTR
*/

/**
 * @param {Boolean} [force = false] - If false, and if {@link Container_SetConstants} has been called
 * before, returns immediately and does not set the values. If true, executes the entire function
 * whether or not {@link Container_SetConstants} has been called before.
 */
Container_SetConstants(force := false) {
    global
    if IsSet(container_flag_constants_set) && !force {
        return
    }
    g_kernel32_CompareStringEx := DllCall('GetProcAddress', 'Ptr', DllCall('GetModuleHandle', 'Str', 'kernel32', 'Ptr'), 'AStr', 'CompareStringEx', 'Ptr')

    if !IsSet(PTR_EMPTY_STRING) {
        PTR_EMPTY_STRING := StrPtr('')
    }

    local i := 0
    CONTAINER_SORTTYPE_CB_DATE         := ++i
    CONTAINER_SORTTYPE_CB_DATESTR      := ++i
    CONTAINER_SORTTYPE_CB_NUMBER       := ++i
    CONTAINER_SORTTYPE_CB_STRING       := ++i
    CONTAINER_SORTTYPE_CB_STRINGPTR    := ++i
    CONTAINER_SORTTYPE_DATE            := ++i
    CONTAINER_SORTTYPE_DATESTR         := ++i
    CONTAINER_SORTTYPE_DATEVALUE       := ++i
    CONTAINER_SORTTYPE_MISC            := ++i
    CONTAINER_SORTTYPE_NUMBER          := ++i
    CONTAINER_SORTTYPE_STRING          := ++i
    CONTAINER_SORTTYPE_STRINGPTR       := ++i
    CONTAINER_SORTTYPE_END             := i ; indicates the final value in the group

    CONTAINER_DEFAULT_ENCODING          := 'cp1200'
    CONTAINER_INSERTIONSORT_THRESHOLD   := 16

    LOCALE_NAME_INVARIANT               := PTR_EMPTY_STRING
    LOCALE_NAME_USER_DEFAULT            := 0
    LOCALE_NAME_SYSTEM_DEFAULT          := StrPtr('!x-sys-default-locale')
    LINGUISTIC_IGNORECASE               := 0x00000010
    LINGUISTIC_IGNOREDIACRITIC          := 0x00000020
    NORM_IGNORECASE                     := 0x00000001
    NORM_IGNOREKANATYPE                 := 0x00010000
    NORM_IGNORENONSPACE                 := 0x00000002
    NORM_IGNORESYMBOLS                  := 0x00000004
    NORM_IGNOREWIDTH                    := 0x00020000
    NORM_LINGUISTIC_CASING              := 0x08000000
    SORT_DIGITSASNUMBERS                := 0x00000008
    SORT_STRINGSORT                     := 0x00001000

    container_flag_constants_set := true
}

Container_CompareStringEx(LocaleName, Flags, NlsVersionInfo, Ptr1, Ptr2) {
    if result := DllCall(
        g_kernel32_CompareStringEx
      , 'ptr', LocaleName
      , 'uint', Flags
      , 'ptr', Ptr1
      , 'int', -1
      , 'ptr', Ptr2
      , 'int', -1
      , 'ptr', NlsVersionInfo
      , 'ptr', 0
      , 'ptr', 0
      , 'int'
    ) {
        return result - 2
    } else {
        throw OSError()
    }
}

Container_CompareDate(date1, date2) {
    return DateDiff(date1, date2, 'S')
}
Container_CompareDateEx(date1, date2) {
    return Container_Date.FromTimestamp(date1).TotalSeconds - Container_Date.FromTimestamp(date2).TotalSeconds
}
Container_CompareDateStr(DateParserObj, dateStr1, dateStr2) {
    return DateParserObj(dateStr1).Diff('S', DateParserObj(dateStr2).Timestamp)
}
Container_CompareDateStr_Century(DateParserObj, Century, dateStr1, dateStr2) {
    return DateParserObj(dateStr1, Century).Diff('S', DateParserObj(dateStr2, Century).Timestamp)
}
Container_CompareDateStr_CompareValue(DateParserObj, date1, dateStr2) {
    return date1.Diff('S', DateParserObj(dateStr2).Timestamp)
}
Container_CompareDateStr_Century_CompareValue(DateParserObj, Century, date1, dateStr2) {
    return date1.Diff('S', DateParserObj(dateStr2, Century).Timestamp)
}
Container_CompareDateStrEx(DateParserObj, dateStr1, dateStr2) {
    return DateParserObj(dateStr1).TotalSeconds - DateParserObj(dateStr2).TotalSeconds
}
Container_CompareDateStr_CenturyEx(DateParserObj, Century, dateStr1, dateStr2) {
    return DateParserObj(dateStr1, Century).TotalSeconds - DateParserObj(dateStr2, Century).TotalSeconds
}
Container_CompareDateStr_CompareValueEx(DateParserObj, date1, dateStr2) {
    return date1.TotalSeconds - DateParserObj(dateStr2).TotalSeconds
}
Container_CompareDateStr_Century_CompareValueEx(DateParserObj, Century, date1, dateStr2) {
    return date1.TotalSeconds - DateParserObj(dateStr2, Century).TotalSeconds
}
Container_CallbackValue_DateValue(Value) {
    return Value.__Container_DateValue
}
Container_CallbackValue_DateValueCustom(PropertyName, Value) {
    return Value.%PropertyName%
}
Container_CallbackDateInsert(PropertyName, DateObjFunc, CallbackValue, Value) {
    Value.DefineProp(PropertyName, { Value: DateObjFunc(CallbackValue(Value)).TotalSeconds })
}
Container_ConvertDate(DateObjFunc, Self, Value) {
    return DateObjFunc(Value).TotalSeconds
}
Container_ConvertDateCb(DateObjFunc, CallbackValue, Self, Value) {
    return DateObjFunc(CallbackValue(Value)).TotalSeconds
}

Container_IndexToSymbol(index) {
    if !Container.HasOwnProp('SortType') {
        Container_SetSortTypeContainer()
    }
    if Container.SortType.Find(index, &value) {
        return value
    } else {
        throw IndexError('``index`` is out of range.', , index)
    }
}
Container_SetSortTypeContainer() {
    sortType := Container.SortType := Container.CbNumber((value) => value.index)
    for s in Container.SortTypeSymbolList {
        if InStr(s, '_CB_') {
            obj := {
                index: %s%
              , name: RegExReplace(s, 'CONTAINER_SORTTYPE_CB_(\w)(\w+)', 'Cb')
              , symbol: s
            }
        } else {
            obj := {
                index: %s%
              , name: RegExReplace(s, 'CONTAINER_SORTTYPE_(\w)(\w+)', '')
              , symbol: s
            }
        }
        sortType.Insert(obj)
    }
}

class Container extends Array {
    static __New() {
        this.DeleteProp('__New')
        this.Collection := Map()
        proto := this.Prototype
        proto.CallbackCompare := proto.CallbackValue := proto.CompareDateCentury :=
        proto.CallbackCompareValue := proto.CompareStringNlsVersionInfo :=
        proto.CompareStringLocaleName := proto.__DateParser := proto.CallbackDateInsert :=
        ''
        proto.SortType := 0
        Container_SetConstants()
        this.SortTypeSymbolList := [
            'CONTAINER_SORTTYPE_CB_DATE'
          , 'CONTAINER_SORTTYPE_CB_DATESTR'
          , 'CONTAINER_SORTTYPE_CB_NUMBER'
          , 'CONTAINER_SORTTYPE_CB_STRING'
          , 'CONTAINER_SORTTYPE_CB_STRINGPTR'
          , 'CONTAINER_SORTTYPE_DATE'
          , 'CONTAINER_SORTTYPE_DATESTR'
          , 'CONTAINER_SORTTYPE_DATEVALUE'
          , 'CONTAINER_SORTTYPE_MISC'
          , 'CONTAINER_SORTTYPE_NUMBER'
          , 'CONTAINER_SORTTYPE_STRING'
          , 'CONTAINER_SORTTYPE_STRINGPTR'
        ]
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a string in the format yyyyMMddHHmmss.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareDate}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.timestamp
     * }
     *
     * c := Container.CbDate(CallbackValue)
     * c.InsertList([
     *     { timestamp: "20250312122930" }
     *   , { timestamp: "20250411122900" }
     *   , { timestamp: "20251015091805" }
     * ])
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static CbDate(CallbackValue, UseCompareDateEx := false, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_CB_DATE)
        c.SetCallbackValue(CallbackValue)
        c.SetCompareDate(UseCompareDateEx)
        return c
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a date string in any format recognized by the
     * {@link Container_DateParser} set to {@link Container#DateParser}.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareDateStr}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     *
     * c := Container.CbDateStr(CallbackValue, "yyyy-MM-dd HH:mm:ss")
     * c.InsertList([
     *     { date: "2025-03-12 12:29:30" }
     *   , { date: "2025-04-11 12:29:00" }
     *   , { date: "2025-10-15 09:18:05" }
     * ])
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {String} DateFormat - The format string that {@link Container_Date} uses to parse
     * date strings into usable date values.
     *
     * @param {String} [RegExOptions = ""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static CbDateStr(CallbackValue, DateFormat, RegExOptions := '', Century?, UseCompareDateEx := false, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_CB_DATESTR)
        c.SetCallbackValue(CallbackValue)
        c.SetCompareDateStr(DateFormat, RegExOptions, Century ?? unset, UseCompareDateEx)
        return c
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a date string in any format recognized
     * by the {@link Container_DateParser} set to {@link Container#DateParser}.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetDateParser}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     *
     * dateParser := Container_DateParser("yyyy-MM-dd HH:mm:ss")
     * c := Container.CbDateStrFromParser(CallbackValue, dateParser)
     * c.InsertList([
     *     { date: "2025-03-12 12:29:30" }
     *   , { date: "2025-04-11 12:29:00" }
     *   , { date: "2025-10-15 09:18:05" }
     * ])
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {Container_DateParser} DateParserObj - The {@link Container_DateParser}.
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateStr} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static CbDateStrFromParser(CallbackValue, DateParserObj, Century?, UseCompareDateEx := false, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_CB_DATESTR)
        c.SetCallbackValue(CallbackValue)
        c.SetDateParser(DateParserObj, Century ?? unset, UseCompareDateEx)
        return c
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a number.
     * - **CallbackCompare**: Not used.
     *
     * @example
     * CallbackValue(value) {
     *     return value.value
     * }
     *
     * c := Container.CbNumber(CallbackValue)
     * c.InsertList([
     *     { value: 298581 }
     *   , { value: 195801 }
     *   , { value: 585929 }
     * ])
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static CbNumber(CallbackValue, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_CB_NUMBER)
        c.SetCallbackValue(CallbackValue)
        return c
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a string.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.name
     * }
     *
     * c := Container.CbString(CallbackValue)
     * c.InsertList([
     *     { name: "obj4" }
     *   , { name: "obj3" }
     *   , { name: "obj1" }
     * ])
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static CbString(CallbackValue, LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_CB_STRING)
        c.SetCallbackValue(CallbackValue)
        c.SetCompareStringEx(LocaleName, Flags, NlsVersionInfo)
        return c
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a pointer to a null-terminated string.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareStringEx}.
     *
     * If you know your code will be used for a lot of sorting and finding operations, you can
     * improve performance by storing the name / key in a buffer.
     *
     * @example
     * class ImageSamples {
     *     __New(Name, ImageData) {
     *         this.NameBuffer := Buffer(StrPut(Name, "cp1200"))
     *         StrPut(Name, this.NameBuffer, "cp1200")
     *         this.ImageData := ImageData
     *     }
     *     Name => StrGet(this.NameBuffer, "cp1200")
     * }
     *
     * CallbackValue(value) {
     *     return value.NameBuffer.Ptr
     * }
     *
     * c := Container.CbStringPtr(CallbackValue)
     * c.InsertList([
     *     ImageSamples("obj4", data4)
     *   , ImageSamples("obj3", data3)
     *   , ImageSamples("obj1", data1)
     * ])
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static CbStringPtr(CallbackValue, LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_CB_STRINGPTR)
        c.SetCallbackValue(CallbackValue)
        c.SetCompareStringEx(LocaleName, Flags, NlsVersionInfo)
        return c
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareDate}.
     *
     * @example
     * c := Container.Date()
     * c.InsertList([
     *     "20250312122930"
     *   , "20250411122900"
     *   , "20251015091805"
     * ])
     * @
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static Date(UseCompareDateEx := false, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_DATE)
        c.SetCompareDate(UseCompareDateEx)
        return c
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareDateStr}.
     *
     * @example
     * c := Container.DateStr("yyyy-MM-dd HH:mm:ss")
     * c.InsertList([
     *     "2025-03-12 12:29:30"
     *   , "2025-04-11 12:29:00"
     *   , "2025-10-15 09:18:05"
     * ])
     * @
     *
     * @param {String} DateFormat - The format string that {@link Container_Date} uses to parse
     * date strings into usable date values.
     *
     * @param {String} [RegExOptions = ""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static DateStr(DateFormat, RegExOptions := '', Century?, UseCompareDateEx := false, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_DATESTR)
        c.SetCompareDateStr(DateFormat, RegExOptions, Century ?? unset, UseCompareDateEx)
        return c
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a date string in any format recognized
     * by the {@link Container_DateParser} set to {@link Container#DateParser}.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetDateParser}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     *
     * dateParser := Container_DateParser("yyyy-MM-dd HH:mm:ss")
     * c := Container.DateStrFromParser(dateParser)
     * c.InsertList([
     *     "2025-03-12 12:29:30"
     *   , "2025-04-11 12:29:00"
     *   , "2025-10-15 09:18:05"
     * ])
     * @
     *
     * @param {Container_DateParser} DateParserObj - The {@link Container_DateParser}.
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateStr} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static DateStrFromParser(DateParserObj, Century?, UseCompareDateEx := false, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_DATESTR)
        c.SetDateParser(DateParserObj, Century ?? unset, UseCompareDateEx)
        return c
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a date string in any format recognized
     * by the {@link Container_DateParser} set to {@link Container#DateParser}.
     * - **CallbackCompare**: This calls {@link Container.Prototype.DatePreprocess}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     *
     * c := Container.DateValue(CallbackValue, "yyyy-MM-dd HH:mm:ss")
     * ; Use DateInsertList (not InsertList)
     * c.DateInsertList([
     *     { date: "2025-03-12 12:29:30" }
     *   , { date: "2025-04-11 12:29:00" }
     *   , { date: "2025-10-15 09:18:05" }
     * ])
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {String} DateFormat - The format string that {@link Container_Date} uses to parse
     * date strings into usable date values.
     *
     * @param {String} [RegExOptions = ""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static DateValue(CallbackValue, DateFormat, RegExOptions := '', Century?, UseCompareDateEx := false, PropertyName := '__Container_DateValue', Values*) {
        c := this.CbDateStr(CallbackValue, DateFormat, RegExOptions, Century ?? unset, UseCompareDateEx)
        if Values.Length {
            c.Push(Values*)
        }
        c.DatePreprocess(, , PropertyName)
        return c
    }
    /**
     * Converts an existing `Array` object into a `Container` object.
     *
     * @param {Array} Arr - The `Array` object to convert.
     *
     * @returns {Container} - The same `Arr` after changing the base to `Container.Prototype`.
     */
    static FromArray(Arr) {
        ObjSetBase(Arr, this.Prototype)
        return Arr
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: Provided by your code and implements custom logic to return the comparison
     * value.
     *
     * @example
     * CallbackCompare(value1, value2) {
     *     return StrLen(value1) - StrLen(value2)
     * }
     *
     * c := Container.Misc(CallbackCompare)
     *
     * c.InsertList([
     *     "cat"
     *   , "elephant"
     *   , "kale"
     * ])
     * @
     *
     * @param {*} CallbackCompare - The callback to use as a comparator for sorting operations. Sets
     * the property {@link Container#CallbackCompare}.
     *
     * Parameters:
     * 1. A value to be compared.
     * 2. A value to be compared.
     *
     * Returns {Number} - If sorting in ascending order:
     * - If the number is less than zero it indicates the first parameter is less than the second parameter.
     * - If the number is zero it indicates the two parameters are equal.
     * - If the number is greater than zero it indicates the first parameter is greater than the second parameter.
     *
     * Invert the return value (multiply by -1) to sort in descending order.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static Misc(CallbackCompare, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_MISC)
        c.SetCallbackCompare(CallbackCompare)
        return c
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: Not used.
     *
     * @example
     * c := Container.Number()
     * c.InsertList([
     *     298581
     *   , 195801
     *   , 585929
     * ])
     * @
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static Number(Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_NUMBER)
        return c
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * c := Container.String()
     * c.InsertList([
     *     "string4"
     *   , "string3"
     *   , "string1"
     * ])
     * @
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static String(LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_STRING)
        c.SetCompareStringEx(LocaleName, Flags, NlsVersionInfo)
        return c
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * StrBuf(str) {
     *     buf := Buffer(StrPut(str, "cp1200"))
     *     StrPut(str, buf, "cp1200")
     *     return buf
     * }
     *
     * buf1 := StrBuf("string4")
     * buf2 := StrBuf("string3")
     * buf3 := StrBuf("string1")
     *
     * c := Container.StringPtr()
     * c.InsertList([
     *     buf1.Ptr
     *   , buf2.Ptr
     *   , buf3.Ptr
     * ])
     * @
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    static StringPtr(LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0, Values*) {
        c := Container(Values*)
        c.SetSortType(CONTAINER_SORTTYPE_STRINGPTR)
        c.SetCompareStringEx(LocaleName, Flags, NlsVersionInfo)
        return c
    }
    /**
     * Calls {@link https://www.autohotkey.com/docs/v2/lib/StrSplit.htm StrSplit} and converts
     * the return value to a {@link Container}. Calls {@link Container.Prototype.ToString} from
     * the new container.
     *
     * @param {String} Str - The string to pass to {@link https://www.autohotkey.com/docs/v2/lib/StrSplit.htm StrSplit}.
     *
     * @param {String} [Delimiters] - If blank or omitted, each character of the input string will
     * be treated as a separate substring.
     *
     * Otherwise, specify either a single string or an array of strings (case-sensitive), each of
     * which is used to determine where the boundaries between substrings occur. Since the
     * delimiters are not considered to be part of the substrings themselves, they are never
     * included in the returned array. Also, if there is nothing between a pair of delimiters
     * within the input string, the corresponding array element will be blank.
     *
     * For example: "," would divide the string based on every occurrence of a comma. Similarly,
     * `[A_Space, A_Tab]` would create a new array element every time a space or tab is encountered
     * in the input string.
     *
     * @param {String} [OmitChars] - If blank or omitted, no characters will be excluded. Otherwise,
     * specify a list of characters (case-sensitive) to exclude from the beginning and end of each
     * array element. For example, if OmitChars is " `t", spaces and tabs will be removed from the
     * beginning and end (but not the middle) of every element.
     *
     * If Delimiters is blank, OmitChars indicates which characters should be excluded from the array.
     *
     * @param {Integer} [MaxParts = -1] - If omitted, it defaults to -1, which means "no limit".
     * Otherwise, specify the maximum number of substrings to return. If non-zero, the string is
     * split a maximum of MaxParts-1 times and the remainder of the string is returned in the last
     * substring (excluding any leading or trailing OmitChars).
     *
     * @returns {Container}
     */
    static StrSplit(Str, Delimiters?, OmitChars?, MaxParts := -1, LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0) {
        split := StrSplit(Str, Delimiters ?? unset, OmitChars ?? unset, MaxParts)
        ObjSetBase(split, Container.Prototype)
        split.ToString(LocaleName, Flags, NlsVersionInfo)
        return split
    }
    static __Add(Id, Obj) {
        if this.Collection.Has(Id) {
            throw Error('The collection already has an item with that id.', , Id)
        } else {
            this.Collection.Set(Id, Obj)
        }
        ObjRelease(ObjPtr(Obj))
    }
    static __GetUid() {
        loop 100 {
            n := Random(1, 4294967295)
            if !this.Collection.Has(n) {
                return n
            }
        }
        throw Error('Failed to produce a unique id.')
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Compares the input value with a value in the container.
     * @example
     * if index := c.Find(MyValue) {
     *     ; do something
     * } else {
     *     ; Since it didn't return an index, we know `MyValue` is outside of the range of the container.
     *     ; To place the value in order, we must know if it should be placed at the beginning or end.
     *     if c.Compare(MyValue, 1) < 0 {
     *         c.InsertAt(1, MyValue)
     *     } else {
     *         c.Push(MyValue)
     *     }
     * }
     * @
     * @param {*} Value - Any value to compare to one of the values in the container.
     * @param {Integer} Index - The index of the value to compare with `Value`.
     */
    Compare(Value, Index) {
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                return Value - this[Index]
            case CONTAINER_SORTTYPE_STRING:
                if IsNumber(Value) {
                    return this.CallbackCompare.Call(Value, StrPtr(this[Index]))
                } else {
                    return this.CallbackCompare.Call(StrPtr(Value), StrPtr(this[Index]))
                }
            case CONTAINER_SORTTYPE_STRINGPTR:
                if IsNumber(Value) {
                    return this.CallbackCompare.Call(Value, this[Index])
                } else {
                    return this.CallbackCompare.Call(StrPtr(Value), this[Index])
                }
            case CONTAINER_SORTTYPE_DATE:
                return this.CallbackCompare.Call(Value, this[Index])
            case CONTAINER_SORTTYPE_DATESTR:
                if IsNumber(Value) {
                    return this.CallbackCompareValue.Call(Container_Date.FromTimestamp(Value), this[Index])
                } else {
                    return this.CallbackCompare.Call(Value, this[Index])
                }
            case CONTAINER_SORTTYPE_CB_NUMBER:
                if IsNumber(Value) {
                    return Value - this.CallbackValue.Call(this[Index])
                } else {
                    return this.CallbackValue.Call(Value) - this.CallbackValue.Call(this[Index])
                }
            case CONTAINER_SORTTYPE_CB_STRING:
                if IsNumber(Value) {
                    return this.CallbackCompare.Call(Value, StrPtr(this.CallbackValue.Call(this[Index])))
                } else if IsObject(Value) {
                    return this.CallbackCompare.Call(StrPtr(this.CallbackValue.Call(Value)), StrPtr(this.CallbackValue.Call(this[Index])))
                } else {
                    return this.CallbackCompare.Call(StrPtr(Value), StrPtr(this.CallbackValue.Call(this[Index])))
                }
            case CONTAINER_SORTTYPE_CB_STRINGPTR:
                if IsNumber(Value) {
                    return this.CallbackCompare.Call(Value, this.CallbackValue.Call(this[Index]))
                } else if IsObject(Value) {
                    return this.CallbackCompare.Call(this.CallbackValue.Call(Value), this.CallbackValue.Call(this[Index]))
                } else {
                    return this.CallbackCompare.Call(StrPtr(Value), this.CallbackValue.Call(this[Index]))
                }
            case CONTAINER_SORTTYPE_CB_DATE:
                if IsNumber(Value) {
                    return this.CallbackCompare.Call(Value, this.CallbackValue.Call(this[Index]))
                } else {
                    return this.CallbackCompare.Call(this.CallbackValue.Call(Value), this.CallbackValue.Call(this[Index]))
                }
            case CONTAINER_SORTTYPE_CB_DATESTR:
                date1 := ''
                if !IsObject(Value) {
                    if IsNumber(Value) {
                        date1 := Container_Date.FromTimestamp(Value)
                    } else {
                        date1 := this.DateParser.Call(
                            Value
                          , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                        )
                    }
                }
                if date1 {
                    return this.CallbackCompareValue.Call(date1, this.CallbackValue.Call(this[Index]))
                } else {
                    return this.CallbackCompare.Call(this.CallbackValue.Call(Value), this.CallbackValue.Call(this[Index]))
                }
            case CONTAINER_SORTTYPE_MISC:
                return this.CallbackCompare.Call(Value, this[Index])
            case CONTAINER_SORTTYPE_DATEVALUE:
                if IsObject(Value) {
                    if HasProp(Value, '__Container_DateValue') {
                        Value := Value.__Container_DateValue
                    } else {
                        Value := this.DateConvertCb(Value)
                    }
                } else if !IsNumber(Value) {
                    Value := this.DateConvert(Value)
                }
                return Value - this[Index].__Container_DateValue
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Removes all unset indices, shifting the values to the left.
     */
    Condense(IndexStart := 1, IndexEnd := this.Length) {
        IndexStart--
        loop IndexEnd - IndexStart {
            if !this.Has(++IndexStart) {
                this.RemoveAt(IndexStart--)
            }
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Creates a new {@link Container}, copying the values of any own properties of this object.
     * The base object of the new {@link Container} is also set to the base of this object.
     *
     * The new container is empty. To also fill the container with the same values, use the built-in
     * `Array.Prototype.Clone` method, e.g. `containerObj.Clone()`.
     */
    Copy() {
        c := Container()
        for prop in this.OwnProps() {
            c.DefineProp(prop, this.GetOwnPropDesc(prop))
        }
        ObjSetBase(c, this.Base)
        return c
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * {@link Container#DateConvert} is defined from the body of {@link Container.Prototype.DatePreprocess}.
     * This converts a string value to a value that can be passed to any of the binary search methods.
     *
     * @example
     * c := Container(
     *     { Date: "3/1/25 12:01" }
     *   , { Date: "3/1/25 12:15" }
     *   , { Date: "3/1/25 9:17" }
     *   , { Date: "3/1/25 14:25" }
     * )
     * c.SetDateCompareDateStr("M/d/yy H:mm")
     * c.SetSortType(CONTAINER_SORTTYPE_CB_DATESTR)
     * c.SetCallbackValue((value) => value.Date)
     * c.DatePreprocess()
     * ; After calling c.DatePreprocess, I can no longer search for values using strings
     * ; like "3/1/25 9:17", so I have to convert the date string to a date value
     * dateValue := c.DateConvert("3/1/25 9:17")
     * index := c.Find(dateValue)
     * OutputDebug(index "`n") ; 1
     * @
     *
     * @param {*} Value - The value to convert to an integer.
     */
    DateConvert(Value) {
        throw Error(A_ThisFunc ' must be overridden by ``Container.Prototype.DatePreprocess``.')
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * {@link Container#DateConvertCb} is defined from the body of {@link Container.Prototype.DatePreprocess}.
     * This converts an object value to a value that can be passed to any of the binary search methods.
     *
     * @example
     * c := Container(
     *     { Date: "3/1/25 12:01" }
     *   , { Date: "3/1/25 12:15" }
     *   , { Date: "3/1/25 9:17" }
     *   , { Date: "3/1/25 14:25" }
     * )
     * c.SetDateCompareDateStr("M/d/yy H:mm")
     * c.SetSortType(CONTAINER_SORTTYPE_CB_DATESTR)
     * c.SetCallbackValue((value) => value.Date)
     * c.DatePreprocess()
     * ; After calling c.DatePreprocess, I can no longer search for values using strings
     * ; like "3/1/25 9:17", so I have to convert the date string to a date value
     * dateValue := c.DateConvert({ Date: "3/1/25 9:17" })
     * index := c.Find(dateValue)
     * OutputDebug(index "`n") ; 1
     * ; This is unnecessary for values taken directly from the container
     * ; because the values in the container are processed and can be
     * ; used directly.
     * valueToFind := c[2]
     * index := c.Find(valueToFind)
     * OutputDebug(index "`n") ; 2
     * @
     *
     * @param {*} Value - The value to convert to an integer.
     */
    DateConvertCb(Value) {
        throw Error(A_ThisFunc ' must be overridden by ``Container.Prototype.DatePreprocess``.')
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Inserts a value in order. See {@link Container.Prototype.DatePreprocess} for more
     * information.
     *
     * @param {*} Value - The value.
     *
     * @returns {Integer} - The index at which it was inserted.
     */
    DateInsert(Value) {
        this.CallbackDateInsert.Call(Value)
        return this.Insert(Value)
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Inserts a value in order if the value does not exist in the container. See
     * {@link Container.Prototype.DatePreprocess} for more information.
     *
     * @param {*} Value - The value.
     *
     * @returns {Integer} - The index at which it was inserted.
     */
    DateInsertIfAbsent(Value) {
        this.CallbackDateInsert.Call(Value)
        return this.InsertIfAbsent(Value)
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Inserts a value in order if the value does not exist in the container. See
     * {@link Container.Prototype.DatePreprocess} for more information.
     *
     * @param {*} Value - The value.
     *
     * @returns {Integer} - The index at which it was inserted.
     */
    DateInsertIfAbsentSparse(Value) {
        this.CallbackDateInsert.Call(Value)
        return this.InsertIfAbsentSparse(Value)
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Inserts values in order. See {@link Container.Prototype.DatePreprocess} for more information.
     *
     * @param {*} Values - One or more values to insert.
     */
    DateInsertList(Values) {
        if Values is Array {
            callbackDateInsert := this.CallbackDateInsert
            for value in Values {
                callbackDateInsert.Call(value)
                this.Insert(value)
            }
        } else {
            this.CallbackDateInsert.Call(Values)
            this.Insert(Values)
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Inserts values in order. See {@link Container.Prototype.DatePreprocess} for more information.
     *
     * @param {*} Values - One or more values to insert.
     */
    DateInsertListSparse(Values) {
        if Values is Array {
            callbackDateInsert := this.CallbackDateInsert
            loop Values.Length {
                if Values.Has(A_Index) {
                    callbackDateInsert.Call(Values[A_Index])
                    this.InsertSparse(Values[A_Index])
                }
            }
        } else {
            this.CallbackDateInsert.Call(Values)
            this.InsertSparse(Values)
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Inserts a value in order. See {@link Container.Prototype.DatePreprocess} for more
     * information.
     *
     * @param {*} Value - The value.
     *
     * @returns {Integer} - The index at which it was inserted.
     */
    DateInsertSparse(Value) {
        this.CallbackDateInsert.Call(Value)
        return this.InsertSparse(Value)
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * {@link Container.Prototype.DatePreprocess} iterates the values in the container and sets
     * a property with an integer representing the number of seconds between 01/01/0001 00:00:00 and
     * the date associated with that value. This allows sorting operations to be performed with
     * simple arithmetic, significantly improving performance.
     *
     * There are two options for adding values to the container after
     * {@link Container.Prototype.DatePreprocess} has been called:
     * - Call {@link Container.Prototype.DateInsert} or {@link Container.Prototype.DateInsertSparse}
     *   to add one value to an already-sorted container.
     * - Add one or more values to the end of the container, then call
     *   {@link Container.Prototype.DateUpdate} specifying the range.
     *
     * To use {@link Container.Prototype.DatePreprocess}, the following must be true:
     * - The values in the container are objects.
     * - Property {@link Container#SortType} is CONTAINER_SORTTYPE_CB_DATE or CONTAINER_SORTTYPE_CB_DATESTR.
     * - Property {@link Container#CallbackValue} is set with a function that will return the date
     *   string, or your code passes a function to parameter `CallbackValue`.
     *
     * If {@link Container#SortType} is CONTAINER_SORTTYPE_CB_DATESTR, then there is one additional
     * requirement:
     * - Your code has previously called {@link Container.Prototype.SetCompareDateStr}, or your
     *   code passes a {@link Container_DateParser} to parameter `DateParserObj`.
     *
     * After calling {@link Container.Prototype.DatePreprocess}, your code has a range of options for
     * kinds of values to pass to the methods that implement a binary search. You can pass
     * - A date string that is in the format readable by {@link Container#DateParser}.
     * - An object that returns a date string when passed to {@link Container#CallbackValue}.
     * - An object that has the property `PropertyName` (i.e. an object in the container that has
     *   been processed by {@link Container.Prototype.DatePreprocess} or
     *   {@link Container.Prototype.DateUpdate}.
     * - A date value number, e.g. a value returned by {@link Container#DateConvert} or
     *   {@link Container#DateConvertCb}.
     *
     * The following are some additional actions taken by {@link Container.Prototype.DatePreprocess}:
     * - Sets property {@link Container#CallbackDateInsert} with a function that sets the property
     *   with the date value.
     * - Sets property {@link Container#DateConvert} with a function that returns the date
     *   value from an input string.
     * - Sets property {@link Container#DateConvertCb} with a function that returns the date
     *   value from an input object.
     * - Deletes property {@link Container#CallbackCompare} if it exists.
     * - If the sort type is `CONTAINER_SORTTYPE_CB_DATESTR ` and if a value is passed to
     *   `DateParserObj`, property {@link Container#__DateParser} is set with that value.
     *
     * If the value of `PropertyName` is the default "__Container_DateValue":
     * - Sets the value of property {@link Container#SortType} to CONTAINER_SORTTYPE_DATEVALUE.
     * - Sets the value of property {@link Container#CallbackValue} to{@link Container_CallbackValue_DateValue}.
     *
     * If the value of `PropertyName` is something other than the default:
     * - Sets the value of property {@link Container#SortType} to CONTAINER_SORTTYPE_CB_NUMBER.
     * - Sets the value of property {@link Container#CallbackValue} to {@link Container_CallbackValue_DateValueCustom}.
     *
     * @param {*} [CallbackValue] - The `Func` or callable object that is called to get the date
     * string associated with each object. This is required if property {@link Container#CallbackValue}
     * is not set.
     *
     * @param {Container_DateParser} [DateParserObj] - The {@link Container_DateParser} that will
     * be used to produce the date value. This is required if property {@link Container#__DateParser}
     * is not set. This value is set to property {@link Container#__DateParser}.
     *
     * This is ignored if {@link Container#SortType} is not CONTAINER_SORTTYPE_CB_DATESTR.
     *
     * @param {String} [PropertyName = "__Container_DateValue"] - The name of the property that
     * is set with the date value. {@link Container} is optimized to use the default name. Changing
     * the name is valid but reduces performance.
     */
    DatePreprocess(CallbackValue?, DateParserObj?, PropertyName := '__Container_DateValue') {
        if !IsSet(CallbackValue) {
            CallbackValue := this.CallbackValue
        }
        if this.SortType = CONTAINER_SORTTYPE_CB_DATE {
            Fn := ObjBindMethod(Container_Date, 'FromTimestamp')
        } else if this.SortType = CONTAINER_SORTTYPE_CB_DATESTR {
            Fn := DateParserObj ?? this.__DateParser
        } else {
            throw PropertyError('Property "SortType" must be either CONTAINER_SORTTYPE_CB_DATE or CONTAINER_SORTTYPE_CB_DATESTR.')
        }
        this.CallbackDateInsert := Container_CallbackDateInsert.Bind(PropertyName, Fn, CallbackValue)
        this.DefineProp('DateConvert', { Call: Container_ConvertDate.Bind(Fn) })
        this.DefineProp('DateConvertCb', { Call: Container_ConvertDateCb.Bind(Fn, CallbackValue) })
        i := 0
        loop this.Length {
            if this.Has(++i) {
                this[i].DefineProp(PropertyName, { Value: Fn(CallbackValue(this[i])).TotalSeconds })
            }
        }
        if this.HasOwnProp('CallbackCompare') {
            this.DeleteProp('CallbackCompare')
        }
        if PropertyName = '__Container_DateValue' {
            this.SortType := CONTAINER_SORTTYPE_DATEVALUE
            this.CallbackValue := Container_CallbackValue_DateValue
        } else {
            this.SortType := CONTAINER_SORTTYPE_CB_NUMBER
            this.CallbackValue := Container_CallbackValue_DateValueCustom.Bind(PropertyName)
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * For each value in the indicated range, sets a property with an integer representing the number
     * of seconds between 01/01/0001 00:00:00 and the date associated with that value.
     *
     * {@link Container.Prototype.DateUpdate} can only be called after
     * {@link Container.Prototype.DatePreprocess} has been called at least once.
     *
     * @param {Integer} [IndexStart = 1] - The start index.
     *
     * @param {Integer} [IndexEnd = this.Length] - The end index.
     */
    DateUpdate(IndexStart := 1, IndexEnd := this.Length) {
        Fn := this.CallbackDateInsert
        IndexStart--
        loop IndexEnd - IndexStart {
            if this.Has(++IndexStart) {
                Fn(this[IndexStart])
            }
        }
    }
    /**
     * @description - Recursively copies the {@link Container} object's properties onto a new object. For all new objects,
     * `ObjDeepClone` attempts to set the new object's base to the same base as the subject. For objects
     * that inherit from `Map` or `Array`, clones the items in addition to the properties.
     * @param {*} Self - The object to be deep cloned. If calling this method from an instance,
     * exclude this parameter.
     * @param {Map} [ConstructorParams] - A map of constructor parameters, where the key is the class
     * name (use `ObjToBeCloned.__Class` as the key), and the value is an array of values that will be
     * passed to the constructor. Using `ConstructorParams` can allow `ObjDeepClone` to create correctly-
     * typed objects in cases where normally AHK will not allow setting the type using `ObjSetBase()`.
     * @param {Integer} [Depth = 0] - The maximum depth to clone. A value equal to or less than 0 will
     * result in no limit.
     * @returns {*}
     */
    DeepClone(ConstructorParams?, Depth := 0) {
        GetTarget := IsSet(ConstructorParams) ? _GetTarget2 : _GetTarget1
        Result := GetTarget(this)
        PtrList := Map(ObjPtr(this), Result)
        CurrentDepth := 0
        return _Recurse(Result, this)

        _Recurse(Target, Subject) {
            CurrentDepth++
            for Prop in Subject.OwnProps() {
                Desc := Subject.GetOwnPropDesc(Prop)
                if Desc.HasOwnProp('Value') {
                    Target.DefineProp(Prop, { Value: IsObject(Desc.Value) ? _ProcessValue(Desc.Value) : Desc.Value })
                } else {
                    Target.DefineProp(Prop, Desc)
                }
            }
            if Target is Array {
                Target.Length := Subject.Length
                for item in Subject {
                    if IsSet(item) {
                        Target[A_Index] := IsObject(item) ? _ProcessValue(item) : item
                    }
                }
            } else if Target is Map {
                Target.Capacity := Subject.Capacity
                for Key, Val in Subject {
                    if IsObject(Key) {
                        Target.Set(_ProcessValue(Key), IsObject(Val) ? _ProcessValue(Val) : Val)
                    } else {
                        Target.Set(Key, IsObject(Val) ? _ProcessValue(Val) : Val)
                    }
                }
            }
            CurrentDepth--
            return Target
        }
        _GetTarget1(Subject) {
            try {
                Target := GetObjectFromString(Subject.__Class)()
            } catch {
                if Subject Is Map {
                    Target := Map()
                } else if Subject is Array {
                    Target := Array()
                } else {
                    Target := Object()
                }
            }
            try {
                ObjSetBase(Target, Subject.Base)
            }
            return Target
        }
        _GetTarget2(Subject) {
            if ConstructorParams.Has(Subject.__Class) {
                Target := GetObjectFromString(Subject.__Class)(ConstructorParams.Get(Subject.__Class)*)
            } else {
                try {
                    Target := GetObjectFromString(Subject.__Class)()
                } catch {
                    if Subject Is Map {
                        Target := Map()
                    } else if Subject is Array {
                        Target := Array()
                    } else {
                        Target := Object()
                    }
                }
                try {
                    ObjSetBase(Target, Subject.Base)
                }
            }
            return Target
        }
        _ProcessValue(Val) {
            if Val is ComValue {
                return Val
            }
            if PtrList.Has(ObjPtr(Val)) {
                return PtrList.Get(ObjPtr(Val))
            }
            if CurrentDepth == Depth {
                return Val
            } else {
                PtrList.Set(ObjPtr(Val), _Target := GetTarget(Val))
                return _Recurse(_Target, Val)
            }
        }
        GetObjectFromString(Path) {
            Split := StrSplit(Path, '.')
            if !IsSet(%Split[1]%)
                return
            OutObj := %Split[1]%
            i := 1
            while ++i <= Split.Length {
                if !OutObj.HasOwnProp(Split[i])
                    return
                OutObj := OutObj.%Split[i]%
            }
            return OutObj
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Calls {@link Container.Prototype.FindAll} to find a value in the container. If the
     * value is found, deletes each instance of the value, leaving the indices unset.
     *
     * @param {*} Value - The value to find and delete.
     *
     * @param {VarRef} [OutList] - A variable that will receive a {@link Container} containing
     * the deleted values. The {@link Container} is created by calling {@link Container.Prototype.Copy}.
     * You must set the variable with a nonzero value before calling {@link Container.Prototype.DeleteAll}
     * to direct the function to collect the values.
     *
     * @example
     * ; Assume `c` is a correctly prepared `Container`.
     * index := c.DeleteAll(1000, &list := true)
     * for v in list {
     *     ; do something
     * }
     * @
     *
     * @returns {Integer} - If the value is found, the first index from left-to-right where the value
     * was located. Else, 0.
     */
    DeleteAll(Value, &OutList?) {
        if index := this.FindAll(Value, &lastIndex) {
            i := index - 1
            if IsSet(OutList) && OutList {
                OutList := this.Copy()
                loop lastIndex - i {
                    OutList.Push(this.Delete(++i))
                }
            } else {
                loop lastIndex - i {
                    this.Delete(++i)
                }
            }
            return index
        }
        return 0
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Calls {@link Container.Prototype.FindAllSparse} to find a value in the container. If the
     * value is found, deletes each instance of the value, leaving the indices unset.
     *
     * @param {*} Value - The value to find and delete.
     *
     * @param {VarRef} [OutList] - A variable that will receive a {@link Container} containing
     * the deleted values. The {@link Container} is created by calling {@link Container.Prototype.Copy}.
     * You must set the variable with a nonzero value before calling
     * {@link Container.Prototype.DeleteAllSparse} to direct the function to collect the values.
     *
     * @example
     * ; Assume `c` is a correctly prepared `Container`.
     * index := c.DeleteAllSparse(1000, &list := true)
     * for v in list {
     *     ; do something
     * }
     * @
     *
     * @returns {Integer} - If the value is found, the first index from left-to-right where the value
     * was located. Else, 0.
     */
    DeleteAllSparse(Value, &OutList?) {
        if index := this.FindAllSparse(Value, &lastIndex) {
            i := index - 1
            if IsSet(OutList) && OutList {
                OutList := this.Copy()
                loop lastIndex - i {
                    if this.Has(++i) {
                        OutList.Push(this.Delete(i))
                    }
                }
            } else {
                loop lastIndex - i {
                    if this.Has(++i) {
                        this.Delete(i)
                    }
                }
            }
            return index
        }
        return 0
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Calls {@link Container.Prototype.Find} to find a value in the container. If the
     * value is found, deletes the value, leaving the index unset. If the value is not found, throws
     * an error.
     *
     * @param {*} Value - The value to find and delete.
     *
     * @param {VarRef} [OutValue] - A variable that will receive the found value.
     *
     * @returns {Integer} - If the value is found, the index the value was located.
     *
     * @throws {UnsetItemError} - "Value not found."
     */
    DeleteValue(Value, &OutValue?) {
        if index := this.Find(Value, &OutValue) {
            this.Delete(index)
            return index
        } else {
            throw UnsetItemError('Value not found.', -1, IsObject(Value) ? '{ ' Type(Value) ' }' : Value)
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Calls {@link Container.Prototype.FindSparse} to find a value in the container. If the
     * value is found, deletes the value, leaving the index unset.
     *
     * @param {*} Value - The value to find and delete.
     *
     * @param {VarRef} [OutValue] - A variable that will receive the found value.
     *
     * @returns {Integer} - If the value is found, the index the value was located. Else, 0.
     */
    DeleteValueIf(Value, &OutValue?) {
        if index := this.Find(Value, &OutValue) {
            this.Delete(index)
            return index
        } else {
            return 0
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Calls {@link Container.Prototype.FindSparse} to find a value in the container. If the
     * value is found, deletes the value, leaving the index unset.
     *
     * @param {*} Value - The value to find and delete.
     *
     * @param {VarRef} [OutValue] - A variable that will receive the found value.
     *
     * @returns {Integer} - If the value is found, the index the value was located. Else, 0.
     */
    DeleteValueIfSparse(Value, &OutValue?) {
        if index := this.FindSparse(Value, &OutValue) {
            this.Delete(index)
            return index
        } else {
            return 0
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Calls {@link Container.Prototype.FindSparse} to find a value in the container. If the
     * value is found, deletes the value, leaving the index unset. If the value is not found, throws
     * an error.
     *
     * @param {*} Value - The value to find and delete.
     *
     * @param {VarRef} [OutValue] - A variable that will receive the found value.
     *
     * @returns {Integer} - If the value is found, the index the value was located.
     *
     * @throws {UnsetItemError} - "Value not found."
     */
    DeleteValueSparse(Value, &OutValue?) {
        if index := this.FindSparse(Value, &OutValue) {
            this.Delete(index)
            return index
        } else {
            throw UnsetItemError('Value not found.', -1, IsObject(Value) ? '{ ' Type(Value) ' }' : Value)
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes. When unset indices are encountered, the variable that receives the
     * item and the variable that receives the item's sort value are both unset.
     *
     * @param {Integer} VarCount - The number of variables in the for-loop.
     *
     * For sort types CONTAINER_SORTTYPE_CB_DATE, CONTAINER_SORTTYPE_CB_DATESTR, CONTAINER_SORTTYPE_CB_NUMBER,
     * CONTAINER_SORTTYPE_CB_STRING, CONTAINER_SORTTYPE_CB_STRINGPTR, and CONTAINER_SORTTYPE_DATEVALUE,
     * the behavior of {@link Container.Prototype.Enum} can be different than the others.
     * - When called in a 1-variable `for` loop, e.g. `for value in ContainerObj.Enum(1) { ... }`,
     *   the variable receives each item consecutively, same as the standard `Array.Prototype.__Enum`.
     * - When called in a 2-variable `for` loop, e.g. `for name, value in ContainerObj.Enum(2) { ... }`,
     *   the first variable receives the value returned by {@link Container#CallbackValue} for the
     *   current item, and the second variable receives the item, similar to a map object's key and
     *   value.
     * @example
     * CallbackValue(value) {
     *     return value.name
     * }
     * c := Container.CbString(CallbackValue)
     * c.InsertList([
     *     { name: "obj3" }
     *   , { name: "obj2" }
     *   , { name: "obj4" }
     * ])
     *
     * for name, obj in c.Enum(2) {
     *     OutputDebug(name " - " Type(obj) "`n")
     * }
     * @
     *
     * - When called in a 3-variable `for` loop, e.g.
     *   `for index, name, value in ContainerObj.Enum(2) { ... }`, the first variable receives the
     *   index, the second variable receives the value returned by {@link Container#CallbackValue} for
     *   the current item, and the third variable receives the item.
     * @example
     * CallbackValue(value) {
     *     return value.name
     * }
     * c := Container.CbString(CallbackValue)
     * c.InsertList([
     *     { name: "obj3" }
     *   , { name: "obj2" }
     *   , { name: "obj4" }
     * ])
     *
     * for index, name, obj in c.Enum(3) {
     *     OutputDebug(index ": " name " - " Type(obj) "`n")
     * }
     * @
     *
     * For all other sort types, the behavior of {@link Container.Prototype.Enum} is the same
     * as for standad arrays:
     * - When called in a 1-variable `for` loop, the variable receives each item consecutively.
     * - When called in a 2-variable `for` loop, the first variable receives the index and the
     *   second variable receives the item.
     *
     * @returns {Func|Enumerator}
     */
    Enum(VarCount) {
        if VarCount == 1 {
            return Array.Prototype.__Enum.Call(this, VarCount)
        } else if VarCount == 2 {
            switch this.SortType, 0 {
                case CONTAINER_SORTTYPE_CB_DATE
                , CONTAINER_SORTTYPE_CB_DATESTR
                , CONTAINER_SORTTYPE_CB_NUMBER
                , CONTAINER_SORTTYPE_CB_STRING
                , CONTAINER_SORTTYPE_CB_STRINGPTR
                , CONTAINER_SORTTYPE_DATEVALUE:
                    callbackValue := this.CallbackValue
                    end := this.Length
                    start := 0
                    return _Enum2
                default: return Array.Prototype.__Enum.Call(this, VarCount)
            }
        } else {
            switch this.SortType, 0 {
                case CONTAINER_SORTTYPE_CB_DATE
                , CONTAINER_SORTTYPE_CB_DATESTR
                , CONTAINER_SORTTYPE_CB_NUMBER
                , CONTAINER_SORTTYPE_CB_STRING
                , CONTAINER_SORTTYPE_CB_STRINGPTR
                , CONTAINER_SORTTYPE_DATEVALUE:
                    callbackValue := this.CallbackValue
                    end := this.Length
                    start := 0
                    return _Enum3
                default: return Array.Prototype.__Enum.Call(this, VarCount)
            }
        }

        _Enum2(&key, &value) {
            if ++start > end {
                return 0
            }
            if this.Has(start) {
                key := callbackValue(this[start])
                value := this[start]
            } else {
                key := value := unset
            }
            return 1
        }
        _Enum3(&index, &key, &value) {
            if ++start > end {
                return 0
            }
            index := start
            if this.Has(start) {
                key := callbackValue(this[start])
                value := this[start]
            } else {
                key := value := unset
            }
            return 1
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Enumerates a subset of the items in the container.
     *
     * @example
     * CallbackValue(value) {
     *     return value.name
     * }
     * c := Container.CbString(CallbackValue)
     * c.InsertList([
     *     { name: "obj3" }
     *   , { name: "obj2" }
     *   , { name: "obj4" }
     *   , { name: "obj1" }
     *   , { name: "obj5" }
     * ])
     *
     * for index, name, obj in c.EnumRange(3, "obj2", "obj4") {
     *     OutputDebug(index ": " name " - " Type(obj) "`n")
     * }
     * @
     *
     * `ValueStart` and `ValueEnd` do not need to exist in the container.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     * c := Container.CbDateStr(CallbackValue, "yyyy-MM-dd")
     * c.InsertList([
     *     { date: "2025-05-02" }
     *   , { date: "2025-05-06" }
     *   , { date: "2025-04-19" }
     *   , { date: "2025-05-19" }
     *   , { date: "2025-04-30" }
     *   , { date: "2025-06-02" }
     * ])
     * for index, date, obj in c.EnumRange(3, "2025-05-01", "2025-05-31") {
     *     OutputDebug(index ": " date " - " Type(obj) "`n")
     * }
     * @
     *
     * For sort types CONTAINER_SORTTYPE_CB_DATE, CONTAINER_SORTTYPE_CB_DATESTR, CONTAINER_SORTTYPE_CB_NUMBER,
     * CONTAINER_SORTTYPE_CB_STRING, CONTAINER_SORTTYPE_CB_STRINGPTR, and CONTAINER_SORTTYPE_DATEVALUE,
     * the behavior of {@link Container.Prototype.EnumRange} is different than the others.
     * - When called in a 1-variable `for` loop, the variable receives each item consecutively.
     * - When called in a 2-variable `for` loop, the first variable receives the value returned by
     *   `ContainerObj.CallbackValue` for the current item, and the second variable receives the
     *   item, similar to a map object's key and value.
     * - When called in a 3-variable `for` loop, the first variable receives the index, the second
     *   variable receives the value returned by `ContainerObj.CallbackValue` for the current item,
     *   and the third variable receives the item.
     *
     * For all other sort types:
     * - When called in a 1-variable `for` loop, the variable receives each item consecutively.
     * - When called in a 2-variable `for` loop, the first variable receives the index and the
     *   second variable receives the item.
     * - When called in a 3-variable `for` loop, a `ValueError` is thrown.
     *
     * @param {Integer} [VarCout = 1] - One of the following:
     * - 1 : Use when calling {@link Container.Prototype.EnumRange} in a 1-variable `for` loop.
     * - 2 : Use when calling {@link Container.Prototype.EnumRange} in a 2-variable `for` loop.
     * - 3 : Use when calling {@link Container.Prototype.EnumRange} in a 3-variable `for` loop.
     *
     * @param {*} [ValueStart] - The value which will be passed to {@link Container.Prototype.FindInequality}
     * to evaluate the start index. If unset, the start index is 1.
     *
     * @param {*} [ValueEnd] - The value which will be passed to {@link Container.Prototype.FindInequality}
     * to evaluate the end index. If unset, the end index is the value of `this.Length`.
     *
     * @returns {Func} - The enumerator function.
     *
     * @throws {ValueError} - "The start index must be less than the end index."
     *
     * @throws {ValueError} - "This container's sort type cannot use a three-variable `for` loop."
     */
    EnumRange(VarCount := 1, ValueStart?, ValueEnd?) {
        if IsSet(ValueStart) {
            if start := this.FindInequality(ValueStart) {
                start--
            }
        } else {
            start := 0
        }
        if IsSet(ValueEnd) {
            end := this.FindInequality(ValueEnd, , '<=') || this.Length
        } else {
            end := this.Length
        }
        if start >= end {
            ; 1 is subtracted from `start`, or `start == 0`, so `start == end` really means `start + 1 == end`.
            throw ValueError('The start index must be less than the end index.', , 'Start: ' (start + 1) '; end: ' end)
        }
        if VarCount == 1 {
            return _Enum1
        } else if VarCount == 2 {
            switch this.SortType, 0 {
                case CONTAINER_SORTTYPE_CB_DATE
                , CONTAINER_SORTTYPE_CB_DATESTR
                , CONTAINER_SORTTYPE_CB_NUMBER
                , CONTAINER_SORTTYPE_CB_STRING
                , CONTAINER_SORTTYPE_CB_STRINGPTR
                , CONTAINER_SORTTYPE_DATEVALUE:
                    callbackValue := this.CallbackValue
                    return _EnumCb2
                default: return _Enum2
            }
        } else {
            switch this.SortType, 0 {
                case CONTAINER_SORTTYPE_CB_DATE
                , CONTAINER_SORTTYPE_CB_DATESTR
                , CONTAINER_SORTTYPE_CB_NUMBER
                , CONTAINER_SORTTYPE_CB_STRING
                , CONTAINER_SORTTYPE_CB_STRINGPTR
                , CONTAINER_SORTTYPE_DATEVALUE:
                    callbackValue := this.CallbackValue
                    return _EnumCb3
                default: throw ValueError('This container`'s sort type cannot use a three-variable ``for`` loop.', , Container_IndexToSymbol(this.SortType).symbol)
            }
        }

        _Enum1(&value) {
            if ++start > end {
                return 0
            }
            value := this[start]
            return 1
        }
        _Enum2(&index, &value) {
            if ++start > end {
                return 0
            }
            index := start
            value := this[start]
            return 1
        }
        _EnumCb2(&key, &value) {
            if ++start > end {
                return 0
            }
            key := callbackValue(this[start])
            value := this[start]
            return 1
        }
        _EnumCb3(&index, &key, &value) {
            if ++start > end {
                return 0
            }
            index := start
            key := callbackValue(this[start])
            value := this[start]
            return 1
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes. When unset indices are encountered, the variable that receives the
     * item and the variable that receives the item's sort value are both unset.
     *
     * Enumerates a subset of the items in the container.
     *
     * @example
     * CallbackValue(value) {
     *     return value.name
     * }
     * c := Container.CbString(CallbackValue)
     * c.InsertList([
     *     { name: "obj3" }
     *   , { name: "obj2" }
     *   , { name: "obj4" }
     *   , { name: "obj1" }
     *   , { name: "obj5" }
     * ])
     * c.DeleteValue("obj4")
     *
     * for index, name, obj in c.EnumRangeSparse(3, "obj2", "obj5") {
     *     if IsSet(obj) {
     *          OutputDebug(index ": " name " - " Type(obj) "`n")
     *     } else {
     *          OutputDebug(index ": unset`n")
     *     }
     * }
     * @
     *
     * `ValueStart` and `ValueEnd` do not need to exist in the container.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     * c := Container.CbDateStr(CallbackValue, "yyyy-MM-dd")
     * c.InsertList([
     *     { date: "2025-05-02" }
     *   , { date: "2025-05-06" }
     *   , { date: "2025-04-19" }
     *   , { date: "2025-05-19" }
     *   , { date: "2025-04-30" }
     *   , { date: "2025-06-02" }
     * ])
     * for index, date, obj in c.EnumRangeSparse(3, "2025-05-01", "2025-05-31") {
     *     OutputDebug(index ": " date " - " Type(obj) "`n")
     * }
     * @
     *
     * For sort types CONTAINER_SORTTYPE_CB_DATE, CONTAINER_SORTTYPE_CB_DATESTR, CONTAINER_SORTTYPE_CB_NUMBER,
     * CONTAINER_SORTTYPE_CB_STRING, CONTAINER_SORTTYPE_CB_STRINGPTR, and CONTAINER_SORTTYPE_DATEVALUE,
     * the behavior of {@link Container.Prototype.EnumRangeSparse} is different than the others.
     * - When called in a 1-variable `for` loop, the variable receives each item consecutively.
     * - When called in a 2-variable `for` loop, the first variable receives the value returned by
     *   `ContainerObj.CallbackValue` for the current item, and the second variable receives the
     *   item, similar to a map object's key and value.
     * - When called in a 3-variable `for` loop, the first variable receives the index, the second
     *   variable receives the value returned by `ContainerObj.CallbackValue` for the current item,
     *   and the third variable receives the item.
     *
     * For all other sort types:
     * - When called in a 1-variable `for` loop, the variable receives each item consecutively.
     * - When called in a 2-variable `for` loop, the first variable receives the index and the
     *   second variable receives the item.
     * - When called in a 3-variable `for` loop, a `ValueError` is thrown.
     *
     * @param {Integer} [VarCout = 1] - One of the following:
     * - 1 : Use when calling {@link Container.Prototype.EnumRangeSparse} in a 1-variable `for` loop.
     * - 2 : Use when calling {@link Container.Prototype.EnumRangeSparse} in a 2-variable `for` loop.
     * - 3 : Use when calling {@link Container.Prototype.EnumRangeSparse} in a 3-variable `for` loop.
     *
     * @param {*} [ValueStart] - The value which will be passed to {@link Container.Prototype.FindInequalitySparse}
     * to evaluate the start index. If unset, the start index is 1.
     *
     * @param {*} [ValueEnd] - The value which will be passed to {@link Container.Prototype.FindInequalitySparse}
     * to evaluate the end index. If unset, the end index is the value of `this.Length`.
     *
     * @returns {Func} - The enumerator function.
     *
     * @throws {ValueError} - "The start index must be less than the end index."
     *
     * @throws {ValueError} - "This container's sort type cannot use a three-variable `for` loop."
     */
    EnumRangeSparse(VarCount := 1, ValueStart?, ValueEnd?) {
        if IsSet(ValueStart) {
            if start := this.FindInequalitySparse(ValueStart) {
                start--
            }
        } else {
            start := 0
        }
        if IsSet(ValueEnd) {
            end := this.FindInequalitySparse(ValueEnd, , '<=') || this.Length
        } else {
            end := this.Length
        }
        if start >= end {
            ; 1 is subtracted from `start`, or `start == 0`, so `start == end` really means `start + 1 == end`.
            throw ValueError('The start index must be less than the end index.', , 'Start: ' (start + 1) '; end: ' end)
        }
        if VarCount == 1 {
            return _Enum1
        } else if VarCount == 2 {
            switch this.SortType, 0 {
                case CONTAINER_SORTTYPE_CB_DATE
                , CONTAINER_SORTTYPE_CB_DATESTR
                , CONTAINER_SORTTYPE_CB_NUMBER
                , CONTAINER_SORTTYPE_CB_STRING
                , CONTAINER_SORTTYPE_CB_STRINGPTR
                , CONTAINER_SORTTYPE_DATEVALUE:
                    callbackValue := this.CallbackValue
                    return _EnumCb2
                default: return _Enum2
            }
        } else {
            switch this.SortType, 0 {
                case CONTAINER_SORTTYPE_CB_DATE
                , CONTAINER_SORTTYPE_CB_DATESTR
                , CONTAINER_SORTTYPE_CB_NUMBER
                , CONTAINER_SORTTYPE_CB_STRING
                , CONTAINER_SORTTYPE_CB_STRINGPTR
                , CONTAINER_SORTTYPE_DATEVALUE:
                    callbackValue := this.CallbackValue
                    return _EnumCb3
                default: throw ValueError('This container`'s sort type cannot use a three-variable ``for`` loop.', , Container_IndexToSymbol(this.SortType).symbol)
            }
        }

        _Enum1(&value) {
            if ++start > end {
                return 0
            }
            if this.Has(start) {
                value := this[start]
            } else {
                value := unset
            }
            return 1
        }
        _Enum2(&index, &value) {
            if ++start > end {
                return 0
            }
            index := start
            if this.Has(start) {
                value := this[start]
            } else {
                value := unset
            }
            return 1
        }
        _EnumCb2(&key, &value) {
            if ++start > end {
                return 0
            }
            if this.Has(start) {
                key := callbackValue(this[start])
                value := this[start]
            } else {
                key := value := unset
            }
            return 1
        }
        _EnumCb3(&index, &key, &value) {
            if ++start > end {
                return 0
            }
            index := start
            if this.Has(start) {
                key := callbackValue(this[start])
                value := this[start]
            } else {
                key := value := unset
            }
            return 1
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Iterates the values in the container, passing each value to a callback function. If the callback
     * function returns nonzero, {@link Container.Prototype.Every} will return 1 immediately.
     * If the callback function always returns 0 or an empty string, {@link Container.Prototype.Every}
     * will return 0 after processing every value.
     *
     * @param {*} Callback - If `ThisArg` is set, the function can accept two to four parameters.
     *
     * Parameters:
     * - `ThisArg` - the hidden `this` parameter.
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * If `ThisArg` is unset, the function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: zero or an empty string to continue the process; a nonzero value to end the process
     * and direct {@link Container.Prototype.Every} to return 1.
     *
     * @param {*} [ThisArg] - The value to pass to the hidden `this` parameter when executing the
     * callback. See the file "test\ThisArg-example.ahk" for working examples.
     *
     * @returns {Integer} - If the callback returns a nonzero value, 1. Else, 0.
     */
    Every(Callback, ThisArg?) {
        if IsSet(ThisArg) {
            loop this.Length {
                if Callback(ThisArg, this[A_Index], A_Index, this) {
                    return 1
                }
            }
        } else {
            loop this.Length {
                if Callback(this[A_Index], A_Index, this) {
                    return 1
                }
            }
        }
        return 0
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Iterates the values in the container, passing each value to a callback function. If the callback
     * function returns nonzero, {@link Container.Prototype.EverySparse} will return 1 immediately.
     * If the callback function always returns 0 or an empty string, {@link Container.Prototype.EverySparse}
     * will return 0 after processing every value.
     *
     * @param {*} Callback - If `ThisArg` is set the function can accept two to four parameters.
     * Parameters 2-4 must be optional.
     *
     * Parameters:
     * - `ThisArg` - the hidden `this` parameter.
     * - The current value. If there is no value, this parameter will be unset (the parameter should be optional).
     * - The current index.
     * - The {@link Container} object.
     *
     * If `ThisArg` is unset, the function can accept one to three parameters. Parameters 1-3 must be
     * optional.
     *
     * Parameters:
     * - The current value. If there is no value, this parameter will be unset (the parameter should be optional).
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: zero or an empty string to continue the process; a nonzero value to end the process
     * and direct {@link Container.Prototype.EverySparse} to return 1.
     *
     * @param {*} [ThisArg] - The value to pass to the hidden `this` parameter when executing the
     * callback. See the file "test\ThisArg-example.ahk" for working examples.
     *
     * @returns {Integer} - If the callback returns a nonzero value, 1. Else, 0.
     */
    EverySparse(Callback, ThisArg?) {
        if IsSet(ThisArg) {
            loop this.Length {
                if this.Has(A_Index) {
                    if Callback(ThisArg, this[A_Index], A_Index, this) {
                        return 1
                    }
                } else if Callback(ThisArg, , A_Index, this) {
                    return 1
                }
            }
        } else {
            loop this.Length {
                if this.Has(A_Index) {
                    if Callback(this[A_Index], A_Index, this) {
                        return 1
                    }
                } else if Callback(, A_Index, this) {
                    return 1
                }
            }
        }
        return 0
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * This version of the function does not search for multiple indices; it only finds
     * the first index from left-to-right that contains the input value.
     *
     * @param {*} Value - The value to find.
     *
     * @param {Number} [IndexStart = 1] - The index to start the search at.
     *
     * @param {Number} [IndexEnd = this.Length] - The index to end the search at.
     *
     * @returns {Integer} - If the value is found, the first index containing the value from left
     * to right. Else, 0.
     */
    Find(Value, &OutValue?, IndexStart := 1, IndexEnd := this.Length) {
        if IndexEnd < IndexStart {
            return 0
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_CB_DATE:
                CallbackCompare := this.CallbackCompareValue
                Compare := _CompareValue
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := Container_Date.FromTimestamp(this.CallbackValue.Call(Value))
                }
            case CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompareValue
                CallbackValue := this.CallbackValue
                Compare := _CompareCbValue
                if IsObject(Value) {
                    Value := CallbackValue(Value)
                }
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := this.__DateParser.Call(
                        Value
                      , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                    )
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare := _CompareCbNumber
                if !IsNumber(Value) {
                    Value := CallbackValue(Value)
                }
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare := _CompareCbString
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        _value := CallbackValue(Value)
                        Value := StrPtr(_value)
                    } else {
                        _value := Value
                        Value := StrPtr(Value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare := _CompareCbValue
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        Value := CallbackValue(Value)
                    } else {
                        _value := Value
                        Value := StrPtr(_value)
                    }
                }
            case CONTAINER_SORTTYPE_DATE:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
            case CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompareValue
                Compare := _CompareValue
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := this.DateParser.Call(
                        Value
                      , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                    )
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_DATEVALUE:
                if IsObject(Value) {
                    if HasProp(Value, '__Container_DateValue') {
                        Value := Value.__Container_DateValue
                    } else {
                        Value := this.DateConvertCb(Value)
                    }
                } else if !IsNumber(Value) {
                    Value := this.DateConvert(Value)
                }
                Compare := _CompareDateValue
            case CONTAINER_SORTTYPE_MISC:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
            case CONTAINER_SORTTYPE_NUMBER:
                Compare := _CompareNumber
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareString
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }
        while IndexEnd - IndexStart > 4 {
            i := IndexEnd - Ceil((IndexEnd - IndexStart) * 0.5)
            if x := Compare() {
                if x > 0 {
                    IndexStart := i
                } else {
                    IndexEnd := i
                }
            } else {
                loop i - IndexStart {
                    --i
                    if Compare() {
                        OutValue := this[i + 1]
                        return i + 1
                    }
                }
                return i
            }
        }
        i := IndexStart
        loop IndexEnd - i + 1 {
            if Compare() {
                ++i
            } else {
                OutValue := this[i]
                return i
            }
        }

        return 0

        _CompareDateValue() => Value - this[i].__Container_DateValue
        _CompareNumber() => Value - this[i]
        _CompareString() => CallbackCompare(Value, StrPtr(this[i]))
        _CompareCbNumber() => Value - CallbackValue(this[i])
        _CompareCbString() => CallbackCompare(Value, StrPtr(CallbackValue(this[i])))
        _CompareCbValue() => CallbackCompare(Value, CallbackValue(this[i]))
        _CompareValue() => CallbackCompare(Value, this[i])
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * @description - Performs a binary search on an array to find one or more indices that contain
     * the input value. If there are multiple indices with the input value, the index returned by
     * the function will be the lowest index, and the index assigned to `OutLastIndex` will be the
     * highest index.
     *
     * @param {*} Value - The value to search for. This value may be an object as long as its
     * numeric/string value can be returned by {@link Container#CallbackCompare}.
     *
     * @param {Vthisef} [OutLastIndex] - If there are multiple indices containing the input value,
     * `OutLastIndex` is set with the greatest index which contains the input value. If there is one
     * index containing the input value, `OutLastIndex` will be the same as the return value.
     *
     * @param {Number} [IndexStart = 1] - The index to start the search at.
     *
     * @param {Number} [IndexEnd = this.Length] - The index to end the search at.
     *
     * @returns {Integer} - If the value is found, the first index containing the value. Else, 0.
     */
    FindAll(Value, &OutLastIndex?, IndexStart := 1, IndexEnd := this.Length) {
        if IndexEnd < IndexStart {
            return 0
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                Compare := _CompareNumber
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareString
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompareValue
                Compare := _CompareValue
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := this.DateParser.Call(
                        Value
                      , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                    )
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare := _CompareCbNumber
                if !IsNumber(Value) {
                    Value := CallbackValue(Value)
                }
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare := _CompareCbString
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        _value := CallbackValue(Value)
                        Value := StrPtr(_value)
                    } else {
                        _value := Value
                        Value := StrPtr(Value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare := _CompareCbValue
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        Value := CallbackValue(Value)
                    } else {
                        _value := Value
                        Value := StrPtr(_value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_DATE:
                CallbackCompare := this.CallbackCompareValue
                Compare := _CompareValue
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := Container_Date.FromTimestamp(this.CallbackValue.Call(Value))
                }
            case CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompareValue
                CallbackValue := this.CallbackValue
                Compare := _CompareCbValue
                date := ''
                if !IsObject(Value) {
                    if IsNumber(Value) {
                        date := Container_Date.FromTimestamp(Value)
                    } else {
                        date := this.DateParser.Call(
                            Value
                          , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                        )
                    }
                }
                if date {
                    Value := date
                } else {
                    Value := this.CallbackValue.Call(Value)
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_DATE:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
            case CONTAINER_SORTTYPE_DATEVALUE:
                if IsObject(Value) {
                    if HasProp(Value, '__Container_DateValue') {
                        Value := Value.__Container_DateValue
                    } else {
                        Value := this.DateConvertCb(Value)
                    }
                } else if !IsNumber(Value) {
                    Value := this.DateConvert(Value)
                }
                Compare := _CompareDateValue
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }
        while IndexEnd - IndexStart > 4 {
            i := IndexEnd - Ceil((IndexEnd - IndexStart) * 0.5)
            if x := Compare() {
                if x > 0 {
                    IndexStart := i
                } else {
                    IndexEnd := i
                }
            } else {
                Start := i
                --i
                loop i - IndexStart + 1 {
                    if Compare() {
                        break
                    } else {
                        --i
                    }
                }
                Result := i + 1
                i := Start + 1
                loop IndexEnd - i + 1 {
                    if Compare() {
                        break
                    } else {
                        ++i
                    }
                }
                OutLastIndex := i - 1
                return Result
            }
        }
        i := IndexStart
        loop IndexEnd - i + 1 {
            if Compare() {
                ++i
            } else {
                Result := i
                break
            }
        }
        ; Value was not found
        if !IsSet(Result) {
            return 0
        }
        ++i
        loop IndexEnd - i + 1 {
            if Compare() {
                break
            } else {
                ++i
            }
        }
        OutLastIndex := i - 1
        return Result

        _CompareDateValue() => Value - this[i].__Container_DateValue
        _CompareNumber() => Value - this[i]
        _CompareString() => CallbackCompare(Value, StrPtr(this[i]))
        _CompareCbNumber() => Value - CallbackValue(this[i])
        _CompareCbString() => CallbackCompare(Value, StrPtr(CallbackValue(this[i])))
        _CompareCbValue() => CallbackCompare(Value, CallbackValue(this[i]))
        _CompareValue() => CallbackCompare(Value, this[i])
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * @description - Performs a binary search on an array to find one or more indices that contain
     * the input value. {@link Container.Prototype.FindSparse} allows for unset indices, but
     * every set index must be sorted in order.
     *
     * @param {*} Value - The value to search for. This value may be an object as long
     * as its numerical value can be returned by the `ValueCallback` function.
     *
     * @param {Vthisef} [OutLastIndex] - If there are multiple indices containing the input value,
     * `OutLastIndex` is set with the greatest index which contains the input value. If there is one
     * index containing the input value, `OutLastIndex` will be the same as the return value.
     *
     * @param {Number} [IndexStart = 1] - The index to start the search at.
     *
     * @param {Number} [IndexEnd = this.Length] - The index to end the search at.
     *
     * @returns {Integer} - The index of the first value that satisfies the condition.
     */
    FindAllSparse(Value, &OutLastIndex?, IndexStart := 1, IndexEnd := this.Length) {
        if IndexEnd < IndexStart {
            return 0
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                Compare := _CompareNumber
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareString
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompareValue
                Compare := _CompareValue
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := this.DateParser.Call(
                        Value
                      , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                    )
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare := _CompareCbNumber
                if !IsNumber(Value) {
                    Value := CallbackValue(Value)
                }
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare := _CompareCbString
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        _value := CallbackValue(Value)
                        Value := StrPtr(_value)
                    } else {
                        _value := Value
                        Value := StrPtr(Value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare := _CompareCbValue
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        Value := CallbackValue(Value)
                    } else {
                        _value := Value
                        Value := StrPtr(_value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_DATE:
                CallbackCompare := this.CallbackCompareValue
                Compare := _CompareValue
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := Container_Date.FromTimestamp(this.CallbackValue.Call(Value))
                }
            case CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompareValue
                CallbackValue := this.CallbackValue
                Compare := _CompareCbValue
                date := ''
                if !IsObject(Value) {
                    if IsNumber(Value) {
                        date := Container_Date.FromTimestamp(Value)
                    } else {
                        date := this.DateParser.Call(
                            Value
                          , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                        )
                    }
                }
                if date {
                    Value := date
                } else {
                    Value := this.CallbackValue.Call(Value)
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_DATE:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
            case CONTAINER_SORTTYPE_DATEVALUE:
                if IsObject(Value) {
                    if HasProp(Value, '__Container_DateValue') {
                        Value := Value.__Container_DateValue
                    } else {
                        Value := this.DateConvertCb(Value)
                    }
                } else if !IsNumber(Value) {
                    Value := this.DateConvert(Value)
                }
                Compare := _CompareDateValue
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }
        while IndexEnd - IndexStart > 4 {
            if !this.Has(i := IndexEnd - Ceil((IndexEnd - IndexStart) * 0.5)) {
                if !_GetNearest() {
                    return 0
                }
            }
            if x := Compare() {
                if x > 0 {
                    IndexStart := i
                } else {
                    IndexEnd := i
                }
            } else {
                Start := Result := OutLastIndex := i
                loop i - IndexStart {
                    if this.Has(--i) {
                        if Compare() {
                            break
                        } else {
                            Result := i
                        }
                    }
                }
                i := Start
                loop IndexEnd - i {
                    if this.Has(++i) {
                        if Compare() {
                            break
                        } else {
                            OutLastIndex := i
                        }
                    }
                }
                return Result
            }
        }
        i := IndexStart - 1
        loop IndexEnd - i {
            if this.Has(++i) {
                if !Compare() {
                    Result := OutLastIndex := i
                    break
                }
            }
        }
        ; Value was not found
        if !IsSet(Result) {
            return 0
        }
        OutLastIndex := Result
        loop IndexEnd - i {
            if this.Has(++i) {
                if Compare() {
                    break
                } else {
                    OutLastIndex := i
                }
            }
        }
        return Result

        _CompareDateValue() => Value - this[i].__Container_DateValue
        _CompareNumber() => Value - this[i]
        _CompareString() => CallbackCompare(Value, StrPtr(this[i]))
        _CompareCbNumber() => Value - CallbackValue(this[i])
        _CompareCbString() => CallbackCompare(Value, StrPtr(CallbackValue(this[i])))
        _CompareCbValue() => CallbackCompare(Value, CallbackValue(this[i]))
        _CompareValue() => CallbackCompare(Value, this[i])
        _GetNearest() {
            Start := i
            loop IndexEnd - i {
                if this.Has(++i) {
                    return 1
                }
            }
            i := Start
            loop i - IndexStart {
                if this.Has(--i) {
                    return 1
                }
            }
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Searches the for the index which contains the first value that satisfies the condition.
     *
     * @param {*} Value - The value to search for. `Value` may be an object as long as its
     * numeric value can be returned by {@link Container#CallbackCompare}.
     *
     * @param {Vthisef} [OutValue] - A variable that will receive the raw value at the found index.
     *
     * @param {String} [Condition='>='] - The inequality symbol indicating what condition satisfies
     * the search. Valid values are:
     * - ">": `QuickFind` returns the index of the first value greater than the input value.
     * - ">=": `QuickFind` returns the index of the first value greater than or equal to the input value.
     * - "<": `QuickFind` returns the index of the first value less than the input value.
     * - "<=": `QuickFind` returns the index of the first value less than or equal to the input value.
     *
     * @param {Number} [IndexStart = 1] - The index to start the search at.
     *
     * @param {Number} [IndexEnd = this.Length] - The index to end the search at.
     *
     * @returns {Integer} - The index of the first value that satisfies the condition.
     */
    FindInequality(Value, &OutValue?, Condition := '>=', IndexStart := 1, IndexEnd := this.Length) {
        if IndexEnd < IndexStart {
            return 0
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                Compare1 := _CompareNumber1
                Compare2 := _CompareNumber2
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareString1
                Compare2 := _CompareString2
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompare
                CallbackCompareValue := this.CallbackCompareValue
                Compare1 := _CompareDate1
                Compare2 := _CompareValue2
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := this.DateParser.Call(
                        Value
                      , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                    )
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbNumber1
                Compare2 := _CompareCbNumber2
                if !IsNumber(Value) {
                    Value := CallbackValue(Value)
                }
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbString1
                Compare2 := _CompareCbString2
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        _value := CallbackValue(Value)
                        Value := StrPtr(_value)
                    } else {
                        _value := Value
                        Value := StrPtr(Value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbValue1
                Compare2 := _CompareCbValue2
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        Value := CallbackValue(Value)
                    } else {
                        _value := Value
                        Value := StrPtr(_value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_DATE:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbValue1
                Compare2 := _CompareCbValue2
                if !IsNumber(Value) {
                    Value := this.CallbackValue.Call(Value)
                }
            case CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompare
                CallbackCompareValue := this.CallbackCompareValue
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbDate1
                Compare2 := _CompareCbValue2
                date := ''
                if IsObject(Value) {
                    Value := this.CallbackValue.Call(Value)
                }
                if !IsObject(Value) {
                    if IsNumber(Value) {
                        date := Container_Date.FromTimestamp(Value)
                    } else {
                        date := this.DateParser.Call(
                            Value
                          , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                        )
                    }
                }
                if date {
                    Value := date
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_DATE:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
            case CONTAINER_SORTTYPE_DATEVALUE:
                if IsObject(Value) {
                    if HasProp(Value, '__Container_DateValue') {
                        Value := Value.__Container_DateValue
                    } else {
                        Value := this.DateConvertCb(Value)
                    }
                } else if !IsNumber(Value) {
                    Value := this.DateConvert(Value)
                }
                Compare1 := _CompareDateValue1
                Compare2 := _CompareDateValue2
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }

        ;@region 1 Unique val
        ; This block handles conditions where there is only one unique value between `IndexStart`
        ; and `IndexEnd`.
        if IndexEnd > IndexStart {
            x := Compare2(IndexStart, IndexEnd)
        } else {
            x := 0
        }
        if !x {
            ; First, we validate `Value`. We might be able to skip the whole process if `Value` is
            ; out of range. We can also prepare the return value so we don't need to re-check
            ; `Condition`. The return value will be a function of the sort direction.
            i := IndexStart
            x := Compare1()
            switch Condition {
                case '>':
                    if x >= 0 {
                        return 0
                    }
                    Result := (BaseDirection) => BaseDirection == 1 ? IndexEnd : IndexStart
                case '>=':
                    if x > 0 {
                        return 0
                    }
                    Result := (BaseDirection) => BaseDirection == 1 ? IndexEnd : IndexStart
                case '<':
                    if x <= 0 {
                        return 0
                    }
                    Result := (BaseDirection) => BaseDirection == 1 ? IndexStart : IndexEnd
                case '<=':
                    if x < 0 {
                        return 0
                    }
                    Result := (BaseDirection) => BaseDirection == 1 ? IndexStart : IndexEnd
            }
            ; `Value` satisfies the condition at this point. If `IndexEnd == IndexStart`, then there is only
            ; one set index and we can return that.
            if IndexEnd == IndexStart {
                OutValue := this[IndexStart]
                return IndexStart
            }
            ; At this point, we know `Value` is valid and there are multiple indices with `Value`.
            ; Therefore, we must know the sort direction so we know whether to return `IndexStart` or
            ; `IndexEnd`.
            x := Compare2(1, this.Length)
            if x = 0 {
                ; Default to `IndexStart` because there is no sort direction.
                OutValue := this[IndexStart]
                return IndexStart
            } else if x < 0 {
                OutValue := this[Result(-1)]
                return Result(-1)
            } else {
                OutValue := this[Result(1)]
                return Result(1)
            }
        }
        ;@endregion

        ;@region Condition
        switch Condition {

            ;@region case >=
            case '>=':
                Condition := _Compare_GTE
                AltCondition := _Compare_LT
                HandleEqualValues := _HandleEqualValues_EQ
                EQ := true
                ; If the value at IndexEnd is > the value at IndexStart
                if x < 0 {
                    i := IndexEnd
                    ; If the input value is greater than the value at IndexEnd
                    if Compare1() > 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := -1
                    Sequence_GT := _Sequence_GT_A_2
                    Sequence_LT := _Sequence_GT_A_1
                    Compare_Loop := _CompareSimple_LT
                } else {
                    i := IndexStart
                    ; If the input value is greater than the value at IndexStart
                    if Compare1() > 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := 1
                    Sequence_GT := _Sequence_GT_D_2
                    Sequence_LT := _Sequence_GT_D_1
                    Compare_Loop := _CompareSimple_GT
                }
            ;@endregion

            ;@region case >
            case '>':
                Condition := _Compare_GT
                AltCondition := _Compare_LTE
                HandleEqualValues := _HandleEqualValues_NEQ
                EQ := false
                ; If the value at IndexEnd is > the value at IndexStart
                if x < 0 {
                    i := IndexEnd
                    ; If the input value is greater than or equal to the value at IndexEnd
                    if Compare1() >= 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := 1
                    Sequence_GT := _Sequence_GT_A_2
                    Sequence_LT := _Sequence_GT_A_1
                    Compare_Loop := _CompareSimple_LT
                } else {
                    i := IndexStart
                    ; If the input value is greater than or equal to the value at IndexStart
                    if Compare1() >= 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := -1
                    Sequence_GT := _Sequence_GT_D_2
                    Sequence_LT := _Sequence_GT_D_1
                    Compare_Loop := _CompareSimple_GT
                }
            ;@endregion

            ;@region case <=
            case '<=':
                Condition := _Compare_LTE
                AltCondition := _Compare_GT
                HandleEqualValues := _HandleEqualValues_EQ
                EQ := true
                ; If the value at IndexEnd is > the value at IndexStart
                if x < 0 {
                    i := IndexStart
                    ; If the input value is less than the value at IndexStart
                    if Compare1() < 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := 1
                    Sequence_GT := _Sequence_LT_A_2
                    Sequence_LT := _Sequence_LT_A_1
                    Compare_Loop := _CompareSimple_LT
                } else {
                    i := IndexEnd
                    ; If the input value is less than the value at IndexEnd
                    if Compare1() < 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := -1
                    Sequence_GT := _Sequence_LT_D_2
                    Sequence_LT := _Sequence_LT_D_1
                    Compare_Loop := _CompareSimple_GT
                }
            ;@endregion

            ;@region case <
            case '<':
                Condition := _Compare_LT
                AltCondition := _Compare_GTE
                HandleEqualValues := _HandleEqualValues_NEQ
                EQ := false
                ; If the value at IndexEnd is > the value at IndexStart
                if x < 0 {
                    i := IndexStart
                    ; If the input value is less than or equal to the value at IndexStart
                    if Compare1() <= 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := -1
                    Sequence_GT := _Sequence_LT_A_2
                    Sequence_LT := _Sequence_LT_A_1
                    Compare_Loop := _CompareSimple_LT
                } else {
                    i := IndexEnd
                    ; If the input value is less than or equal to the value at IndexEnd
                    if Compare1() <= 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := 1
                    Sequence_GT := _Sequence_LT_D_2
                    Sequence_LT := _Sequence_LT_D_1
                    Compare_Loop := _CompareSimple_GT
                }
            ;@endregion

            default: throw ValueError('Invalid condition.', -1, Condition)
        }
        ;@endregion

        ;@region Process
        while IndexEnd - IndexStart > 4 {
            i := IndexEnd - Ceil((IndexEnd - IndexStart) * 0.5)
            x := Compare1()
            if x = 0 {
                return HandleEqualValues()
            } else if Compare_Loop() {
                IndexStart := i
            } else {
                IndexEnd := i
            }
        }
        ; If we go the entire loop without landing on an equal value, then we search sequentially
        ; from `i`.
        x := Compare1()
        if x = 0 {
            return HandleEqualValues()
        } else if _CompareSimple_GT() {
            return Sequence_GT()
        } else {
            return Sequence_LT()
        }
        ;@endregion

        ;@region Compare1
        _Compare_GT() => Compare1() < 0
        _Compare_GTE() => Compare1() <= 0
        _Compare_LT() => Compare1() > 0
        _Compare_LTE() => Compare1() >= 0
        _Compare_EQ() => Compare1() = 0

        _CompareSimple_GT() => x < 0
        _CompareSimple_GTE() => x <= 0
        _CompareSimple_LT() => x > 0
        _CompareSimple_LTE() => x >= 0
        _CompareSimple_EQ() => x = 0

        _CompareDateValue1() => Value - this[i].__Container_DateValue
        _CompareNumber1() => Value - this[i]
        _CompareString1() => CallbackCompare(Value, StrPtr(this[i]))
        _CompareCbNumber1() => Value - CallbackValue(this[i])
        _CompareCbString1() => CallbackCompare(Value, StrPtr(CallbackValue(this[i])))
        _CompareCbValue1() => CallbackCompare(Value, CallbackValue(this[i]))
        _CompareValue1() => CallbackCompare(Value, this[i])
        _CompareDate1() => CallbackCompareValue(Value, this[i])
        _CompareCbDate1() => CallbackCompareValue(Value, CallbackValue(this[i]))

        _CompareDateValue2(a, b) => this[a].__Container_DateValue - this[b].__Container_DateValue
        _CompareNumber2(a, b) => this[a] - this[b]
        _CompareString2(a, b) => CallbackCompare(StrPtr(this[a]), StrPtr(this[b]))
        _CompareCbNumber2(a, b) => CallbackValue(this[a]) - CallbackValue(this[b])
        _CompareCbString2(a, b) => CallbackCompare(StrPtr(CallbackValue(this[a])), StrPtr(CallbackValue(this[b])))
        _CompareCbValue2(a, b) => CallbackCompare(CallbackValue(this[a]), CallbackValue(this[b]))
        _CompareValue2(a, b) => CallbackCompare(this[a], this[b])
        ;@endregion

        ;@region Sequence
        /**
         * @description - Used when:
         * - `!Compare_GT()`
         * - Ascent == 1
         * - > or >=
         */
        _Sequence_GT_A_1() {
            ; If `Value` > <current value>, and if GT, then we must search toward `Value`
            ; until we hit an equal or greater value. If we hit an equal value and if ET, we return
            ; that. If not ET, then we keep going until we find a greater value. Since we have
            ; already set `Condition` to check for the correct condition, we just need to check
            ; `Condition`.
            loop IndexEnd - i {
                ++i
                if Condition() {
                    OutValue := this[i]
                    return i
                }
            }
            OutValue := this[i]
            return i
        }
        /**
         * @description - Used when:
         * - `!Compare_GT()`
         * - Ascent == -1
         * - > or >=
         */
        _Sequence_GT_D_1() {
            ; Same as above but in the opposite direction.
            loop i - IndexStart {
                --i
                if Condition() {
                    OutValue := this[i]
                    return i
                }
            }
            OutValue := this[i]
            return i
        }
        /**
         * @description - Used when:
         * - `Compare_GT()`
         * - Ascent == 1
         * - > or >=
         */
        _Sequence_GT_A_2() {
            ; If `Value` < <current value> and if GT, then we are already at an index that
            ; satisfies the condition, but we do not know for sure that it is the first index.
            ; So we must search toward `Value` until finding an index that does not
            ; satisfy the condition. In this case we search agains the direction of ascent.
            Previous := i
            loop i - IndexStart {
                --i
                if AltCondition() {
                    if EQ && _Compare_EQ() {
                        return HandleEqualValues()
                    } else {
                        OutValue := this[Previous]
                        return Previous
                    }
                } else {
                    Previous := i
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        /**
         * @description - Used when:
         * - `Compare_GT()`
         * - Ascent == -1
         * - > or >=
         */
        _Sequence_GT_D_2() {
            ; Same as above but opposite direction.
            Previous := i
            loop IndexEnd - i {
                ++i
                if AltCondition() {
                    if EQ && _Compare_EQ() {
                        return HandleEqualValues()
                    } else {
                        OutValue := this[Previous]
                        return Previous
                    }
                } else {
                    Previous := i
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        /**
         * @description - Used when:
         * - `!Compare_GT()`
         * - Ascent == 1
         * - < or <=
         */
        _Sequence_LT_A_1() {
            ; If `Value` > <current value> and if not GT, then we are already at an index that
            ; satisfies the condition, but we do not know for sure that it is the first index.
            ; So we must search toward `Value` until finding an index that does not
            ; satisfy the condition. If we run into an equal value, and if EQ, then we can
            ; pass control over to `HandleEqualValues` because it will do the rest. If not EQ,
            ; then we can ignore equality because we just need `AltCondition` to return true.
            Previous := i
            loop IndexEnd - i {
                ++i
                if AltCondition() {
                    if EQ && _Compare_EQ() {
                        return HandleEqualValues()
                    } else {
                        OutValue := this[Previous]
                        return Previous
                    }
                } else {
                    Previous := i
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        /**
         * @description - Used when:
         * - `!Compare_GT()`
         * - Ascent == -1
         * - < or <=
         */
        _Sequence_LT_D_1() {
            ; Same as above but opposite direction.
            Previous := i
            loop i - IndexStart {
                --i
                if AltCondition() {
                    if EQ && _Compare_EQ() {
                        return HandleEqualValues()
                    } else {
                        OutValue := this[Previous]
                        return Previous
                    }
                } else {
                    Previous := i
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        /**
         * @description - Used when:
         * - `Compare_GT()`
         * - Ascent == 1
         * - < or <=
         */
        _Sequence_LT_A_2() {
            ; If `Value` < <current value>, and if not GT, then we must go opposite of the
            ; direction of ascent until `Condition` returns true.
            loop i - IndexStart {
                --i
                if Condition() {
                    OutValue := this[i]
                    return i
                }
            }
            OutValue := this[i]
            return i
        }
        /**
         * @description - Used when:
         * - `Compare_GT()`
         * - Ascent == -1
         * - < or <=
         */
        _Sequence_LT_D_2() {
            ; Same as above but opposite direction.
            loop IndexEnd - i {
                ++i
                if Condition() {
                    OutValue := this[i]
                    return i
                }
            }
            OutValue := this[i]
            return i
        }
        ;@endregion

        ;@region Helpers
        ; This function is used when equality is included in the condition.
        _HandleEqualValues_EQ() {
            ; We are able to prepare for this function beforehand by understanding what direction
            ; we must search in order to find the correct index to return. Since equality is included,
            ; we must search in the opposite direction we otherwise would have, then return the
            ; index that is previous to the first index which contains a value that is NOT equivalent
            ; to `Value`.
            ; Consider an array:
            ; -500 -499 -498 -497 -497 -497 -496 -495 -494
            ; `Value := -497`
            ; If GT, then the correct index is 4 because it is the first index to contain a value
            ; that meets the condition in the search direction, so to find it we must search
            ; <DirectionofAscent> * -1 (-1 in the example) then return 4 when we get to 3.
            ; If LT, then the correct index is 6, so we must do the opposite. Specifically,
            ; we must search <DirectionofAscent> (1 in the example) then return 6 when we get to 7.
            /**
             * @example
             * if GT {
             *     HEV_Direction := BaseDirection == 1 ? -1 : 1
             * } else {
             *     HEV_Direction := BaseDirection == 1 ? 1 : -1
             * }
             * @
             */
            if HEV_Direction > 0 {
                i--
                LoopCount := IndexEnd - i
            } else {
                i++
                LoopCount := i - IndexStart
            }
            loop LoopCount {
                i += HEV_Direction
                if !_Compare_EQ() {
                    break
                }
                Previous := i
            }
            OutValue := this[Previous]
            return Previous
        }
        ; This function is used when equality is not included in the condition.
        _HandleEqualValues_NEQ() {
            ; When equality is not included, the process is different. When GT, we no longer invert
            ; the direction of ascent. We are interested in the first index that contains a value
            ; which meets the condition in the same direction as the direction of ascent. When LT,
            ; we are interested in the first index that contains a value which meets the condition
            ; in the opposite direction of the direction of ascent.
            ; Consider an array:
            ; -500 -499 -498 -497 -497 -497 -496 -495 -494
            ; `Value := -497`
            ; If GT, then the correct index is 7 because it is the first index to contain a value
            ; that meets the condition in the search direction, so to find it we must search
            ; <DirectionofAscent> (1 in the example) then return 7 when we get to 7.
            ; If LT, then the correct index is 3, so we must do the opposite. Specifically,
            ; we must search <DirectionofAscent> * -1 (-1 in the example) then return 3 when we get to 3.
            /**
             * @example
             * if GT {
             *     HEV_Direction := BaseDirection == 1 ? 1 : -1
             * } else {
             *     HEV_Direction := BaseDirection == 1 ? -1 : 1
             * }
             * @
             */
            loop HEV_Direction > 0 ? IndexEnd - i + 1 : i {
                i += HEV_Direction
                if !_Compare_EQ() {
                    break
                }
            }
            OutValue := this[i]
            return i
        }
        ;@endregion
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * earches the for the index which contains the first value that satisfies the condition.
     *
     * @param {*} Value - The value to search for. `Value` may be an object as long as its
     * numeric value can be returned by {@link Container#CallbackCompare}.
     *
     * @param {Vthisef} [OutValue] - A variable that will receive the raw value at the found index.
     *
     * @param {String} [Condition='>='] - The inequality symbol indicating what condition satisfies
     * the search. Valid values are:
     * - ">": `QuickFind` returns the index of the first value greater than the input value.
     * - ">=": `QuickFind` returns the index of the first value greater than or equal to the input value.
     * - "<": `QuickFind` returns the index of the first value less than the input value.
     * - "<=": `QuickFind` returns the index of the first value less than or equal to the input value.
     *
     * @param {Number} [IndexStart = 1] - The index to start the search at.
     *
     * @param {Number} [IndexEnd = this.Length] - The index to end the search at.
     *
     * @returns {Integer} - The index of the first value that satisfies the condition.
     */
    FindInequalitySparse(Value, &OutValue?, Condition := '>=', IndexStart := 1, IndexEnd := this.Length) {
        if IndexEnd < IndexStart {
            return 0
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                Compare1 := _CompareNumber1
                Compare2 := _CompareNumber2
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareString1
                Compare2 := _CompareString2
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompare
                CallbackCompareValue := this.CallbackCompareValue
                Compare1 := _CompareDate1
                Compare2 := _CompareValue2
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := this.DateParser.Call(
                        Value
                      , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                    )
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbNumber1
                Compare2 := _CompareCbNumber2
                if !IsNumber(Value) {
                    Value := CallbackValue(Value)
                }
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbString1
                Compare2 := _CompareCbString2
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        _value := CallbackValue(Value)
                        Value := StrPtr(_value)
                    } else {
                        _value := Value
                        Value := StrPtr(Value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbValue1
                Compare2 := _CompareCbValue2
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        Value := CallbackValue(Value)
                    } else {
                        _value := Value
                        Value := StrPtr(_value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_DATE:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbValue1
                Compare2 := _CompareCbValue2
                if !IsNumber(Value) {
                    Value := this.CallbackValue.Call(Value)
                }
            case CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompare
                CallbackCompareValue := this.CallbackCompareValue
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbDate1
                Compare2 := _CompareCbValue2
                date := ''
                if IsObject(Value) {
                    Value := this.CallbackValue.Call(Value)
                }
                if !IsObject(Value) {
                    if IsNumber(Value) {
                        date := Container_Date.FromTimestamp(Value)
                    } else {
                        date := this.DateParser.Call(
                            Value
                          , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                        )
                    }
                }
                if date {
                    Value := date
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_DATE:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
            case CONTAINER_SORTTYPE_DATEVALUE:
                if IsObject(Value) {
                    if HasProp(Value, '__Container_DateValue') {
                        Value := Value.__Container_DateValue
                    } else {
                        Value := this.DateConvertCb(Value)
                    }
                } else if !IsNumber(Value) {
                    Value := this.DateConvert(Value)
                }
                Compare1 := _CompareDateValue1
                Compare2 := _CompareDateValue2
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }

        ;@region Get left-right
        ; This block starts to identify the sort direction, and also sets `left` and `right` in the
        ; process.
        i := IndexStart
        ; No return value indicates the array had no set indices between IndexStart and IndexEnd.
        if !_GetNearest_L2R() {
            throw Error('The indices within the input range are all unset.')
        }
        left := i
        i := IndexEnd
        ; This will always return 1 because we know that there is at least one value in the input range.
        _GetNearest_R2L()
        right := i
        ;@endregion

        ;@region 1 Unique val
        ; This block handles conditions where there is only one unique value between `IndexStart`
        ; and `IndexEnd`.
        if IndexEnd > IndexStart {
            x := Compare2(left, right)
        } else {
            x := 0
        }
        if !x {
            ; First, we validate `Value`. We might be able to skip the whole process if `Value` is
            ; out of range. We can also prepare the return value so we don't need to re-check
            ; `Condition`. The return value will be a function of the sort direction.
            i := left
            x := Compare1()
            switch Condition {
                case '>':
                    if x >= 0 {
                        return 0
                    }
                    Result := (BaseDirection) => BaseDirection == 1 ? right : left
                case '>=':
                    if x > 0 {
                        return 0
                    }
                    Result := (BaseDirection) => BaseDirection == 1 ? right : left
                case '<':
                    if x <= 0 {
                        return 0
                    }
                    Result := (BaseDirection) => BaseDirection == 1 ? left : right
                case '<=':
                    if x < 0 {
                        return 0
                    }
                    Result := (BaseDirection) => BaseDirection == 1 ? left : right
            }
            ; `Value` satisfies the condition at this point. If `right == left`, then there is only
            ; one set index and we can return that.
            if right == left {
                OutValue := this[left]
                return left
            }
            ; At this point, we know `Value` is valid and there are multiple indices with `Value`.
            ; Therefore, we must know the sort direction so we know whether to return `left` or
            ; `right`.
            i := 0
            while !this.Has(++i) {
                continue
            }
            _left := i
            i := this.Length + 1
            while !this.Has(--i) {
                continue
            }
            _right := i
            x := Compare2(_left, _right)
            if x = 0 {
                ; Default to `left` because there is no sort direction.
                OutValue := this[left]
                return left
            } else if x < 0 {
                OutValue := this[Result(-1)]
                return Result(-1)
            } else {
                OutValue := this[Result(1)]
                return Result(1)
            }
        }
        ;@endregion

        ;@region Condition
        switch Condition {

            ;@region case >=
            case '>=':
                Condition := _Compare_GTE
                AltCondition := _Compare_LT
                HandleEqualValues := _HandleEqualValues_EQ
                EQ := true
                if x < 0 {
                    i := right
                    if Compare1() > 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := -1
                    Sequence_GT := _Sequence_GT_A_2
                    Sequence_LT := _Sequence_GT_A_1
                    Compare_Loop := _CompareSimple_LT
                } else {
                    i := left
                    if Compare1() > 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := 1
                    Sequence_GT := _Sequence_GT_D_2
                    Sequence_LT := _Sequence_GT_D_1
                    Compare_Loop := _CompareSimple_GT
                }
            ;@endregion

            ;@region case >
            case '>':
                Condition := _Compare_GT
                AltCondition := _Compare_LTE
                HandleEqualValues := _HandleEqualValues_NEQ
                EQ := false
                if x < 0 {
                    i := right
                    if Compare1() >= 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := 1
                    Sequence_GT := _Sequence_GT_A_2
                    Sequence_LT := _Sequence_GT_A_1
                    Compare_Loop := _CompareSimple_LT
                } else {
                    i := left
                    if Compare1() >= 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := -1
                    Sequence_GT := _Sequence_GT_D_2
                    Sequence_LT := _Sequence_GT_D_1
                    Compare_Loop := _CompareSimple_GT
                }
            ;@endregion

            ;@region case <=
            case '<=':
                Condition := _Compare_LTE
                AltCondition := _Compare_GT
                HandleEqualValues := _HandleEqualValues_EQ
                EQ := true
                if x < 0 {
                    i := left
                    if Compare1() < 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := 1
                    Sequence_GT := _Sequence_LT_A_2
                    Sequence_LT := _Sequence_LT_A_1
                    Compare_Loop := _CompareSimple_LT
                } else {
                    i := right
                    if Compare1() < 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := -1
                    Sequence_GT := _Sequence_LT_D_2
                    Sequence_LT := _Sequence_LT_D_1
                    Compare_Loop := _CompareSimple_GT
                }
            ;@endregion

            ;@region case <
            case '<':
                Condition := _Compare_LT
                AltCondition := _Compare_GTE
                HandleEqualValues := _HandleEqualValues_NEQ
                EQ := false
                if x < 0 {
                    i := left
                    if Compare1() <= 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := -1
                    Sequence_GT := _Sequence_LT_A_2
                    Sequence_LT := _Sequence_LT_A_1
                    Compare_Loop := _CompareSimple_LT
                } else {
                    i := right
                    if Compare1() <= 0 {
                        ; `Value` is out of range.
                        return 0
                    }
                    HEV_Direction := 1
                    Sequence_GT := _Sequence_LT_D_2
                    Sequence_LT := _Sequence_LT_D_1
                    Compare_Loop := _CompareSimple_GT
                }
            ;@endregion

            default: throw ValueError('Invalid condition.', -1, Condition)
        }
        ;@endregion

        stop := -1
        rng := IndexEnd - IndexStart + 1
        ;@region Process
        while rng * 0.5 ** stop > 4 {
            stop++
            i := right - Ceil((right - left) * 0.5)
            while !this.Has(i) {
                if i + 1 > IndexEnd {
                    while !this.Has(--i) {
                        continue
                    }
                    if _Compare_GT() {
                        return Sequence_GT()
                    } else {
                        return Sequence_LT()
                    }
                } else {
                    i++
                }
            }
            x := Compare1()
            if x = 0 {
                return HandleEqualValues()
            } else if Compare_Loop() {
                left := i
            } else {
                right := i
            }
        }
        ; If we go the entire loop without landing on an equal value, then we search sequentially
        ; from `i`.
        x := Compare1()
        if x = 0 {
            return HandleEqualValues()
        } else if _CompareSimple_GT() {
            return Sequence_GT()
        } else {
            return Sequence_LT()
        }
        ;@endregion

        ;@region Compare1
        _Compare_GT() => Compare1() < 0
        _Compare_GTE() => Compare1() <= 0
        _Compare_LT() => Compare1() > 0
        _Compare_LTE() => Compare1() >= 0
        _Compare_EQ() => Compare1() = 0

        _CompareSimple_GT() => x < 0
        _CompareSimple_GTE() => x <= 0
        _CompareSimple_LT() => x > 0
        _CompareSimple_LTE() => x >= 0
        _CompareSimple_EQ() => x = 0

        _CompareDateValue1() => Value - this[i].__Container_DateValue
        _CompareNumber1() => Value - this[i]
        _CompareString1() => CallbackCompare(Value, StrPtr(this[i]))
        _CompareCbNumber1() => Value - CallbackValue(this[i])
        _CompareCbString1() => CallbackCompare(Value, StrPtr(CallbackValue(this[i])))
        _CompareCbValue1() => CallbackCompare(Value, CallbackValue(this[i]))
        _CompareValue1() => CallbackCompare(Value, this[i])
        _CompareDate1() => CallbackCompareValue(Value, this[i])
        _CompareCbDate1() => CallbackCompareValue(Value, CallbackValue(this[i]))

        _CompareDateValue2(a, b) => this[a].__Container_DateValue - this[b].__Container_DateValue
        _CompareNumber2(a, b) => this[a] - this[b]
        _CompareString2(a, b) => CallbackCompare(StrPtr(this[a]), StrPtr(this[b]))
        _CompareCbNumber2(a, b) => CallbackValue(this[a]) - CallbackValue(this[b])
        _CompareCbString2(a, b) => CallbackCompare(StrPtr(CallbackValue(this[a])), StrPtr(CallbackValue(this[b])))
        _CompareCbValue2(a, b) => CallbackCompare(CallbackValue(this[a]), CallbackValue(this[b]))
        _CompareValue2(a, b) => CallbackCompare(this[a], this[b])
        ;@endregion

        ;@region Sequence
        /**
         * @description - Used when:
         * - `!Compare_GT()`
         * - Ascent == 1
         * - > or >=
         */
        _Sequence_GT_A_1() {
            ; If `Value` > <current value>, and if GT, then we must search toward `Value`
            ; until we hit an equal or greater value. If we hit an equal value and if ET, we return
            ; that. If not ET, then we keep going until we find a greater value. Since we have
            ; already set `Condition` to check for the correct condition, we just need to check
            ; `Condition`.
            loop IndexEnd - i {
                if this.Has(++i) {
                    if Condition() {
                        OutValue := this[i]
                        return i
                    }
                }
            }
            OutValue := this[i]
            return i
        }
        /**
         * @description - Used when:
         * - `!Compare_GT()`
         * - Ascent == -1
         * - > or >=
         */
        _Sequence_GT_D_1() {
            ; Same as above but in the opposite direction.
            loop i - IndexStart {
                if this.Has(--i) {
                    if Condition() {
                        OutValue := this[i]
                        return i
                    }
                }
            }
            OutValue := this[i]
            return i
        }
        /**
         * @description - Used when:
         * - `Compare_GT()`
         * - Ascent == 1
         * - > or >=
         */
        _Sequence_GT_A_2() {
            ; If `Value` < <current value> and if GT, then we are already at an index that
            ; satisfies the condition, but we do not know for sure that it is the first index.
            ; So we must search toward `Value` until finding an index that does not
            ; satisfy the condition. In this case we search agains the direction of ascent.
            Previous := i
            loop i - IndexStart {
                if this.Has(--i) {
                    if AltCondition() {
                        if EQ && _Compare_EQ() {
                            return HandleEqualValues()
                        } else {
                            OutValue := this[Previous]
                            return Previous
                        }
                    } else {
                        Previous := i
                    }
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        /**
         * @description - Used when:
         * - `Compare_GT()`
         * - Ascent == -1
         * - > or >=
         */
        _Sequence_GT_D_2() {
            ; Same as above but opposite direction.
            Previous := i
            loop IndexEnd - i {
                if this.Has(++i) {
                    if AltCondition() {
                        if EQ && _Compare_EQ() {
                            return HandleEqualValues()
                        } else {
                            OutValue := this[Previous]
                            return Previous
                        }
                    } else {
                        Previous := i
                    }
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        /**
         * @description - Used when:
         * - `!Compare_GT()`
         * - Ascent == 1
         * - < or <=
         */
        _Sequence_LT_A_1() {
            ; If `Value` > <current value> and if not GT, then we are already at an index that
            ; satisfies the condition, but we do not know for sure that it is the first index.
            ; So we must search toward `Value` until finding an index that does not
            ; satisfy the condition. If we run into an equal value, and if EQ, then we can
            ; pass control over to `HandleEqualValues` because it will do the rest. If not EQ,
            ; then we can ignore equality because we just need `AltCondition` to return true.
            Previous := i
            loop IndexEnd - i {
                if this.Has(++i) {
                    if AltCondition() {
                        if EQ && _Compare_EQ() {
                            return HandleEqualValues()
                        } else {
                            OutValue := this[Previous]
                            return Previous
                        }
                    } else {
                        Previous := i
                    }
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        /**
         * @description - Used when:
         * - `!Compare_GT()`
         * - Ascent == -1
         * - < or <=
         */
        _Sequence_LT_D_1() {
            ; Same as above but opposite direction.
            Previous := i
            loop i - IndexStart {
                if this.Has(--i) {
                    if AltCondition() {
                        if EQ && _Compare_EQ() {
                            return HandleEqualValues()
                        } else {
                            OutValue := this[Previous]
                            return Previous
                        }
                    } else {
                        Previous := i
                    }
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        /**
         * @description - Used when:
         * - `Compare_GT()`
         * - Ascent == 1
         * - < or <=
         */
        _Sequence_LT_A_2() {
            ; If `Value` < <current value>, and if not GT, then we must go opposite of the
            ; direction of ascent until `Condition` returns true.
            loop i - IndexStart {
                if this.Has(--i) {
                    if Condition() {
                        OutValue := this[i]
                        return i
                    }
                }
            }
            OutValue := this[i]
            return i
        }
        /**
         * @description - Used when:
         * - `Compare_GT()`
         * - Ascent == -1
         * - < or <=
         */
        _Sequence_LT_D_2() {
            ; Same as above but opposite direction.
            loop IndexEnd - i {
                if this.Has(++i) {
                    if Condition() {
                        OutValue := this[i]
                        return i
                    }
                }
            }
            OutValue := this[i]
            return i
        }
        ;@endregion

        ;@region Helpers
        ; This function is used when equality is included in the condition.
        _HandleEqualValues_EQ() {
            ; We are able to prepare for this function beforehand by understanding what direction
            ; we must search in order to find the correct index to return. Since equality is included,
            ; we must search in the opposite direction we otherwise would have, then return the
            ; index that is previous to the first index which contains a value that is NOT equivalent
            ; to `Value`.
            ; Consider an array:
            ; -500 -499 -498 -497 -497 -497 -496 -495 -494
            ; `Value := -497`
            ; If GT, then the correct index is 4 because it is the first index to contain a value
            ; that meets the condition in the search direction, so to find it we must search
            ; <DirectionofAscent> * -1 (-1 in the example) then return 4 when we get to 3.
            ; If LT, then the correct index is 6, so we must do the opposite. Specifically,
            ; we must search <DirectionofAscent> (1 in the example) then return 6 when we get to 7.
            /**
             * @example
             * if GT {
             *     HEV_Direction := BaseDirection == 1 ? -1 : 1
             * } else {
             *     HEV_Direction := BaseDirection == 1 ? 1 : -1
             * }
             * @
             */
            if HEV_Direction > 0 {
                i--
                LoopCount := IndexEnd - i
            } else {
                i++
                LoopCount := i - IndexStart
            }
            loop LoopCount {
                i += HEV_Direction
                if this.Has(i) {
                    if !_Compare_EQ() {
                        break
                    }
                    Previous := i
                }
            }
            OutValue := this[Previous]
            return Previous
        }
        ; This function is used when equality is not included in the condition.
        _HandleEqualValues_NEQ() {
            ; When equality is not included, the process is different. When GT, we no longer invert
            ; the direction of ascent. We are interested in the first index that contains a value
            ; which meets the condition in the same direction as the direction of ascent. When LT,
            ; we are interested in the first index that contains a value which meets the condition
            ; in the opposite direction of the direction of ascent.
            ; Consider an array:
            ; -500 -499 -498 -497 -497 -497 -496 -495 -494
            ; `Value := -497`
            ; If GT, then the correct index is 7 because it is the first index to contain a value
            ; that meets the condition in the search direction, so to find it we must search
            ; <DirectionofAscent> (1 in the example) then return 7 when we get to 7.
            ; If LT, then the correct index is 3, so we must do the opposite. Specifically,
            ; we must search <DirectionofAscent> * -1 (-1 in the example) then return 3 when we get to 3.
            /**
             * @example
             * if GT {
             *     HEV_Direction := BaseDirection == 1 ? 1 : -1
             * } else {
             *     HEV_Direction := BaseDirection == 1 ? -1 : 1
             * }
             * @
             */
            loop HEV_Direction > 0 ? IndexEnd - i + 1 : i {
                i += HEV_Direction
                if this.Has(i) {
                    if !_Compare_EQ() {
                        break
                    }
                }
            }
            if this.Has(i) {
                OutValue := this[i]
                return i
            }
        }
        _GetNearest_L2R() {
            loop IndexEnd - i + 1 {
                if this.Has(i) {
                    return 1
                }
                i++
            }
        }
        _GetNearest_R2L() {
            loop i - IndexStart + 1 {
                if this.Has(i) {
                    return 1
                }
                i--
            }
        }
        ;@endregion
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * This version of the function does not search for multiple indices; it only finds
     * the first index from left-to-right that contains the input value.
     *
     * @param {*} Value - The value to find.
     *
     * @param {Number} [IndexStart = 1] - The index to start the search at.
     *
     * @param {Number} [IndexEnd = this.Length] - The index to end the search at.
     *
     * @returns {Integer} - If the value is found, the first index containing the value from left
     * to right. Else, 0.
     */
    FindSparse(Value, &OutValue?, IndexStart := 1, IndexEnd := this.Length) {
        if IndexEnd < IndexStart {
            return 0
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                Compare := _CompareNumber
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareString
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
                if !IsNumber(Value) {
                    _value := Value
                    Value := StrPtr(_value)
                }
            case CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompareValue
                Compare := _CompareValue
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := this.DateParser.Call(
                        Value
                      , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                    )
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare := _CompareCbNumber
                if !IsNumber(Value) {
                    Value := CallbackValue(Value)
                }
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare := _CompareCbString
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        _value := CallbackValue(Value)
                        Value := StrPtr(_value)
                    } else {
                        _value := Value
                        Value := StrPtr(Value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare := _CompareCbValue
                if !IsNumber(Value) {
                    if IsObject(Value) {
                        Value := CallbackValue(Value)
                    } else {
                        _value := Value
                        Value := StrPtr(_value)
                    }
                }
            case CONTAINER_SORTTYPE_CB_DATE:
                CallbackCompare := this.CallbackCompareValue
                Compare := _CompareValue
                if IsNumber(Value) {
                    Value := Container_Date.FromTimestamp(Value)
                } else {
                    Value := Container_Date.FromTimestamp(this.CallbackValue.Call(Value))
                }
            case CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompareValue
                CallbackValue := this.CallbackValue
                Compare := _CompareCbValue
                date := ''
                if !IsObject(Value) {
                    if IsNumber(Value) {
                        date := Container_Date.FromTimestamp(Value)
                    } else {
                        date := this.DateParser.Call(
                            Value
                          , StrLen(this.CompareDateCentury) ? this.CompareDateCentury : unset
                        )
                    }
                }
                if date {
                    Value := date
                } else {
                    Value := this.CallbackValue.Call(Value)
                }
                if !Value {
                    throw Error('Failed to parse ``Value``.', , Value)
                }
            case CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_DATE:
                CallbackCompare := this.CallbackCompare
                Compare := _CompareValue
            case CONTAINER_SORTTYPE_DATEVALUE:
                if IsObject(Value) {
                    if HasProp(Value, '__Container_DateValue') {
                        Value := Value.__Container_DateValue
                    } else {
                        Value := this.DateConvertCb(Value)
                    }
                } else if !IsNumber(Value) {
                    Value := this.DateConvert(Value)
                }
                Compare := _CompareDateValue
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }
        while IndexEnd - IndexStart > 4 {
            if !this.Has(i := IndexEnd - Ceil((IndexEnd - IndexStart) * 0.5)) {
                if !_GetNearest() {
                    return 0
                }
            }
            if x := Compare() {
                if x > 0 {
                    IndexStart := i
                } else {
                    IndexEnd := i
                }
            } else {
                loop i - IndexStart {
                    --i
                    if Compare() {
                        OutValue := this[i + 1]
                        return i + 1
                    }
                }
                return i
            }
        }
        i := IndexStart - 1
        loop IndexEnd - i + 1 {
            if this.Has(++i) && !Compare() {
                OutValue := this[i]
                return i
            }
        }

        return 0

        _CompareDateValue() => Value - this[i].__Container_DateValue
        _CompareNumber() => Value - this[i]
        _CompareString() => CallbackCompare(Value, StrPtr(this[i]))
        _CompareCbNumber() => Value - CallbackValue(this[i])
        _CompareCbString() => CallbackCompare(Value, StrPtr(CallbackValue(this[i])))
        _CompareCbValue() => CallbackCompare(Value, CallbackValue(this[i]))
        _CompareValue() => CallbackCompare(Value, this[i])
        _GetNearest() {
            Start := i
            loop IndexEnd - i {
                if this.Has(++i) {
                    return 1
                }
            }
            i := Start
            loop i - IndexStart {
                if this.Has(--i) {
                    return 1
                }
            }
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no. Unset indices are skipped; all indices in the output container are
     * set.
     *
     * Creates a new {@link Container} by calling {@link Container.Prototype.Copy} on this container,
     * then iterates the values of this {@link Container}. For each
     * value that inherits from array (including {@link Container}), the values are recursively
     * "flattened", i.e., the values of the nested array/container are added directly to the end of
     * the output container.
     *
     * @param {Integer} [MaxDepth = 0] - If a positive integer, the maximum depth to recurse into
     * nested arrays. A value less than or equal to 0 indicates to maximum.
     *
     * @returns {Container} - A new container containing the flattened values.
     */
    Flat(MaxDepth := 0) {
        result := this.Copy()
        result.Capacity := this.Length * 2
        stack := [ this, 0 ]
        stack.Capacity := 16
        if MaxDepth > 0 {
            loop {
                c := stack[-1][1]
                i := stack[-1][2]
                loop {
                    if ++i > c.Length {
                        stack.Pop()
                        if stack.Length {
                            continue 2
                        } else {
                            return result
                        }
                    }
                    if c.Has(i) {
                        if c[i] is Array && stack.Length < MaxDepth {
                            stack[-1][2] := i
                            stack.Push([ c[i], 0 ])
                            continue 2
                        } else {
                            result.Push(c[i])
                        }
                    }
                }
            }
        } else {
            loop {
                c := stack[-1][1]
                i := stack[-1][2]
                loop {
                    if ++i > c.Length {
                        stack.Pop()
                        if stack.Length {
                            continue 2
                        } else {
                            return result
                        }
                    }
                    if c.Has(i) {
                        if c[i] is Array {
                            stack[-1][2] := i
                            stack.Push([ c[i], 0 ])
                            continue 2
                        } else {
                            result.Push(c[i])
                        }
                    }
                }
            }
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Iterates the values in the container, passing each value to a callback function. The callback's
     * return value is ignored.
     *
     * @param {*} Callback - If `ThisArg` is set, the function can accept two to four parameters.
     *
     * Parameters:
     * - `ThisArg` - the hidden `this` parameter.
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * If `ThisArg` is unset, the function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * @param {*} [ThisArg] - The value to pass to the hidden `this` parameter when executing the
     * callback. See the file "test\ThisArg-example.ahk" for working examples.
     */
    ForEach(Callback, ThisArg?) {
        if IsSet(ThisArg) {
            loop this.Length {
                Callback(ThisArg, this[A_Index], A_Index, this)
            }
        } else {
            loop this.Length {
                Callback(this[A_Index], A_Index, this)
            }
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Iterates the values in the container, passing each value to a callback function. The callback's
     * return value is ignored.
     *
     * @param {*} Callback - If `ThisArg` is set, the function can accept two to four parameters.
     * Parameters 2-4 must be optional.
     *
     * Parameters:
     * - `ThisArg` - the hidden `this` parameter.
     * - The current value. If there is no value, this parameter will be unset (the parameter should be optional).
     * - The current index.
     * - The {@link Container} object.
     *
     * If `ThisArg` is unset, the function can accept one to three parameters. Parameters 1-3 must
     * be optional.
     *
     * Parameters:
     * - The current value. If there is no value, this parameter will be unset (the parameter should be optional).
     * - The current index.
     * - The {@link Container} object.
     *
     * @param {*} [ThisArg] - The value to pass to the hidden `this` parameter when executing the
     * callback. See the file "test\ThisArg-example.ahk" for working examples.
     */
    ForEachSparse(Callback, ThisArg?) {
        if IsSet(ThisArg) {
            loop this.Length {
                if this.Has(A_Index) {
                    Callback(ThisArg, this[A_Index], A_Index, this)
                } else {
                    Callback(ThisArg, , A_Index, this)
                }
            }
        } else {
            loop this.Length {
                if this.Has(A_Index) {
                    Callback(this[A_Index], A_Index, this)
                } else {
                    Callback(, A_Index, this)
                }
            }
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Uses {@link Container.Prototype.Find} to return a value.
     *
     * @param {*} Value - The value passed to {@link Container.Prototype.Find}.
     *
     * @param {*} [Default] - The value to return if {@link Container.Prototype.Find} returns 0.
     *
     * @returns {*} -  If found, returns the found value. If not found, and if `Default` is set,
     * returns `Default`. If `Default` is not set, and if the container has a
     * {@link https://www.autohotkey.com/docs/v2/lib/Array.htm#Default "Default"} property, returns
     * `this.Default`. Else, throws an error.
     *
     * @throws {UnsetItemError} - "Value not found."
     */
    GetValue(Value, Default?) {
        if this.Find(Value, &outValue) {
            return outValue
        } else {
            if IsSet(Default) {
                return Default
            } else if HasProp(this, 'Default') {
                return this.Default
            } else {
                throw UnsetItemError('Value not found.')
            }
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Uses {@link Container.Prototype.Find} to return a value.
     *
     * @param {*} Value - The value passed to {@link Container.Prototype.Find}.
     *
     * @param {*} [Default] - The value to return if {@link Container.Prototype.Find} returns 0.
     *
     * @returns {*} -  If found, returns the found value. If not found, and if `Default` is set,
     * returns `Default`. If `Default` is not set, and if the container has a
     * {@link https://www.autohotkey.com/docs/v2/lib/Array.htm#Default "Default"} property, returns
     * `this.Default`. Else, throws an error.
     *
     * @throws {UnsetItemError} - "Value not found."
     */
    GetValueSparse(Value, Default?) {
        if this.FindSparse(Value, &outValue) {
            return outValue
        } else {
            if IsSet(Default) {
                return Default
            } else if HasProp(this, 'Default') {
                return this.Default
            } else {
                throw UnsetItemError('Value not found.')
            }
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Iterates the values in the container and compares the values to `Value`. If found, the function returns the index.
     *
     * @example
     * c := Container(
     *     { Name: "obj4" }
     *   , { Name: "obj1" }
     *   , { Name: "obj3" }
     *   , { Name: "obj2" }
     * )
     * OutputDebug(c.HasValue("obj1", (value) => value.Name) '`n') ; 2
     * OutputDebug(c.HasValue("obj5", (value) => value.Name) '`n') ; 0
     * @
     *
     * @param {*} Value - The value to find.
     *
     * @param {*} [Callback] - A `Func` or callable object that is called for each value in the container.
     *
     * Parameters:
     * 1. The current value.
     *
     * Returns the value to compare with `Value`.
     *
     * @returns {Integer} - If `Value` is found, the index. Else, 0.
     */
    HasValue(Value, Callback?) {
        if IsSet(Callback) {
            loop this.Length {
                if Callback(this[A_Index]) = Value {
                    return A_Index
                }
            }
        } else {
            loop this.Length {
                if this[A_Index] = Value {
                    return A_Index
                }
            }
        }
        return 0
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Iterates the values in the container and compares the values to `Value`. If found, the function returns the index.
     *
     * @example
     * c := Container(
     *     { Name: "obj4" }
     *   ,
     *   ,
     *   , { Name: "obj2" }
     * )
     * OutputDebug(c.HasValueSparse("obj1", (value) => value.Name) '`n') ; 0
     * OutputDebug(c.HasValueSparse("obj2", (value) => value.Name) '`n') ; 4
     * @
     *
     * @param {*} Value - The value to find.
     *
     * @param {*} Callback - A `Func` or callable object that is called for each value in the container.
     *
     * Parameters:
     * 1. The current value.
     *
     * Returns the value to compare with `Value`.
     *
     * @returns {Integer} - If `Value` is found, the index. Else, 0.
     */
    HasValueSparse(Value, Callback?) {
        if IsSet(Callback) {
            loop this.Length {
                if this.Has(A_Index) && Callback(this[A_Index]) = Value {
                    return A_Index
                }
            }
        } else {
            loop this.Length {
                if this.Has(A_Index) && this[A_Index] = Value {
                    return A_Index
                }
            }
        }
        return 0
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Inserts a value in order.
     *
     * @param {*} Value - The value.
     *
     * @returns {Integer} - The index at which it was inserted.
     */
    Insert(Value) {
        if this.Length {
            if index := this.FindInequality(Value, , '>') {
                this.InsertAt(index, Value)
                return index
            } else if this.Compare(Value, 1) < 0 {
                this.InsertAt(1, Value)
                return 1
            } else {
                this.Push(Value)
                return this.Length
            }
        } else {
            this.Push(Value)
            return 1
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Inserts a value in order if the value does not exist in the container.
     *
     * @param {*} Value - The value.
     *
     * @returns {Integer} - The index at which it was inserted.
     */
    InsertIfAbsent(Value) {
        if this.Length {
            if index := this.FindInequality(Value, , '>=') {
                ; If `Value` is not equivalent with the value at `index`
                if this.Compare(Value, index) {
                    this.InsertAt(index, Value)
                    return index
                }
            } else if this.Compare(Value, 1) < 0 {
                this.InsertAt(1, Value)
                return 1
            } else {
                this.Push(Value)
                return this.Length
            }
        } else {
            this.Push(Value)
            return 1
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Inserts a value in order if the value does not exist in the container.
     *
     * @param {*} Value - The value.
     *
     * @returns {Integer} - The index at which it was inserted.
     */
    InsertIfAbsentSparse(Value) {
        if this.Length {
            if index := this.FindInequalitySparse(Value, , '>=') {
                ; If `Value` is not equivalent with the value at `index`
                if this.Compare(Value, index) {
                    ; If there is an unset index to the left, fill it in
                    if !this.Has(index - 1) && index > 1 {
                        this[index - 1] := Value
                        return index - 1
                    } else {
                        this.InsertAt(index, Value)
                        return index
                    }
                }
            } else {
                i := 1
                while !this.Has(i) && i < this.Length {
                    ++i
                }
                ; If all indices are unset
                if !this.Has(i) {
                    this[1] := Value
                    return
                }
                if this.Compare(Value, i) < 0 {
                    if i > 1 {
                        this[i - 1] := Value
                        return i - 1
                    } else {
                        this.InsertAt(1, Value)
                        return 1
                    }
                } else {
                    i := this.Length
                    while !this.Has(i) && i > 0 {
                        --i
                    }
                    if i < this.Length {
                        this[i + 1] := Value
                        return i + 1
                    } else {
                        this.Push(Value)
                        return this.Length
                    }
                }
            }
        } else {
            this.Push(Value)
            return 1
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Inserts values in order.
     *
     * @param {*} Values - One or more values to insert.
     */
    InsertList(Values) {
        if Values is Array {
            for value in Values {
                this.Insert(value)
            }
        } else {
            this.Insert(Values)
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Inserts values in order.
     *
     * @param {*} Values - One or more values to insert.
     */
    InsertListSparse(Values) {
        if Values is Array {
            loop Values.Length {
                if Values.Has(A_Index) {
                    this.InsertSparse(Values[A_Index])
                }
            }
        } else {
            this.InsertSparse(Values)
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Inserts a value in order.
     *
     * @param {*} Value - The value.
     *
     * @returns {Integer} - The index at which it was inserted.
     */
    InsertSparse(Value) {
        if this.Length {
            if index := this.FindInequalitySparse(Value, , '>') {
                ; If there is an unset index to the left, fill it in
                if !this.Has(index - 1) && index > 1 {
                    this[index - 1] := Value
                    return index - 1
                } else {
                    this.InsertAt(index, Value)
                    return index
                }
            } else {
                i := 1
                while !this.Has(i) && i < this.Length {
                    ++i
                }
                ; If all indices are unset
                if !this.Has(i) {
                    this[1] := Value
                    return
                }
                if this.Compare(Value, i) < 0 {
                    if i > 1 {
                        this[i - 1] := Value
                        return i - 1
                    } else {
                        this.InsertAt(1, Value)
                        return 1
                    }
                } else {
                    i := this.Length
                    while !this.Has(i) && i > 0 {
                        --i
                    }
                    if i < this.Length {
                        this[i + 1] := Value
                        return i + 1
                    } else {
                        this.Push(Value)
                        return this.Length
                    }
                }
            }
        } else {
            this.Push(Value)
            return 1
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Sorts in-place using insertion sort method. This method is appropriate for small container
     * sizes (n <= 32).
     */
    InsertionSort() {
        if !this.Length {
            throw Error('The ``Container`` is empty.')
        }
        if this.Length == 1 {
            return this
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                Compare1 := _CompareNumber1
                Compare2 := _CompareNumber2
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareString1
                Compare2 := _CompareString2
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbNumber1
                Compare2 := _CompareCbNumber2
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbString1
                Compare2 := _CompareCbString2
            case CONTAINER_SORTTYPE_CB_STRINGPTR
            , CONTAINER_SORTTYPE_CB_DATE
            , CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbValue1
                Compare2 := _CompareCbValue2
            case CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_DATE
            , CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
            case CONTAINER_SORTTYPE_DATEVALUE:
                Compare1 := _CompareDateValue1
                Compare2 := _CompareDateValue2
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }
        if this.Length == 2 {
            if Compare1(this[1], this[2]) > 0 {
                t := this[1]
                this[1] := this[2]
                this[2] := t
            }
            return this
        } else if this.Length > 2 {
            i := 1
            loop this.Length - 1 {
                j := i
                b := this[++i]
                loop j {
                    if Compare2(this[j]) < 0 {
                        break
                    }
                    this[j + 1] := this[j--]
                }
                this[j + 1] := b
            }
        }

        return this

        _CompareDateValue1(a, b) => a.__Container_DateValue - b.__Container_DateValue
        _CompareNumber1(a, b) => a - b
        _CompareString1(a, b) => CallbackCompare(StrPtr(a), StrPtr(b))
        _CompareCbNumber1(a, b) => CallbackValue(a) - CallbackValue(b)
        _CompareCbString1(a, b) => CallbackCompare(StrPtr(CallbackValue(a)), StrPtr(CallbackValue(b)))
        _CompareCbValue1(a, b) => CallbackCompare(CallbackValue(a), CallbackValue(b))
        _CompareValue1(a, b) => Callbackcompare(a, b)
        _CompareDateValue2(a) => a.__Container_DateValue - b.__Container_DateValue
        _CompareNumber2(a) => a - b
        _CompareString2(a) => CallbackCompare(StrPtr(a), StrPtr(b))
        _CompareCbNumber2(a) => CallbackValue(a) - CallbackValue(b)
        _CompareCbString2(a) => CallbackCompare(StrPtr(CallbackValue(a)), StrPtr(CallbackValue(b)))
        _CompareCbValue2(a) => CallbackCompare(CallbackValue(a), CallbackValue(b))
        _CompareValue2(a) => Callbackcompare(a, b)
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Joins all values into a string.
     * - The container may not have unset indices.
     * - Objects are represented as `"{" Type(value) "}"`.
     *
     * @param {String} [Delimiter = ", "] - The string to separate each value of the array.
     *
     * @returns {String} - The string.
     */
    Join(Delimiter := ', ') {
        s := ''
        VarSetStrCapacity(&s, this.Length * 5)
        loop this.Length {
            if IsObject(this[A_Index]) {
                s .= '{' Type(this[A_Index]) '}' Delimiter
            } else {
                s .= this[A_Index] Delimiter
            }
        }
        return s ? SubStr(s, 1, -1 * StrLen(Delimiter)) : ''
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Joins all values into a string.
     * - The container may not have unset indices.
     * - Objects are represented as "{" Type(value) "}".
     *
     * @param {String} [Delimiter = ", "] - The string to separate each value of the array.
     *
     * @param {String} [UnsetItem = "`"`""] - The string to represent unset indices. To skip
     * unset indices entirely (and not have them represented in the output), set `UnsetItem` with
     * zero or an empty string.
     *
     * @param {*} [CallbackObject = (value) => "{ " Type(value) " }"] - A `Func` or callable object
     * which accepts the object as an argument and returns the substring to add to the result string.
     *
     * @returns {String} - The string.
     */
    JoinEx(Delimiter := ', ', UnsetItem := '""', CallbackObject := (value) => '{ ' Type(value) ' }') {
        s := ''
        VarSetStrCapacity(&s, this.Length * 5)
        if UnsetItem {
            loop this.Length {
                if this.Has(A_Index) {
                    if IsObject(this[A_Index]) {
                        s .= CallbackObject(this[A_Index]) Delimiter
                    } else {
                        s .= this[A_Index] Delimiter
                    }
                } else {
                    s .= UnsetItem Delimiter
                }
            }
        } else {
            loop this.Length {
                if this.Has(A_Index) {
                    if IsObject(this[A_Index]) {
                        s .= CallbackObject(this[A_Index]) Delimiter
                    } else {
                        s .= this[A_Index] Delimiter
                    }
                }
            }
        }
        return s ? SubStr(s, 1, -1 * StrLen(Delimiter)) : ''
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Creates a new output container, then iterates the values in this container passing each value
     * to a callback function. The return values from the callback function are added to the output
     * container at the same index.
     *
     * @param {*} Callback - If `ThisArg` is set, the function can accept two to four parameters.
     *
     * Parameters:
     * - `ThisArg` - the hidden `this` parameter.
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * If `ThisArg` is unset, the function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: The value to add to the output container.
     *
     * @param {*} [ThisArg] - The value to pass to the hidden `this` parameter when executing the
     * callback. See the file "test\ThisArg-example.ahk" for working examples.
     *
     * @returns {Container} - A new container containing the values returned by the callback function.
     */
    Map(Callback, ThisArg?) {
        Result := Container()
        Result.Capacity := this.Length
        if IsSet(ThisArg) {
            loop this.Length {
                Result.Push(Callback(ThisArg, this[A_Index], A_Index, this))
            }
        } else {
            loop this.Length {
                Result.Push(Callback(this[A_Index], A_Index, this))
            }
        }
        return Result
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Creates a new output container, then iterates the values in this container passing each value
     * to a callback function. The return values from the callback function are added to the output
     * container at the same index.
     *
     * @param {*} Callback - If `ThisArg` is set, the function can accept two to four parameters.
     * Parameters 2-4 must be optional.
     *
     * Parameters:
     * - `ThisArg` - the hidden `this` parameter.
     * - The current value. If there is no value, this parameter will be unset (the parameter should be optional).
     * - The current index.
     * - The {@link Container} object.
     *
     * If `ThisArg` is unset, the function can accept one to three parameters. Parameters 1-3 must be optional.
     *
     * Parameters:
     * - The current value. If there is no value, this parameter will be unset (the parameter should be optional).
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: The value to add to the output container.
     *
     * @param {*} [ThisArg] - The value to pass to the hidden `this` parameter when executing the
     * callback. See the file "test\ThisArg-example.ahk" for working examples.
     *
     * @returns {Container} - A new container containing the values returned by the callback function.
     */
    MapSparse(Callback, ThisArg?) {
        Result := Container()
        Result.Length := this.Length
        if IsSet(ThisArg) {
            loop this.Length {
                if this.Has(A_Index) {
                    Result[A_Index] := Callback(ThisArg, this[A_Index], A_Index, this)
                }
            }
        } else {
            loop this.Length {
                if this.Has(A_Index) {
                    Result[A_Index] := Callback(this[A_Index], A_Index, this)
                }
            }
        }
        return Result
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Iterates the values in the container, passing each value to a callback function. If the
     * callback function returns nonzero, the value is removed from the container.
     *
     * This mutates the original container.
     *
     * @param {*} Callback -  The function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: Nonzero if {@link Container.Prototype.Purge} should remove the value from the
     * container; zero or an empty string if the value should not be removed.
     *
     * @returns {Container} - The purged container.
     */
    Purge(Callback) {
        indices := []
        indices.Capacity := this.Length
        loop this.Length {
            if Callback(this[A_Index], A_Index, this) {
                indices.Push(A_Index)
            }
        }
        n := 0
        for i in indices {
            this.RemoveAt(i - n)
            n++
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Iterates the values in the container, passing each value to a callback function. If the
     * callback function returns nonzero, the value is removed from the container.
     *
     * This mutates the original container.
     *
     * @param {*} Callback -  The function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: Nonzero if {@link Container.Prototype.Purge} should remove the value from the
     * container; zero or an empty string if the value should not be removed.
     *
     * @param {Boolean} [FillUnsetIndices = true] - If true, the values in the container are shifted
     * to the left for each unset index until all unset indices are filled. If false, unset indices
     * are skipped.
     *
     * @returns {Container} - The purged container.
     */
    PurgeSparse(Callback, FillUnsetIndices := true) {
        indices := []
        indices.Capacity := this.Length
        if FillUnsetIndices {
            loop this.Length {
                if !this.Has(A_Index) || Callback(this[A_Index], A_Index, this) {
                    indices.Push(A_Index)
                }
            }
        } else {
            loop this.Length {
                if this.Has(A_Index) && Callback(this[A_Index], A_Index, this) {
                    indices.Push(A_Index)
                }
            }
        }
        n := 0
        for i in indices {
            this.RemoveAt(i - n)
            n++
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * This is similar to `Array.Prototype.Push`, except:
     * - It is not variadic, but you can pass an array of items to `Value`.
     * - It returns the container, allowing {@link Container.Prototype.PushEx} to be chained
     *   with other functions.
     *
     * @example
     * c := Container(1, 2, 3)
     * c2 := Container(4, 5, 6)
     * c3 := Container(7, 8, 9)
     * c.PushEx(c2.PushEx(c3.PushEx([10, 11, 12])))
     * OutputDebug(c.Join() '`n') ; 1, 2, 3, 4, 5, ...
     * @
     *
     * @param {*} Value - The value(s) to add to the container. Is `Value` inherits from `Array`,
     * the values contained in the array are added to the container, not `Value` itself. To add
     * a value that inherits from `Array` as-is, pass the value nested in another array.
     * @example
     * c := Container(1, 2, 3)
     * arr := [ 4, 5, 6 ]
     * c.PushEx([ arr ])
     * @
     */
    PushEx(Value) {
        if Value is Array {
            this.Push(Value*)
        } else {
            this.Push(Value)
        }
        return this
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Characteristics of {@link ScriptParser_QuickSort}:
     * - Does not mutate the input array.
     * - Unstable (does not preserve original order of equal values).
     * - Can sort either ascending or descending - adjust the comparator appropriately.
     * - There's a built-in cutoff to use insertion sort for small arrays (16).
     * - Makes liberal usage of system memory.
     *
     * If you need a comparable function that sorts in-place, see
     * {@link Container.Prototype.Sort}.
     *
     * @param {array} arr - The array to be sorted.
     *
     * @param {*} [compare = (a, b) => a - b] - A `Func` or callable object that compares two values.
     *
     * @param {Integer} [arrSizeThreshold = 8] - Sets a threshold at which insertion sort is used to
     * sort the array instead of the core procedure. The default value of 8 was determine by testing
     * various distributions of numbers. `arrSizeThreshold` generally should be left at 8.
     *
     * @returns {array} - The sorted array.
     */
    ScriptParser_QuickSort(arrSizeThreshold := 8) {
        if !this.Length {
            throw Error('The ``Container`` is empty.')
        }
        if this.Length == 1 {
            return this.Clone()
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                Compare1 := _CompareNumber1
                Compare2 := _CompareNumber2
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareString1
                Compare2 := _CompareString2
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbNumber1
                Compare2 := _CompareCbNumber2
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbString1
                Compare2 := _CompareCbString2
            case CONTAINER_SORTTYPE_CB_STRINGPTR
            , CONTAINER_SORTTYPE_CB_DATE
            , CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbValue1
                Compare2 := _CompareCbValue2
            case CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_DATE
            , CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
            case CONTAINER_SORTTYPE_DATEVALUE:
                Compare1 := _CompareDateValue1
                Compare2 := _CompareDateValue2
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }
        n := this.Length
        if n == 2 {
            if Compare1(this[1], this[2]) > 0 {
                return _MakeResult([this[2], this[1]])
            } else {
                return this.Clone()
            }
        } else if n <= CONTAINER_INSERTIONSORT_THRESHOLD {
            c := this.Clone()
            i := 1
            loop n - 1 {
                j := i
                b := c[++i]
                loop j {
                    if Compare2(c[j]) < 0 {
                        break
                    }
                    c[j + 1] := c[j--]
                }
                c[j + 1] := b
            }
            return c
        }

        candidates := []
        candidates.Length := 3
        stack := []
        loop 3 {
            candidates[A_Index] := this[Random(1, this.Length)]
        }
        i := 1
        loop 2 {
            j := i
            b := candidates[++i]
            loop j {
                if Compare2(candidates[j]) < 0 {
                    break
                }
                candidates[j + 1] := candidates[j--]
            }
            candidates[j + 1] := b
        }
        b := candidates[2]
        left := []
        right := []
        left.Capacity := right.Capacity := this.Length
        for item in this {
            if Compare2(item) < 0 {
                left.Push(item)
            } else {
                right.Push(item)
            }
        }
        stack.Push([ left, right, 1 ])
        c := stack[-1][stack[-1][3]]
        loop {
            if c.Length <= arrSizeThreshold {
                if c.Length == 2 {
                    if Compare1(c[1], c[2]) > 0 {
                        stack[-1][stack[-1][3]] := [c[2], c[1]]
                    }
                } else if c.Length > 1 {
                    ; Insertion sort.
                    i := 1
                    loop c.Length - 1 {
                        j := i
                        b := c[++i]
                        loop j {
                            if Compare2(c[j]) < 0 {
                                break
                            }
                            c[j + 1] := c[j--]
                        }
                        c[j + 1] := b
                    }
                }
                while stack[-1][3] == 2 {
                    complete := stack.Pop()
                    complete[1].Push(complete[2]*)
                    if !stack.Length {
                        return _MakeResult(complete[1])
                    }
                    stack[-1][stack[-1][3]] := complete[1]
                }
                stack[-1][3]++
                c := stack[-1][2]
                continue
            }

            loop 3 {
                candidates[A_Index] := c[Random(1, c.Length)]
            }
            i := 1
            loop 2 {
                j := i
                b := candidates[++i]
                loop j {
                    if Compare2(candidates[j]) < 0 {
                        break
                    }
                    candidates[j + 1] := candidates[j--]
                }
                candidates[j + 1] := b
            }
            b := candidates[2]
            left := []
            right := []
            left.Capacity := right.Capacity := c.Length
            for item in c {
                if Compare2(item) < 0 {
                    left.Push(item)
                } else {
                    right.Push(item)
                }
            }
            if left.Length {
                c := left
                if right.Length {
                    stack.Push([ left, right, 1 ])
                    continue
                }
            } else if right.Length {
                c := right
            }
            if c.Length == 2 {
                if Compare1(c[1], c[2]) > 0 {
                    stack[-1][stack[-1][3]] := [c[2], c[1]]
                }
            } else if c.Length > 1 {
                ; Insertion sort.
                i := 1
                loop c.Length - 1 {
                    j := i
                    b := c[++i]
                    loop j {
                        if Compare2(c[j]) < 0 {
                            break
                        }
                        c[j + 1] := c[j--]
                    }
                    c[j + 1] := b
                }
            }
            stack[-1][stack[-1][3]] := c
            while stack[-1][3] == 2 {
                complete := stack.Pop()
                complete[1].Push(complete[2]*)
                if !stack.Length {
                    return _MakeResult(complete[1])
                }
                stack[-1][stack[-1][3]] := complete[1]
            }
            stack[-1][3]++
            c := stack[-1][2]
        }

        _CompareDateValue1(a, b) => a.__Container_DateValue - b.__Container_DateValue
        _CompareNumber1(a, b) => a - b
        _CompareString1(a, b) => CallbackCompare(StrPtr(a), StrPtr(b))
        _CompareCbNumber1(a, b) => CallbackValue(a) - CallbackValue(b)
        _CompareCbString1(a, b) => CallbackCompare(StrPtr(CallbackValue(a)), StrPtr(CallbackValue(b)))
        _CompareCbValue1(a, b) => CallbackCompare(CallbackValue(a), CallbackValue(b))
        _CompareValue1(a, b) => Callbackcompare(a, b)
        _CompareDateValue2(a) => a.__Container_DateValue - b.__Container_DateValue
        _CompareNumber2(a) => a - b
        _CompareString2(a) => CallbackCompare(StrPtr(a), StrPtr(b))
        _CompareCbNumber2(a) => CallbackValue(a) - CallbackValue(b)
        _CompareCbString2(a) => CallbackCompare(StrPtr(CallbackValue(a)), StrPtr(CallbackValue(b)))
        _CompareCbValue2(a) => CallbackCompare(CallbackValue(a), CallbackValue(b))
        _CompareValue2(a) => Callbackcompare(a, b)
        _MakeResult(c) {
            ObjSetBase(c, this.Base)
            for prop in this.OwnProps() {
                c.DefineProp(prop, this.GetOwnPropDesc(prop))
            }
            return c
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Iterates the values in the container, using a VarRef parameter to generate a cumulative result.
     *
     * @param {*} Callback -  The function can accept two to four parameters.
     *
     * Parameters:
     * - The accumulator (as VarRef).
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: The function should return zero or an empty string to continue processing. The
     * function should return a nonzero value to stop processing.
     *
     * @param {VarRef} [Accumulator] - The VarRef that will be passed to each function call and
     * returned at the end of the process.
     *
     * @returns {*} - The value of `Accumulator`.
    */
    Reduce(Callback, &Accumulator) {
        loop this.Length {
            if Callback(&Accumulator, this[A_Index], A_Index, this) {
                break
            }
        }
        return Accumulator
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Iterates the values in the container, using a VarRef parameter to generate a cumulative result.
     *
     * @param {*} Callback -  The function can accept two to four parameters. Parameters 2-4 must
     * be optional.
     *
     * Parameters:
     * - The accumulator (as VarRef).
     * - The current value. If there is no value, this parameter will be unset (the parameter should be optional).
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: The function should return zero or an empty string to continue processing. The
     * function should return a nonzero value to stop processing.
     *
     * @param {VarRef} [Accumulator] - The VarRef that will be passed to each function call and
     * returned at the end of the process.
     *
     * @returns {*} - The value of `Accumulator`.
    */
    ReduceSparse(Callback, &Accumulator) {
        loop this.Length {
            if this.Has(A_Index) {
                if Callback(&Accumulator, this[A_Index], A_Index, this) {
                    break
                }
            } else if Callback(&Accumulator, , A_Index, this) {
                break
            }
        }
        return Accumulator
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Finds a value in the container using {@link Container.Prototype.Find}, then removes it and
     * returns the index at which it was located. Throws an error if not found.
     *
     * @param {*} Value - The value to find.
     *
     * @param {VarRef} [OutValue] - A variable that will receive the value that was found.
     *
     * @returns {Integer} - The index of the found value.
     *
     * @throws {UnsetItemError} - "Value not found."
     */
    Remove(Value, &OutValue?) {
        if index := this.Find(Value, &OutValue) {
            this.RemoveAt(index)
            return index
        } else {
            throw UnsetItemError('Value not found.', -1, IsObject(Value) ? '{ ' Type(Value) ' }' : Value)
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Calls {@link Container.Prototype.FindAll} to find a value in the container. If the
     * value is found, removes each instance of the value.
     *
     * @param {*} Value - The value to find and remove.
     *
     * @param {VarRef} [OutList] - A variable that will receive a {@link Container} containing
     * the removed values. The {@link Container} is created by calling {@link Container.Prototype.Copy}.
     * You must set the variable with a nonzero value before calling {@link Container.Prototype.RemoveAll}
     * to direct the function to collect the values.
     *
     * @example
     * ; Assume `c` is a correctly prepared `Container`.
     * index := c.RemoveAll(1000, &list := true)
     * for v in list {
     *     ; do something
     * }
     * @
     *
     * @returns {Integer} - If the value is found, the first index from left-to-right where the value
     * was located. Else, 0.
     */
    RemoveAll(Value, &OutList?) {
        if index := this.FindAll(Value, &lastIndex) {
            i := index - 1
            if IsSet(OutList) && OutList {
                OutList := this.Copy()
                loop lastIndex - i {
                    OutList.Push(this.RemoveAt(i))
                }
            } else {
                loop lastIndex - i {
                    this.RemoveAt(i)
                }
            }
            return index
        }
        return 0
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Calls {@link Container.Prototype.FindAllSparse} to find a value in the container. If the
     * value is found, removes each instance of the value.
     *
     * @param {*} Value - The value to find and remove.
     *
     * @param {VarRef} [OutList] - A variable that will receive a {@link Container} containing
     * the removed values. The {@link Container} is created by calling {@link Container.Prototype.Copy}.
     * You must set the variable with a nonzero value before calling
     * {@link Container.Prototype.RemoveAllSparse} to direct the function to collect the values.
     *
     * @example
     * ; Assume `c` is a correctly prepared `Container`.
     * index := c.RemoveAllSparse(1000, &list := true)
     * for v in list {
     *     ; do something
     * }
     * @
     *
     * @returns {Integer} - If the value is found, the first index from left-to-right where the value
     * was located. Else, 0.
     */
    RemoveAllSparse(Value, &OutList?) {
        if index := this.FindAllSparse(Value, &lastIndex) {
            i := index - 1
            if IsSet(OutList) && OutList {
                OutList := this.Copy()
                loop lastIndex - i {
                    if this.Has(++i) {
                        OutList.Push(this.RemoveAt(i--))
                    }
                }
            } else {
                loop lastIndex - i {
                    if this.Has(++i) {
                        this.RemoveAt(i--)
                    }
                }
            }
            return index
        }
        return 0
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: no.
     *
     * Finds a value in the container using {@link Container.Prototype.Find}, then removes it and
     * returns the index at which it was located. Throws an error if not found.
     *
     * @param {*} Value - The value to find.
     *
     * @param {VarRef} [OutValue] - A variable that will receive the value that was found.
     *
     * @returns {Integer} - The index of the found value, or 0 if the value was not found.
     */
    RemoveIf(Value, &OutValue?) {
        if index := this.Find(Value, &OutValue) {
            this.RemoveAt(index)
            return index
        } else {
            return 0
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Finds a value in the container using {@link Container.Prototype.FindSparse}, then removes it and
     * returns the index at which it was located. Throws an error if not found.
     *
     * @param {*} Value - The value to find.
     *
     * @param {VarRef} [OutValue] - A variable that will receive the value that was found.
     *
     * @returns {Integer} - The index of the found value, or 0 if the value was not found.
     */
    RemoveIfSparse(Value, &OutValue?) {
        if index := this.FindSparse(Value, &OutValue) {
            this.RemoveAt(index)
            return index
        } else {
            return 0
        }
    }
    /**
     * Requires a sorted container: yes.
     *
     * Allows unset indices: yes.
     *
     * Finds a value in the container using {@link Container.Prototype.FindSparse}, then removes it and
     * returns the index at which it was located. Throws an error if not found.
     *
     * @param {*} Value - The value to find.
     *
     * @param {VarRef} [OutValue] - A variable that will receive the value that was found.
     *
     * @returns {Integer} - The index of the found value.
     *
     * @throws {UnsetItemError} - "Value not found."
     */
    RemoveSparse(Value, &OutValue?) {
        if index := this.FindSparse(Value, &OutValue) {
            this.RemoveAt(index)
            return index
        } else {
            throw UnsetItemError('Value not found.', -1, IsObject(Value) ? '{ ' Type(Value) ' }' : Value)
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Creates a new {@link Container} by calling {@link Container.Prototype.Copy} on this container,
     * and fills it with the values from this container in reverse order.
     *
     * @returns {Container}
     */
    Reverse() {
        result := this.Copy()
        len := result.Capacity := this.Length
        loop len {
            result.Push(this[-1 * A_Index])
        }
        return Result
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Creates a new {@link Container} by calling {@link Container.Prototype.Copy} on this container,
     * and fills it with the values from this container in reverse
     *
     * @returns {Container}
     */
    ReverseSparse() {
        result := this.Copy()
        len := result.Length := this.Length
        loop len {
            if this.Has(-1 * A_Index) {
                result[A_Index] := this[-1 * A_Index]
            }
        }
        return Result
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Iterates the values in the container, passing each value to a callback function. If the
     * callback function returns a nonzero value, {@link Container.Prototype.Search} returns the
     * current index. If the callback function never returns a nonzero value,
     * {@link Container.Prototype.Search} returns 0.
     *
     * @param {*} Callback - The function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: Nonzero to direct {@link Container.Prototype.Search} to return the current index.
     * Zero or an empty string to direct {@link Container.Prototype.Search} to continue processing.
     *
     * @param {VarRef} [OutValue] - If the callback returns nonzero, this variable will receive the
     * value that was passed to the function when it returned nonzero.
     *
     * @returns {Integer} - If the callback returns nonzero, the index of the value that was passed
     * to the function when it returned nonzero. If the callback never returns nonzero, 0.
     */
    Search(Callback, &OutValue?) {
        loop this.Length {
            if Callback(this[A_Index], A_Index, this) {
                OutValue := this[A_Index]
                return A_Index
            }
        }
        return 0
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * A new {@link Container} is created as the output container. {@link Container.Prototype.SearchAll}
     * iterates the values in the container, passing each value to a callback function. If the
     * callback function returns a nonzero value, the value or index is added to the output
     * container (depending on the value of parameter `ReturnIndices`). The {@link Container} is
     * returned when all values have been processed.
     *
     * @param {*} Callback -  The function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: Nonzero if {@link Container.Prototype.SearchAll} should add the value or index to the
     * output container; zero or an empty string if the item should not be added to the output container.
     *
     * @param {Boolean} [ReturnIndices = false] - If true, the index of each value that causes
     * the callback to return nonzero will be added to the output {@link Container}. If false, the
     * values themselves will be added to the output {@link Container}.
     *
     * @returns {Container} - A {@link Container} containing the items or indices, depending on the
     * value of `ReturnIndices`.
     */
    SearchAll(Callback, ReturnIndices := false) {
        if ReturnIndices {
            result := Container()
            result.Capacity := this.Length
            loop this.Length {
                if Callback(this[A_Index], A_Index, this) {
                    result.Push(A_Index)
                }
            }
        } else {
            result := Container()
            result.Capacity := this.Length
            loop this.Length {
                if Callback(this[A_Index], A_Index, this) {
                    result.Push(this[A_Index])
                }
            }
        }
        result.Capacity := result.Length
        return result
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes. Unset indices are skipped.
     *
     * A new {@link Container} is created as the output container. {@link Container.Prototype.SearchAllSparse}
     * iterates the values in the container, passing each value to a callback function. If the
     * callback function returns a nonzero value, the value or index is added to the output
     * container (depending on the value of parameter `ReturnIndices`). The {@link Container} is
     * returned when all values have been processed.
     *
     * @param {*} Callback -  The function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: Nonzero if {@link Container.Prototype.SearchAllSparse} should add the value or index to the
     * output container; zero or an empty string if the item should not be added to the output container.
     *
     * @param {Boolean} [ReturnIndices = false] - If true, the index of each value that causes
     * the callback to return nonzero will be added to the output {@link Container}. If false, the
     * values themselves will be added to the output {@link Container}.
     *
     * @returns {Container} - A {@link Container} containing the items or indices, depending on the
     * value of `ReturnIndices`.
     */
    SearchAllSparse(Callback, ReturnIndices := false) {
        if ReturnIndices {
            result := Container()
            result.Capacity := this.Length
            loop this.Length {
                if this.Has(A_Index) && Callback(this[A_Index], A_Index, this) {
                    result.Push(A_Index)
                }
            }
        } else {
            result := Container()
            result.Capacity := this.Length
            loop this.Length {
                if this.Has(A_Index) && Callback(this[A_Index], A_Index, this) {
                    result.Push(this[A_Index])
                }
            }
        }
        result.Capacity := result.Length
        return result
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes. Unset indices are skipped.
     *
     * Iterates the values in the container, passing each value to a callback function. If the
     * callback function returns a nonzero value, {@link Container.Prototype.SearchSparse} returns the
     * current index. If the callback function never returns a nonzero value,
     * {@link Container.Prototype.SearchSparse} returns 0.
     *
     * @param {*} Callback - The function can accept one to three parameters.
     *
     * Parameters:
     * - The current value.
     * - The current index.
     * - The {@link Container} object.
     *
     * Returns: Nonzero to direct {@link Container.Prototype.SearchSparse} to return the current index.
     * Zero or an empty string to direct {@link Container.Prototype.SearchSparse} to continue processing.
     *
     * @param {VarRef} [OutValue] - If the callback returns nonzero, this variable will receive the
     * value that was passed to the function when it returned nonzero.
     *
     * @returns {Integer} - If the callback returns nonzero, the index of the value that was passed
     * to the function when it returned nonzero. If the callback never returns nonzero, 0.
     */
    SearchSparse(Callback, &OutValue?) {
        loop this.Length {
            if this.Has(A_Index) && Callback(this[A_Index], A_Index, this) {
                OutValue := this[A_Index]
                return A_Index
            }
        }
        return 0
    }
    /**
     * Defines the comparator for sorting operations. Sets the property
     * {@link Container#CallbackCompare}.
     *
     * @param {*} CallbackCompare - The callback to use as a comparator for sorting operations.
     *
     * Parameters:
     * 1. A value to be compared.
     * 2. A value to be compared.
     *
     * Returns {Number} - If sorting in ascending order:
     * - If the number is less than zero it indicates the first parameter is less than the second parameter.
     * - If the number is zero it indicates the two parameters are equal.
     * - If the number is greater than zero it indicates the first parameter is greater than the second parameter.
     *
     * Invert the return value (multiply by -1) to sort in descending order.
     * @example
     * Comparator(value1, value2) {
     *     return StrLen(value1) - StrLen(value2)
     * }
     *
     * c := Container(
     *     "cat"
     *   , "elephant"
     *   , "kale"
     * )
     *
     * c.SetCallbackCompare(Comparator)
     * @
     */
    SetCallbackCompare(CallbackCompare) {
        this.CallbackCompare := CallbackCompare
    }
    /**
     * Defines the function used to associate a value in the container with a value used for
     * sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.Name
     * }
     *
     * c := Container(
     *     { Name: "obj4" }
     *   , { Name: "obj1" }
     *   , { Name: "obj3" }
     *   , { Name: "obj2" }
     * )
     * c.SetCallbackValue(CallbackValue)
     * @
     *
     * @param {*} CallbackValue - The function that returns the sort value from items in the container.
     *
     * Parameters:
     * 1. A value to be compared.
     *
     * Returns:
     * The value used for sorting.
     */
    SetCallbackValue(CallbackValue) {
        this.CallbackValue := CallbackValue
    }
    /**
     * Defines the comparator for string sort operations.
     * See {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * Sets the function to property {@link Container#CallbackCompare}.
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     */
    SetCompareStringEx(LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0) {
        if !IsNumber(LocaleName) {
            buf := this.CompareStringLocaleName := Buffer(StrPut(LocaleName, CONTAINER_DEFAULT_ENCODING))
            StrPut(LocaleName, Buf, CONTAINER_DEFAULT_ENCODING)
            LocaleName := buf.Ptr
        }
        if IsObject(NlsVersionInfo) {
            this.CompareStringNlsVersionInfo := NlsVersionInfo
            NlsVersionInfo := NlsVersionInfo.Ptr
        }
        this.CallbackCompare := Container_CompareStringEx.Bind(LocaleName, Flags, NlsVersionInfo)
    }
    /**
     * Defines the comparator for string date operations. This is only valid when dates are formatted
     * as yyyyMMddHHmmss time strings. The entire time string is not necessary, the minimum is
     * just the year, but the values must be in that order and values cannot be skipped.
     *
     * This sets the property {@link Container#CallbackCompare} with the comparator.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDate} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     */
    SetCompareDate(UseCompareDateEx := false) {
        this.CallbackCompare := UseCompareDateEx ? Container_CompareDateEx : Container_CompareDate
    }
    /**
     * Defines the comparator for date sort operations. This permits sorting dates with any format
     * of date string that can be interpeted using {@link Container_Date}. This requires that the
     * file Container_Date.ahk is included with an `#include` statement, which is already
     * included at the top of Container.ahk.
     *
     * For details about {@link Container_Date}, see Container_Date.ahk.
     *
     * {@link Container.Prototype.SetCompareDateStr} calls {@link Container.Prototype.SetDateParser}.
     *
     * @param {String} DateFormat - The format string that {@link Container_Date} uses to parse
     * date strings into usable date values.
     *
     * @param {String} [RegExOptions = ""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with a function that compares dates using a custom operation which will perform more slowly
     * but is not subject to the same limitation as {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container#CallbackCompare} is set with a function that uses
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff} which will perform more
     * quickly but cannot handle dates prior to year 1601.
     */
    SetCompareDateStr(DateFormat, RegExOptions := '', Century?, UseCompareDateEx := false) {
        this.SetDateParser(Container_DateParser(DateFormat, RegExOptions), Century ?? unset)
    }
    /**
     * This method is called by {@link Container.Prototype.SetCompareDateStr}, but if you already
     * have an instance of {@link Container_DateParser} to use, you can call
     * {@link Container.Prototype.SetDateParser} directly.
     *
     * Defines the comparator for date sort operations. This permits sorting dates with any format
     * of date string that can be interpeted using {@link Container_Date}. See the description
     * above {@link Container.Prototype.SetCompareDateStr} for more info.
     *
     * Sets three properties, {@link Container#__DateParser}, {@link Container#CallbackCompare}
     * and {@link Container#CallbackCompareValue}.
     *
     * For details about {@link Container_Date}, see the Container_Date.ahk.
     *
     * @param {Container_DateParser} DateParserObj - The {@link Container_DateParser}.
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with a function that compares dates using a custom operation which will perform more slowly
     * but is not subject to the same limitation as {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container#CallbackCompare} is set with a function that uses
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff} which will perform more
     * quickly but cannot handle dates prior to year 1601.
     */
    SetDateParser(DateParserObj, Century?, UseCompareDateEx := false) {
        this.__DateParser := DateParserObj
        if IsSet(Century) {
            if UseCompareDateEx {
                this.CallbackCompare := Container_CompareDateStr_CenturyEx.Bind(DateParserObj, Century)
                this.CallbackCompareValue := Container_CompareDateStr_Century_CompareValueEx.Bind(DateParserObj, Century)
            } else {
                this.CallbackCompare := Container_CompareDateStr_Century.Bind(DateParserObj, Century)
                this.CallbackCompareValue := Container_CompareDateStr_Century_CompareValue.Bind(DateParserObj, Century)
            }
            this.CompareDateCentury := Century
        } else {
            if UseCompareDateEx {
                this.CallbackCompare := Container_CompareDateStrEx.Bind(DateParserObj)
                this.CallbackCompareValue := Container_CompareDateStr_CompareValueEx.Bind(DateParserObj)
            } else {
                this.CallbackCompare := Container_CompareDateStr.Bind(DateParserObj)
                this.CallbackCompareValue := Container_CompareDateStr_CompareValue.Bind(DateParserObj)
            }
        }
    }
    SetId() {
        if !HasProp(this, 'IdContainer') {
            this.IdContainer := Container.__GetUid()
            Container.__Add(this.IdContainer, this)
        }
    }
    /**
     * Sets the sort type.
     *
     * ### CONTAINER_SORTTYPE_CB_DATE
     *
     * CallbackValue is provided by your code and returns a string in the format yyyyMMddHHmmss.
     *
     * Set CallbackCompare by calling {@link Container.Prototype.SetCompareDate}.
     *
     * @example
     * c := Container(
     *     { timestamp: '20250312122930' }
     *   , { timestamp: '20250411122900' }
     *   , { timestamp: '20251015091805' }
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_CB_DATE)
     * c.SetCallbackValue((value) => value.timestamp)
     * c.SetCompareDate()
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_CB_DATESTR
     *
     * CallbackValue is provided by your code and returns a date string in any format recognized
     * by {@link Container_DateParser}.
     *
     * Set CallbackCompare by calling {@link Container.Prototype.SetCompareDateStr} or
     * {@link Container.Prototype.SetDateParser}.
     *
     * @example
     * c := Container(
     *     { date: '2025-03-12 12:29:30' }
     *   , { date: '2025-04-11 12:29:00' }
     *   , { date: '2025-10-15 09:18:05' }
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_CB_DATESTR)
     * c.SetCallbackValue((value) => value.date)
     * c.SetCompareDateStr('yyyy-MM-dd HH:mm:ss')
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_CB_NUMBER
     *
     * CallbackValue is provided by your code and returns a number.
     *
     * CallbackCompare is not used.
     *
     * @example
     * c := Container(
     *     { value: 298581 }
     *   , { value: 195801 }
     *   , { value: 585929 }
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_CB_NUMBER)
     * c.SetCallbackValue((value) => value.value)
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_CB_STRING
     *
     * CallbackValue is provided by your code and returns a string.
     *
     * Set CallbackCompare by calling {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * c := Container(
     *     { name: 'obj4' }
     *   , { name: 'obj3' }
     *   , { name: 'obj1' }
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_CB_STRING)
     * c.SetCallbackValue((value) => value.name)
     * c.SetCompareStringEx()
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_CB_STRINGPTR
     *
     * CallbackValue is provided by your code and returns a pointer to a null-terminated string.
     *
     * Set CallbackCompare by calling {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * class SomeStruct {
     *     static __New() {
     *         this.DeleteProp('__New')
     *         proto := this.Prototype
     *         proto.CbSize := 16 ; arbitrary size for example
     *         proto.__pszText_offset := 8 ; arbitrary offset for example
     *     }
     *     __New(pszText) {
     *         this.Buffer := Buffer(this.cbSize)
     *         this.__pszText := Buffer(StrPut(pszText, 'cp1200'))
     *         StrPut(pszText, this.__pszText, 'cp1200')
     *         NumPut('ptr', this.__pszText.Ptr, this, this.__pszText_offset)
     *     }
     *     pszText {
     *         Get => StrGet(this.__pszText, 'cp1200')
     *         Set {
     *             bytes := StrPut(Value, 'cp1200')
     *             if bytes > this.__pszText.Size {
     *                 this.__pszText.Size := bytes
     *                 NumPut('ptr', this.__pszText.Ptr, this, this.__pszText_offset)
     *             }
     *             StrPut(Value, this.__pszText, 'cp1200')
     *         }
     *     }
     *     Ptr => this.Buffer.Ptr
     *     Size => this.Buffer.Size
     * }
     *
     * c := Container(
     *     SomeStruct("obj4")
     *   , SomeStruct("obj3")
     *   , SomeStruct("obj1")
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_CB_STRINGPTR)
     * c.SetCallbackValue((value) => value.__pszText.Ptr)
     * c.SetCompareStringEx()
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_DATE
     *
     * CallbackValue is not used.
     *
     * Values in the container are date strings in the format yyyyMMddHHmmss.
     *
     * Set CallbackCompare by calling {@link Container.Prototype.SetCompareDate}.
     *
     * @example
     * c := Container(
     *     '20250312122930'
     *   , '20250411122900'
     *   , '20251015091805'
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_DATE)
     * c.SetCompareDate()
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_DATESTR
     *
     * CallbackValue is not used.
     *
     * Values in the container are date string in any format recognized by {@link Container_DateParser}.
     *
     * Set CallbackCompare by calling {@link Container.Prototype.SetCompareDateStr} or
     * {@link Container.Prototype.SetDateParser}.
     *
     * @example
     * c := Container(
     *     '2025-03-12 12:29:30'
     *   , '2025-04-11 12:29:00'
     *   , '2025-10-15 09:18:05'
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_DATESTR)
     * c.SetCompareDateStr('yyyy-MM-dd HH:mm:ss')
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_DATEVALUE
     *
     * Your code does not assign this sort type directly. See {@link Container.Prototype.DatePreprocess}
     * for details about this sort type.
     *
     * ### CONTAINER_SORTTYPE_MISC
     *
     * CallbackValue is not used.
     *
     * CallbackCompare is provided by your code and implements custom logic to return the comparison
     * value.
     *
     * @example
     * c := Container(
     *     { id: 'CFikHajB' }
     *   , { id: 'zhLAlxeK' }
     *   , { id: 'RwaedOSw' }
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_MISC)
     * c.SetCallbackCompare(MyCallbackCompare)
     * MyCallbackCompare(value1, value2) {
     *     ; Implements some logic and returns a number indicating the relationship of the two values
     * }
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_NUMBER
     *
     * CallbackValue is not used.
     *
     * Values in the container are numbers.
     *
     * CallbackCompare is not used.
     *
     * @example
     * c := Container(
     *     298581
     *   , 195801
     *   , 585929
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_NUMBER)
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_STRING
     *
     * CallbackValue is not used.
     *
     * Values in the container are strings.
     *
     * Set CallbackCompare by calling {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * c := Container(
     *     'string4'
     *   , 'string3'
     *   , 'string1'
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_STRING)
     * c.SetCompareStringEx()
     * c.Sort()
     * @
     *
     * ### CONTAINER_SORTTYPE_STRINGPTR
     *
     * CallbackValue is not used.
     *
     * Values in the container are pointers to null-terminated strings.
     *
     * Set CallbackCompare by calling {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * buf1 := StrBuf('string4')
     * buf2 := StrBuf('string3')
     * buf3 := StrBuf('string1')
     * c := Container(
     *     buf1.Ptr
     *   , buf2.Ptr
     *   , buf3.Ptr
     * )
     * c.SetSortType(CONTAINER_SORTTYPE_STRINGPTR)
     * c.SetCompareStringEx()
     * c.Sort()
     *
     * StrBuf(str) {
     *     buf := Buffer(StrPut(str, 'cp1200'))
     *     StrPut(str, buf, 'cp1200')
     *     return buf
     * }
     * @
     *
     * @throws {ValueError} - "Invalid SortType."
     */
    SetSortType(Value) {
        switch Value, 0 {
            case CONTAINER_SORTTYPE_CB_DATE
              , CONTAINER_SORTTYPE_CB_DATESTR
              , CONTAINER_SORTTYPE_MISC
              , CONTAINER_SORTTYPE_CB_NUMBER
              , CONTAINER_SORTTYPE_CB_STRING
              , CONTAINER_SORTTYPE_CB_STRINGPTR
              , CONTAINER_SORTTYPE_DATE
              , CONTAINER_SORTTYPE_DATESTR
              , CONTAINER_SORTTYPE_NUMBER
              , CONTAINER_SORTTYPE_STRING
              , CONTAINER_SORTTYPE_STRINGPTR
              , CONTAINER_SORTTYPE_DATEVALUE:
                this.SortType := Value
            default: throw ValueError('Invalid SortType.', -1, Value)
        }
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: yes.
     *
     * Creates a new {@link Container} by calling {@link Container.Prototype.Copy} on this container,
     * then fills the new container with the values between range (IndexStart, IndexEnd) of this
     * container. Unset indices are skipped entirely.
     *
     * @param {Integer} [IndexStart = 1] - The initial index.
     * @param {Integer} [IndexEnd = this.Length] - The final index.
     * @returns {Container}
     */
    Slice(IndexStart := 1, IndexEnd := this.Length) {
        result := Container(this.SortType)
        IndexStart--
        result.Length := IndexEnd - IndexStart
        loop result.Length {
            if this.Has(++IndexStart) {
                result[A_Index] := this[IndexStart]
            }
        }
        return result
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Characteristics of {@link Container.Prototype.Sort}:
     * - In-place sorting (mutates the this object).
     * - Unstable (does not preserve original order of equal values).
     * - Can sort either ascending or descending - adjust {@link Container#CallbackCompare} appropriately.
     * - There's a built-in cutoff to use insertion sort for small arrays (16).
     *
     * If memory isn't an issue, {@link Container.Prototype.ScriptParser_QuickSort} performs about 30% faster.
     *
     * @returns {Container}
     */
    Sort() {
        if !this.Length {
            throw Error('The ``Container`` is empty.')
        }
        if this.Length == 1 {
            return this
        }
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_NUMBER:
                Compare1 := _CompareNumber1
                Compare2 := _CompareNumber2
            case CONTAINER_SORTTYPE_STRING:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareString1
                Compare2 := _CompareString2
            case CONTAINER_SORTTYPE_STRINGPTR:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
            case CONTAINER_SORTTYPE_CB_NUMBER:
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbNumber1
                Compare2 := _CompareCbNumber2
            case CONTAINER_SORTTYPE_CB_STRING:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbString1
                Compare2 := _CompareCbString2
            case CONTAINER_SORTTYPE_CB_STRINGPTR
            , CONTAINER_SORTTYPE_CB_DATE
            , CONTAINER_SORTTYPE_CB_DATESTR:
                CallbackCompare := this.CallbackCompare
                CallbackValue := this.CallbackValue
                Compare1 := _CompareCbValue1
                Compare2 := _CompareCbValue2
            case CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_DATE
            , CONTAINER_SORTTYPE_DATESTR:
                CallbackCompare := this.CallbackCompare
                Compare1 := _CompareValue1
                Compare2 := _CompareValue2
            case CONTAINER_SORTTYPE_DATEVALUE:
                Compare1 := _CompareDateValue1
                Compare2 := _CompareDateValue2
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }
        n := this.Length
        if n == 2 {
            if Compare1(this[1], this[2]) > 0 {
                t := this[1]
                this[1] := this[2]
                this[2] := t
            }
            return this
        } else if n <= CONTAINER_INSERTIONSORT_THRESHOLD {
            i := 1
            loop n - 1 {
                j := i
                b := this[++i]
                loop j {
                    if Compare2(this[j]) < 0 {
                        break
                    }
                    this[j + 1] := this[j--]
                }
                this[j + 1] := b
            }
            return this
        }

        ; Build heap
        i := Floor(n / 2)
        while i >= 1 {
            b := this[i]
            k := i
            if k * 2 <= n {
                left  := k * 2
                right := left + 1
                j := left
                if right <= n && Compare1(this[right], this[left]) > 0 {
                    j := right
                }
                if Compare2(this[j]) <= 0 {
                    i--
                    continue
                }
            } else {
                i--
                continue
            }

            while k * 2 <= n {
                j := k * 2
                if j + 1 <= n && Compare1(this[j + 1], this[j]) > 0 {
                    j++
                }
                this[k] := this[j]
                k := j
            }
            while k > 1 {
                p := Floor(k / 2)
                if Compare2(this[p]) >= 0 {
                    this[k] := b
                    i--
                    continue 2
                }
                this[k] := this[p]
                k := p
            }
        }

        ; Repeatedly move max to end
        i := n
        while i > 1 {
            t := this[1]
            this[1] := this[i]
            this[i] := t
            i--

            b := this[1]
            k := 1
            if k * 2 <= i {
                left  := k * 2
                right := left + 1
                j := left
                if right <= i && Compare1(this[right], this[left]) > 0 {
                    j := right
                }
                if Compare2(this[j]) <= 0 {
                    continue
                }
            } else {
                continue
            }

            while k * 2 <= i {
                j := k * 2
                if j + 1 <= i && Compare1(this[j + 1], this[j]) > 0 {
                    j++
                }
                this[k] := this[j]
                k := j
            }
            while k > 1 {
                p := Floor(k / 2)
                if Compare2(this[p]) >= 0 {
                    this[k] := b
                    continue 2
                }
                this[k] := this[p]
                k := p
            }
        }
        return this

        _CompareDateValue1(a, b) => a.__Container_DateValue - b.__Container_DateValue
        _CompareNumber1(a, b) => a - b
        _CompareString1(a, b) => CallbackCompare(StrPtr(a), StrPtr(b))
        _CompareCbNumber1(a, b) => CallbackValue(a) - CallbackValue(b)
        _CompareCbString1(a, b) => CallbackCompare(StrPtr(CallbackValue(a)), StrPtr(CallbackValue(b)))
        _CompareCbValue1(a, b) => CallbackCompare(CallbackValue(a), CallbackValue(b))
        _CompareValue1(a, b) => Callbackcompare(a, b)
        _CompareDateValue2(a) => a.__Container_DateValue - b.__Container_DateValue
        _CompareNumber2(a) => a - b
        _CompareString2(a) => CallbackCompare(StrPtr(a), StrPtr(b))
        _CompareCbNumber2(a) => CallbackValue(a) - CallbackValue(b)
        _CompareCbString2(a) => CallbackCompare(StrPtr(CallbackValue(a)), StrPtr(CallbackValue(b)))
        _CompareCbValue2(a) => CallbackCompare(CallbackValue(a), CallbackValue(b))
        _CompareValue2(a) => Callbackcompare(a, b)
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a string in the format yyyyMMddHHmmss.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareDate}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.timestamp
     * }
     *
     * c := Container(
     *     { timestamp: "20250312122930" }
     *   , { timestamp: "20250411122900" }
     *   , { timestamp: "20251015091805" }
     * )
     *
     * c.ToCbDate(CallbackValue)
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToCbDate(CallbackValue, UseCompareDateEx := false, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_CB_DATE)
        this.SetCallbackValue(CallbackValue)
        this.SetCompareDate(UseCompareDateEx)
        return this
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a date string in any format recognized by the
     * {@link Container_DateParser} set to {@link Container#DateParser}.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareDateStr}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     *
     * c := Container(
     *     { date: "2025-03-12 12:29:30" }
     *   , { date: "2025-04-11 12:29:00" }
     *   , { date: "2025-10-15 09:18:05" }
     * )
     *
     * c.ToCbDateStr(CallbackValue, "yyyy-MM-dd HH:mm:ss")
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {String} DateFormat - The format string that {@link Container_Date} uses to parse
     * date strings into usable date values.
     *
     * @param {String} [RegExOptions = ""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToCbDateStr(CallbackValue, DateFormat, RegExOptions := '', Century?, UseCompareDateEx := false, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_CB_DATESTR)
        this.SetCallbackValue(CallbackValue)
        this.SetCompareDateStr(DateFormat, RegExOptions, Century ?? unset, UseCompareDateEx)
        return this
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a date string in any format recognized
     * by the {@link Container_DateParser} set to {@link Container#DateParser}.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetDateParser}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     *
     * c := Container(
     *     { date: "2025-03-12 12:29:30" }
     *   , { date: "2025-04-11 12:29:00" }
     *   , { date: "2025-10-15 09:18:05" }
     * )
     *
     * dateParser := Container_DateParser("yyyy-MM-dd HH:mm:ss")
     * c.ToCbDateStrFromParser(CallbackValue, dateParser)
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {Container_DateParser} DateParserObj - The {@link Container_DateParser}.
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateStr} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToCbDateStrFromParser(CallbackValue, DateParser, Century?, UseCompareDateEx := false, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_CB_DATESTR)
        this.SetCallbackValue(CallbackValue)
        this.SetDateParser(DateParser, Century ?? unset, UseCompareDateEx)
        return this
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a number.
     * - **CallbackCompare**: Not used.
     *
     * @example
     * CallbackValue(value) {
     *     return value.value
     * }
     *
     * c := Container(
     *     { value: 298581 }
     *   , { value: 195801 }
     *   , { value: 585929 }
     * )
     *
     * c.ToCbNumber(CallbackValue)
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToCbNumber(CallbackValue, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_CB_NUMBER)
        this.SetCallbackValue(CallbackValue)
        return this
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a string.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.name
     * }
     *
     * c := Container(
     *     { name: "obj4" }
     *   , { name: "obj3" }
     *   , { name: "obj1" }
     * )
     *
     * c.ToCbString(CallbackValue)
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToCbString(CallbackValue, LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_CB_STRING)
        this.SetCallbackValue(CallbackValue)
        this.SetCompareStringEx(LocaleName, Flags, NlsVersionInfo)
        return this
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a pointer to a null-terminated string.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareStringEx}.
     *
     * If you know your code will be used for a lot of sorting and finding operations, you can
     * improve performance by storing the name / key in a buffer.
     *
     * @example
     * class ImageSamples {
     *     __New(Name, ImageData) {
     *         this.NameBuffer := Buffer(StrPut(Name, "cp1200"))
     *         StrPut(Name, this.NameBuffer, "cp1200")
     *         this.ImageData := ImageData
     *     }
     *     Name => StrGet(this.NameBuffer, "cp1200")
     * }
     *
     * CallbackValue(value) {
     *     return value.NameBuffer.Ptr
     * }
     *
     * c := Container(
     *     ImageSamples("obj4", data4)
     *   , ImageSamples("obj3", data3)
     *   , ImageSamples("obj1", data1)
     * )
     *
     * c.ToCbStringPtr(CallbackValue)
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToCbStringPtr(CallbackValue, LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_CB_STRINGPTR)
        this.SetCallbackValue(CallbackValue)
        this.SetCompareStringEx(LocaleName, Flags, NlsVersionInfo)
        return this
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareDate}.
     *
     * @example
     * c := Container(
     *     "20250312122930"
     *   , "20250411122900"
     *   , "20251015091805"
     * )
     *
     * c.ToDate()
     * @
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToDate(UseCompareDateEx := false, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_DATE)
        this.SetCompareDate(UseCompareDateEx)
        return this
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareDateStr}.
     *
     * @example
     * c := Container(
     *     "2025-03-12 12:29:30"
     *   , "2025-04-11 12:29:00"
     *   , "2025-10-15 09:18:05"
     * )
     *
     * c.ToDateStr("yyyy-MM-dd HH:mm:ss")
     * @
     *
     * @param {String} DateFormat - The format string that {@link Container_Date} uses to parse
     * date strings into usable date values.
     *
     * @param {String} [RegExOptions = ""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToDateStr(DateFormat, RegExOptions := '', Century?, UseCompareDateEx := false, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_DATESTR)
        this.SetCompareDateStr(DateFormat, RegExOptions, Century ?? unset, UseCompareDateEx)
        return this
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a date string in any format recognized
     * by the {@link Container_DateParser} set to {@link Container#DateParser}.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetDateParser}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     *
     * c := Container(
     *     "2025-03-12 12:29:30"
     *   , "2025-04-11 12:29:00"
     *   , "2025-10-15 09:18:05"
     * )
     *
     * dateParser := Container_DateParser("yyyy-MM-dd HH:mm:ss")
     * c.ToDateStrFromParser(dateParser)
     * @
     *
     * @param {Container_DateParser} DateParserObj - The {@link Container_DateParser}.
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateStr} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToDateStrFromParser(DateParser, Century?, UseCompareDateEx := false, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_DATESTR)
        this.SetDateParser(DateParser, Century ?? unset, UseCompareDateEx)
        return this
    }
    /**
     * - **CallbackValue**: Provided by your code and returns a date string in any format recognized
     * by the {@link Container_DateParser} set to {@link Container#DateParser}.
     * - **CallbackCompare**: This calls {@link Container.Prototype.DatePreprocess}.
     *
     * @example
     * CallbackValue(value) {
     *     return value.date
     * }
     *
     * c := Container(
     *     { date: "2025-03-12 12:29:30" }
     *   , { date: "2025-04-11 12:29:00" }
     *   , { date: "2025-10-15 09:18:05" }
     * )
     * c.ToDateValue(CallbackValue, "yyyy-MM-dd HH:mm:ss")
     * @
     *
     * @param {*} CallbackValue - Defines the function used to associate a value in the container
     * with a value used for sorting. Sets the function to property {@link Container#CallbackValue}.
     *
     * @param {String} DateFormat - The format string that {@link Container_Date} uses to parse
     * date strings into usable date values.
     *
     * @param {String} [RegExOptions = ""] - The RegEx options to add to the beginning of the pattern.
     * Include the close parenthesis, e.g. "i)".
     *
     * @param {String} [Century] - The century to use when parsing a 1- or 2-digit year. If not set,
     * the current century is used. If the date strings have 4-digit years, this option is ignored.
     * Sets property {@link Container#CompareDateCentury}.
     *
     * Note that you must call {@link Container.Prototype.SetDateParser} or {@link Container.Prototype.SetCompareDateStr}
     * to change the value of property {@link Container#CompareDateCentury}; changing the value directly
     * will cause unexpected behavior.
     *
     * @param {Boolean} [UseCompareDateEx = false] - If true, sets {@link Container#CallbackCompare}
     * with {@link Container_CompareDateEx}, which will perform more slowly but is not subject
     * to the same limitation as {@link Container_CompareDate} because {@link Container_CompareDateEx}
     * does not use {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm DateDiff}.
     * {@link https://www.autohotkey.com/docs/v2/lib/DateDiff.htm#Remarks DateDiff} has the following
     * limitation: "If DateTime contains an invalid timestamp or a year prior to 1601, a ValueError
     * is thrown."
     *
     * If false, {@link Container_CompareDateEx} is used which will perform more quickly but cannot
     * handle dates prior to year 1601.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToDateValue(CallbackValue, DateFormat, RegExOptions := '', Century?, UseCompareDateEx := false, PropertyName := '__Container_DateValue', Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.ToCbDateStr(CallbackValue, DateFormat, RegExOptions, Century ?? unset, UseCompareDateEx)
        this.DatePreprocess(, , PropertyName)
        return this
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: Provided by your code and implements custom logic to return the comparison
     * value.
     *
     * @example
     * CallbackCompare(value1, value2) {
     *     return StrLen(value1) - StrLen(value2)
     * }
     *
     * c := Container(
     *     "cat"
     *   , "elepehant"
     *   , "kale"
     * )
     *
     * c.ToMisc(CallbackCompare)
     * @
     *
     * @param {*} CallbackCompare - The callback to use as a comparator for sorting operations. Sets
     * the property {@link Container#CallbackCompare}.
     *
     * Parameters:
     * 1. A value to be compared.
     * 2. A value to be compared.
     *
     * Returns {Number} - If sorting in ascending order:
     * - If the number is less than zero it indicates the first parameter is less than the second parameter.
     * - If the number is zero it indicates the two parameters are equal.
     * - If the number is greater than zero it indicates the first parameter is greater than the second parameter.
     *
     * Invert the return value (multiply by -1) to sort in descending order.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToMisc(CallbackCompare, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_MISC)
        this.SetCallbackCompare(CallbackCompare)
        return this
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: Not used.
     *
     * @example
     * c := Container(
     *     298581
     *   , 195801
     *   , 585929
     * )
     *
     * c.ToNumber()
     * @
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToNumber(Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_NUMBER)
        return this
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * c := Container(
     *     "string4"
     *   , "string3"
     *   , "string1"
     * )
     *
     * c.ToString()
     * @
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToString(LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_STRING)
        this.SetCompareStringEx(LocaleName, Flags, NlsVersionInfo)
        return this
    }
    /**
     * - **CallbackValue**: Not used.
     * - **CallbackCompare**: This calls {@link Container.Prototype.SetCompareStringEx}.
     *
     * @example
     * StrBuf(str) {
     *     buf := Buffer(StrPut(str, "cp1200"))
     *     StrPut(str, buf, "cp1200")
     *     return buf
     * }
     *
     * buf1 := StrBuf("string4")
     * buf2 := StrBuf("string3")
     * buf3 := StrBuf("string1")
     *
     * c := Container(
     *     buf1.Ptr
     *   , buf2.Ptr
     *   , buf3.Ptr
     * )
     *
     * c.ToStringPtr()
     * @
     *
     * @param {String|Integer} [LocaleName = LOCALE_NAME_USER_DEFAULT] - Pointer to a locale name,
     * or one of the following predefined values. If `LocaleName` is a string, a buffer object
     * will be created to store the string value. The buffer object is set to property
     * {@link Container#CompareStringLocaleName}.
     * - LOCALE_NAME_INVARIANT
     * - LOCALE_NAME_SYSTEM_DEFAULT
     * - LOCALE_NAME_USER_DEFAULT
     *
     * @param {Integer} [Flag = 0] - See the description of the flags on
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringex}.
     * The flags each exist as global variables by the same name as indicated in the documentation. To
     * combine flags, use the bitwise "or" ( | ), e.g. `LINGUISTIC_IGNORECASE | NORM_IGNORENONSPACE`.
     *
     * @param {Integer|NlsVersionInfoEx|Buffer} [NlsVersionInfo = 0] - Either a pointer to a
     * NLSVERSIONINFOEX structure, or an {@link NlsVersionInfoEx} object, or a buffer containing an
     * NLSVERSIONINFOEX structure. If `NlsVersionInfo` is an object, the object is set to
     * property {@link Container#CompareStringNlsVersionInfo}.
     *
     * @param {...*} [Values] - Zero or more values to instantiate the container with.
     *
     * @returns {Container}
     */
    ToStringPtr(LocaleName := LOCALE_NAME_USER_DEFAULT, Flags := 0, NlsVersionInfo := 0, Values*) {
        if Values.Length {
            this.Push(Values*)
        }
        this.SetSortType(CONTAINER_SORTTYPE_STRINGPTR)
        this.SetCompareStringEx(LocaleName, Flags, NlsVersionInfo)
        return this
    }
    /**
     * Requires a sorted container: no.
     *
     * Allows unset indices: no.
     *
     * Compares every value (except the first) with the preceding value to verify that each is in
     * order.
     *
     * @param {Boolean} [InvertDirection = false] - If true, the sort order is inverted. The default
     * is ascending order.
     *
     * @throws {Error} - "Values out of order."
     * @throws {ValueError} - "Invalid SortType."
     */
    ValidateSort(InvertDirection := false) {
        condition := InvertDirection ? (n) => n < 0 : (n) => n > 0
        switch this.SortType, 0 {
            case CONTAINER_SORTTYPE_CB_DATE
            , CONTAINER_SORTTYPE_CB_DATESTR
            , CONTAINER_SORTTYPE_CB_STRINGPTR:
                callbackValue := this.CallbackValue
                callbackCompare := this.CallbackCompare
                loop this.Length - 1 {
                    if condition(callbackCompare(callbackValue(this[A_Index]), callbackValue(this[A_Index + 1]))) {
                        v1 := callbackValue(this[A_Index])
                        v2 := callbackValue(this[A_Index + 1])
                        _Throw(A_Index)
                    }
                }
            case CONTAINER_SORTTYPE_CB_STRING:
                callbackValue := this.CallbackValue
                callbackCompare := this.CallbackCompare
                loop this.Length - 1 {
                    if condition(callbackCompare(StrPtr(callbackValue(this[A_Index])), StrPtr(callbackValue(this[A_Index + 1])))) {
                        v1 := callbackValue(this[A_Index])
                        v2 := callbackValue(this[A_Index + 1])
                        _Throw(A_Index)
                    }
                }
            case CONTAINER_SORTTYPE_CB_NUMBER:
                callbackValue := this.CallbackValue
                loop this.Length - 1 {
                    if condition(callbackValue(this[A_Index]) - callbackValue(this[A_Index + 1])) {
                        v1 := callbackValue(this[A_Index])
                        v2 := callbackValue(this[A_Index + 1])
                        _Throw(A_Index)
                    }
                }
            case CONTAINER_SORTTYPE_DATEVALUE:
                loop this.Length - 1 {
                    if condition(this[A_Index].__Container_DateValue - this[A_Index + 1].__Container_DateValue) {
                        v1 := this[A_Index].__Container_DateValue
                        v2 := this[A_Index + 1].__Container_DateValue
                        _Throw(A_Index)
                    }
                }
            case CONTAINER_SORTTYPE_DATE
            , CONTAINER_SORTTYPE_DATESTR
            , CONTAINER_SORTTYPE_MISC
            , CONTAINER_SORTTYPE_STRINGPTR:
                callbackCompare := this.CallbackCompare
                loop this.Length - 1 {
                    if condition(callbackCompare(this[A_Index], this[A_Index + 1])) {
                        v1 := this[A_Index]
                        v2 := this[A_Index + 1]
                        _Throw(A_Index)
                    }
                }
            case CONTAINER_SORTTYPE_STRING:
                callbackCompare := this.CallbackCompare
                loop this.Length - 1 {
                    if condition(callbackCompare(StrPtr(this[A_Index]), StrPtr(this[A_Index + 1]))) {
                        v1 := this[A_Index]
                        v2 := this[A_Index + 1]
                        _Throw(A_Index)
                    }
                }
            case CONTAINER_SORTTYPE_NUMBER:
                loop this.Length - 1 {
                    if condition(this[A_Index] - this[A_Index + 1]) {
                        v1 := this[A_Index]
                        v2 := this[A_Index + 1]
                        _Throw(A_Index)
                    }
                }
            default: throw ValueError('Invalid SortType.', -1, this.SortType)
        }

        _Throw(i) {
            throw Error('Values out of order.', -1, 'Index: ' i ' - ' (i + 1))
        }
    }

    /**
     * @memberof Container
     * @instance
     * @type {Container_DateParser}
     */
    DateParser {
        Get => this.__DateParser
        Set => this.SetDateParser(Value)
    }
}

; https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/LibraryManager.ahk

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/LibraryManager.ahk
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * @classdesc -
 * The purpose of {@link LibraryManager} is to improve application performance by obtaining procedure
 * addresses and storing the addresses in a global variable so any subsystem that calls that procedure
 * can have access to the direct address.
 *
 * The optimal storage method for storing a procedure address that will be used repeatedly is to
 * store the address in a global variable. Each subsystem should refer to the same variable when
 * calling the procedure. {@link LibraryManager} facilitates this process.
 *
 * # Usage
 *
 * Using {@link LibraryManager} is easy, but requires a bit of preparation. See the test file
 * "test-files\test-LibraryManager.ahk" for a working example.
 *
 * ## Initialize global variables for procedure addresses
 *
 * The global variables used to store procedure addresses must be initialized. The structure of the
 * variable name is:
 *
 * <prefix>_<library name>_<procedure name>
 *
 * By default, the <prefix> is "g". The value of the prefix is defined by the global variable
 * `LIBRARYMANAGER_VAR_PREFIX` which is initialized within {@link LibraryManager.__New} (unless
 * `LIBRARYMANAGER_VAR_PREFIX` has already been set). Your code can overwrite `LIBRARYMANAGER_VAR_PREFIX`
 * and use a different prefix if necessary, but this should be avoided so open source code does not
 * need to navigate various prefixes among shared libraries. If you do need to redefine
 * `LIBRARYMANAGER_VAR_PREFIX`, note that the variables used internally by {@link LibraryManager}
 * are always `g_kernel32_GetProcAddress`, `g_kernel32_LoadLibraryW`, and
 * `g_kernel32_FreeLibrary`.
 *
 * <library name> is the literal name of the dll without the ".dll" extension.
 *
 * <procedure name> is the literal name of the procedure from which the address will be assigned
 * to the variable.
 *
 * Any characters which are invalid for use within variable names are removed from the name when used
 * to refer to a variable. The variable name is not case sensitive, but the values passed to
 * {@link LibraryManager.Call} are case sensitive.
 *
 * Internally, the variable names are dereferenced with this logic:
 *
 * @example
 *  hMod := DllCall(g_kernel32_LoadLibraryW, 'wstr', dllName, 'ptr')
 *  address := DllCall(g_kernel32_GetProcAddress, 'ptr', hMod, 'astr', procedureName, 'ptr')
 *  dllName := RegExReplace(StrReplace(dllName, '.dll', ''), LibraryManager.InvalidCharPattern, '')
 *  procedureName := RegExReplace(procedureName, LibraryManager.InvalidCharPattern, '')
 *  %LIBRARYMANAGER_VAR_PREFIX%_%dllName%_%procedureName% := address
 * @
 *
 * The default value of {@link LibraryManager.InvalidCharPattern} is "[^\p{L}0-9_\x{00A0}-\x{10FFFF}]",
 * which should correctly encapsulate AutoHotkey's requirements.
 *
 * Here are a few effective approaches to accomplish initializing the variables:
 *
 * - Use a single file which initializes the variables.
 *
 * @example
 *  global g_dllName_Procedure1,
 *  g_dllName_Procedure2,
 *  g_dllName_Procedure3,
 *  ; ...
 *  g_dllName_ProcedureN
 * @
 *
 * Then #include the file in your code. The auto-execute portion of the script must reach the
 * #included file before {@link LibraryManager} is used.
 *
 * - Use multiple files which initialize the variables. If a variable is already initialized,
 * re-initializing the variable with a `global VarName` statement has no effect and is valid.
 * For example, this is acceptable and causes no issues:
 *
 * script1.ahk:
 * @example
 *  global g_dllName_Procedure1, g_dllName_Procedure2
 * @
 *
 * script2.ahk:
 * @example
 *  global g_dllName_Procedure1, g_dllName_Procedure3
 * @
 *
 * script3.ahk:
 * @example
 * #include script1.ahk
 * token1 := LibraryManager('dllName', ['Procedure1', 'Procedure2'])
 * DllCall(g_dllName_Procedure1, 'int', 0, 'int', 0)
 *
 * ; Re-initializing the variables does not cause issues
 * ; even though `g_dllName_Procedure1` has already been
 * ; set with a value.
 * #include script2.ahk
 * token2 := LibraryManager('dllName', ['Procedure1', 'Procedure3'])
 * DllCall(g_dllName_Procedure1, 'int', 0, 'int', 0)
 * @
 *
 * Using this approach, each library can initialize the variables it needs. However, depending
 * on the structure of the code, it is possible that "script2.ahk" is not reached prior to attempting
 * to read the value of `g_dllName_Procedure1` or `g_dllName_Procedure3`, resulting in a `VarUnset`
 * error, even if the code is correctly written. One of the following approaches can be used to avoid
 * this eventuality.
 *
 * - If a custom class will rely on a set of procedures, initialize them in the static "__New" method.
 * Check if the variable is set before initializing the value with `0`.
 *
 * @example
 *  class MyClass {
 *      static __New() {
 *          global
 *          this.DeleteProp('__New')
 *          if !IsSet(g_dllName_Precedure1) {
 *              g_dllName_Procedure1 := 0
 *          }
 *          if !IsSet(g_dllName_Procedure2) {
 *              g_dllName_Procedure2 := 0
 *          }
 *          ; ...
 *      }
 *  }
 * @
 *
 * If the static method "__New" uses local variables which you do not want to be global, you can do
 * either of the following:
 *
 * Define a separate static method to handle the variables.
 *
 * @example
 *  class MyClass {
 *      static __New() {
 *          this.DeleteProp('__New')
 *          this.__InitializeProcedureVars()
 *      }
 *      static __InitializeProcedureVars() {
 *          global
 *          if !IsSet(g_dllName_Precedure1) {
 *              g_dllName_Procedure1 := 0
 *          }
 *          if !IsSet(g_dllName_Procedure2) {
 *              g_dllName_Procedure2 := 0
 *          }
 *          ; ...
 *      }
 *  }
 * @
 *
 * Reference the global variables explicitly.
 *
 * @example
 *  class MyClass {
 *      static __New() {
 *          global g_dllName_Precedure1, g_dllName_Procedure2
 *          this.DeleteProp('__New')
 *          if !IsSet(g_dllName_Precedure1) {
 *              g_dllName_Procedure1 := 0
 *          }
 *          if !IsSet(g_dllName_Procedure2) {
 *              g_dllName_Procedure2 := 0
 *          }
 *      }
 *  }
 * @
 *
 * - Use a helper function.
 *
 * @example
 *  InitializeProcedureVars() {
 *      global
 *      if !IsSet(g_dllName_Procedure1) {
 *          g_dllName_Procedure1 := 0
 *      }
 *      if !IsSet(g_dllName_Procedure2) {
 *          g_dllName_Procedure2 := 0
 *      }
 *      ; ...
 *  }
 * @
 *
 * ## Call LibraryManager.Call
 *
 * Each subsystem calls {@link LibraryManager.Call} with a `Map` object, where the keys are dll
 * file names and the values are an array of procedure names as string. {@link LibraryManager.Call}
 * then calls `LoadLibraryW` for the dlls, and calls `GetProcAddress` for the procedures.
 *
 * @example
 *  global g_dllName_Procedure1,
 *  g_dllName_Procedure2,
 *  g_dllName_Procedure3
 *
 *  procedures := Map('dllName', ['Procedure1', 'Procedure2', 'Procedure3'])
 *  token := LibraryManager(procedures)
 *
 *  ; do work
 *
 *  ; If the libraries are no longer needed
 *  token.Free()
 * @
 *
 * ## Call LibraryManagerToken.Prototype.Free
 *
 * If a subsystem no longer requires the libraries associated with one of its tokens, or if a
 * subsystem is no longer needed altogether, call {@link LibraryManagerToken.Prototype.Free} to
 * decrement the Windows API's reference count for the libraries.
 *
 * # A brief note about `LoadLibrary` and `FreeLibrary`
 *
 * The system uses reference counts to manage calls to `LoadLibrary` and `FreeLibrary`. When
 * `LoadLibrary` is called, if the library has already been loaded, the reference count is increased
 * and the same handle is returned. When `FreeLibrary` is called, the reference count is decreased.
 * If the reference count reaches 0 then the library is unloaded and the handle associated with the
 * library is no longer valid. {@link LibraryManager} handles this internally; your code is only
 * responsible for managing the token it receives from {@link LibraryManager}.
 *
 * # Persistent global variable values
 *
 * When the reference count for a library managed by {@link LibraryManager} reaches 0, any variables
 * associated with that dll do not get changed in any way; if the variable was set with a value, the
 * variable will maintain the value even after the reference count reaches 0.
 *
 * This decision was made because keeping track of which variables are in use would require
 * significant additional memory. {@link LibraryManager} would need to track what variables are
 * associated with what dlls, requiring another stored string for each variable. There is little
 * benefit to doing this, and {@link LibraryManager} works without doing it.
 */
class LibraryManager {
    static __New() {
        this.DeleteProp('__New')
        this.Tokens := LibraryManagerTokenCollection()
        this.InvalidCharPattern := 'S)[^\p{L}0-9_\x{00A0}-\x{10FFFF}]'
        this.__InitializeProcedureVars()
    }
    static Free(Token) {
        if this.Tokens.Has(Token.Id) {
            for hMod in Token.Libraries {
                DllCall(g_kernel32_FreeLibrary, 'ptr', hMod)
            }
            this.Tokens.Delete(Token.Id)
        } else {
            throw UnsetItemError('Token not found.', -1, Token.Id)
        }
    }
    static Call(Procedures*) {
        pattern := this.InvalidCharPattern
        token := LibraryManagerToken()
        this.Tokens.Set(token.Id, token)
        if Procedures[1] is Map {
            for procedureMap in Procedures {
                for dllName, procedureList in procedureMap {
                    if !(hMod := DllCall(g_kernel32_LoadLibraryW, 'wstr', dllName, 'ptr')) {
                        throw Error('Failed to load the dll.', -1, dllName)
                    }
                    this.__Load(&dllName, RegExReplace(StrReplace(dllName, '.dll', ''), pattern, ''), hMod, procedureList, &pattern)
                    token.Add(hMod)
                }
            }
        } else {
            loop Procedures.Length / 2 {
                dllName := Procedures[A_Index * 2 - 1]
                procedureList := Procedures[A_Index * 2]
                if !(hMod := DllCall(g_kernel32_LoadLibraryW, 'wstr', dllName, 'ptr')) {
                    throw Error('Failed to load the dll.', -1, dllName)
                }
                this.__Load(&dllName, RegExReplace(StrReplace(dllName, '.dll', ''), pattern, ''), hMod, procedureList, &pattern)
                token.Add(hMod)
            }
        }
        return token
    }
    static __Load(&DllName, ModifiedDllName, hMod, procedureList, &pattern) {
        global
        loop procedureList.Length {
            if !(%LIBRARYMANAGER_VAR_PREFIX%_%ModifiedDllName%_%RegExReplace(procedureList[A_Index], pattern, '')%
            := DllCall(g_kernel32_GetProcAddress, 'ptr', hMod, 'astr', procedureList[A_Index], 'ptr')) {
                throw Error('Failed to look up the procedure address.', -1, DllName ':' procedureList[A_Index])
            }
        }
    }
    static __InitializeProcedureVars() {
        global LIBRARYMANAGER_VAR_PREFIX, g_kernel32_GetProcAddress
        , g_kernel32_LoadLibraryW, g_kernel32_FreeLibrary
        if !IsSet(LIBRARYMANAGER_VAR_PREFIX) {
            LIBRARYMANAGER_VAR_PREFIX := 'g'
        }
        hMod := DllCall('GetModuleHandleW', 'wstr', 'kernel32', 'ptr')
        if !IsSet(g_kernel32_GetProcAddress) {
            g_kernel32_GetProcAddress := DllCall('GetProcAddress', 'ptr', hMod, 'astr', 'GetProcAddress', 'ptr')
        }
        if !IsSet(g_kernel32_LoadLibraryW) {
            g_kernel32_LoadLibraryW := DllCall(g_kernel32_GetProcAddress, 'ptr', hMod, 'astr', 'LoadLibraryW', 'ptr')
        }
        if !IsSet(g_kernel32_FreeLibrary) {
            g_kernel32_FreeLibrary := DllCall(g_kernel32_GetProcAddress, 'ptr', hMod, 'astr', 'FreeLibrary', 'ptr')
        }
    }
}

class LibraryManagerToken {
    __New() {
        this.Libraries := LibraryManagerLibraryCollection()
        loop {
            id := Random(0, 4294967295)
            if LibraryManager.Tokens.Has(id) {
                OutputDebug('Congratulations, you should buy a lottery ticket today.`n')
                continue
            }
            this.Id := id
            return
        }
    }
    Add(hMod) {
        this.Libraries.Push(hMod)
    }
    Free() {
        LibraryManager.Free(this)
        this.Id := this.Libraries := 0
    }
}

class LibraryManagerTokenCollection extends Map {
}
class LibraryManagerLibraryCollection extends Array {
}

; https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/structs/Rect.ahk
/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/structs/Rect.ahk
    Author: Nich-Cebolla
    License: MIT
*/

;@region Intro

/*
    As of 8/11/25: Most methods are now tested and working.
*/

/**

        Introduction

    This library provides AHK functions and methods that call common User32.dll functions related to
    RECTs, POINTs, and windows.

        Using a buffer

    This library is designed to allow RECT members of any struct at an arbitrary, static offset
    to make use of the functions. For example, consider the WINDOWINFO struct. There are two
    members that are RECTs: rcWindow at offset 4, and rcClient at offset 20. To avoid repetitive
    code and unnecessary work, the `Window32` class initializes instances like this:
    @example
        MakeWinRectObjects() {
            if this.Hwnd {
                this()
            }
            this.Rect := WinRect(this.Hwnd, false, this.Buffer, this.Offset + 4)
            this.ClientRect := WinRect(this.Hwnd, true, this.Buffer, this.Offset + 20)
        }
    @

    Though separate AHK objects, the objects set to `this.Rect` and `this.ClientRect` both make use
    of the same buffer. Whenever the values of the WINDOWINFO struct are changed, the changes are
    reflected by the AHK objects as well.

        Thread dpi awareness

    This "__Call" method exposes a way to call `SetThreadDpiAwarenessContext` before any other method
    by adding "_S" to the end of the method. By default, the thread dpi awareness context is set to
    -4. To use another value, define a property "DpiAwarenessContext" on an individual object or
    on a prototype object with the desired value. Typically you'll want to use -4 if your application
    is dpi aware. See {@link https://www.autohotkey.com/docs/v2/misc/DPIScaling.htm}.
    @example
        ; The default is already -4; this is for example.
        WinRect.Prototype.DpiAwarenessContext := -4
        hwnd := WinExist('A')
        if !hwnd {
            throw Error('Window not found.')
        }
        wrc := WinRect(hwnd)
        ; This sets the dpi awareness context to -4 prior to performing the action
        wrc.GetPos_S(&x, &y, &w, &h)
    @

    If you are not familiar with meta functions, you will want to read
    {@link https://www.autohotkey.com/docs/v2/Objects.htm#Meta_Functions}.

        Dll function addresses

    To improve performance, the first time a dll function is called from this library, the address
    is cached on `RectBase.Addresses`. The module handles are cached on `RectBase.Modules`. To
    release the handles and free the memory, call `RectBase.UnloadAll`.
*/

;@endregion


;@region Window32 cls

/**
 * Calls `GetWindowRect`. The object has a number of properties to make using it easier.
 * - cbSize - 0:4 - The size of this structure.
 * - rcWindow - 4:16 - The coordinates of the window.
 * - rcClient - 20:16 - THe coordinates of the client area.
 * - dwStyle - 36:4 - The window styles.
 * {@link https://learn.microsoft.com/en-us/windows/desktop/winmsg/window-styles}
 * - dwExStyle - 40:4 - The extende window styles.
 * {@link https://learn.microsoft.com/en-us/windows/desktop/winmsg/extended-window-styles}
 * - dwWindowStatus - 44:4 - The window status. Returns `1` if the window is active. Else, `0`.
 * - cxWindowBorders - 48:4 - The width of the window borders in pixels.
 * - cyWindowBorders - 52:4 - The height of the window border in pixels.
 * - atomWindowType - 56:2 - The window class atom.
 * {@link https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registerclassa}.
 * - wCreatorVersion - 58:2 - The Windows version of the application that created the window.
 */
class Window32 {
    static __New() {
        this.DeleteProp('__New')
        this.WindowStyles := Map()
        this.WindowExStyles := Map()
        this.WindowStyles.CaseSense := this.WindowExStyles.CaseSense := false
        this.WindowStyles.Set(
            'WS_OVERLAPPED', 0x00000000
          , 'WS_POPUP', 0x80000000
          , 'WS_CHILD', 0x40000000
          , 'WS_MINIMIZE', 0x20000000
          , 'WS_VISIBLE', 0x10000000
          , 'WS_DISABLED', 0x08000000
          , 'WS_CLIPSIBLINGS', 0x04000000
          , 'WS_CLIPCHILDREN', 0x02000000
          , 'WS_MAXIMIZE', 0x01000000
          , 'WS_CAPTION', 0x00C00000
          , 'WS_BORDER', 0x00800000
          , 'WS_DLGFRAME', 0x00400000
          , 'WS_VSCROLL', 0x00200000
          , 'WS_HSCROLL', 0x00100000
          , 'WS_SYSMENU', 0x00080000
          , 'WS_THICKFRAME', 0x00040000
          , 'WS_GROUP', 0x00020000
          , 'WS_TABSTOP', 0x00010000
          , 'WS_MINIMIZEBOX', 0x00020000
          , 'WS_MAXIMIZEBOX', 0x00010000
        )
        this.WindowExStyles.Set(
            'WS_EX_DLGMODALFRAME', 0x00000001
          , 'WS_EX_NOPARENTNOTIFY', 0x00000004
          , 'WS_EX_TOPMOST', 0x00000008
          , 'WS_EX_ACCEPTFILES', 0x00000010
          , 'WS_EX_TRANSPARENT', 0x00000020
          , 'WS_EX_MDICHILD', 0x00000040
          , 'WS_EX_TOOLWINDOW', 0x00000080
          , 'WS_EX_WINDOWEDGE', 0x00000100
          , 'WS_EX_CLIENTEDGE', 0x00000200
          , 'WS_EX_CONTEXTHELP', 0x00000400
          , 'WS_EX_RIGHT', 0x00001000
          , 'WS_EX_LEFT', 0x00000000
          , 'WS_EX_RTLREADING', 0x00002000
          , 'WS_EX_LTRREADING', 0x00000000
          , 'WS_EX_LEFTSCROLLBAR', 0x00004000
          , 'WS_EX_RIGHTSCROLLBAR', 0x00000000
          , 'WS_EX_CONTROLPARENT', 0x00010000
          , 'WS_EX_STATICEDGE', 0x00020000
          , 'WS_EX_APPWINDOW', 0x00040000
        )
        this.Prototype.cbSize := 60
        this.Make(this)
    }
    static FromDesktop(Buf?, Offset := 0) => this(DllCall(RectBase.GetDesktopWindow, 'ptr'), Buf ?? unset, Offset)
    static FromForeground(Buf?, Offset := 0) => this(DllCall(RectBase.GetForegroundWindow, 'ptr'), Buf ?? unset, Offset)
    /**
     * @param Cmd -
     * - 2 : Returns a handle to the window below the given window.
     * - 3 : Returns a handle to the window above the given window.
     */
    static FromCursor(Buf?, Offset := 0) {
        pt := Point()
        if !DllCall(RectBase.GetCursorPos, 'ptr', pt, 'int') {
            throw OSError()
        }
        return this(DllCall(RectBase.WindowFromPoint, 'int', pt.Value, 'ptr'), Buf ?? unset, Offset)
    }
    static FromNext(Hwnd, Cmd, Buf?, Offset := 0) => this(DllCall(RectBase.GetNextWindow, 'ptr', IsObject(Hwnd) ? Hwnd.Hwnd : Hwnd, 'uint', Cmd, 'ptr'), Buf ?? unset, Offset)
    static FromParent(Hwnd, Buf?, Offset := 0) => this(DllCall(RectBase.GetParent, 'ptr', IsObject(Hwnd) ? Hwnd.Hwnd : Hwnd, 'ptr'), Buf ?? unset, Offset)
    static FromPoint(X, Y, Buf?, Offset := 0) => this(DllCall(RectBase.WindowFromPoint, 'int', (X & 0xFFFFFFFF) | (Y << 32), 'ptr'), Buf ?? unset, Offset)
    static FromShell(Buf?, Offset := 0) => this(DllCall(RectBase.GetShellWindow, 'ptr'), Buf ?? unset, Offset)
    static FromTop(Hwnd := 0, Buf?, Offset := 0) => this(DllCall(RectBase.GetTopWindow, 'ptr', IsObject(Hwnd) ? Hwnd.Hwnd : Hwnd, 'ptr'), Buf ?? unset, Offset)
    /**
     * @param Cmd -
     * - GW_CHILD - 5 - The retrieved handle identifies the child window at the top of the Z order,
     *  if the specified window is a parent window; otherwise, the retrieved handle is NULL. The
     *  function examines only child windows of the specified window. It does not examine descendant
     *  windows.
     *
     * - GW_ENABLEDPOPUP - 6 - The retrieved handle identifies the enabled popup window owned by the
     *  specified window (the search uses the first such window found using GW_HwndNEXT); otherwise,
     *  if there are no enabled popup windows, the retrieved handle is that of the specified window.
     *
     * - GW_HwndFIRST - 0 - The retrieved handle identifies the window of the same type that is highest
     *  in the Z order. If the specified window is a topmost window, the handle identifies a topmost
     *  window. If the specified window is a top-level window, the handle identifies a top-level
     *  window. If the specified window is a child window, the handle identifies a sibling window.
     *
     * - GW_HwndLAST - 1 - The retrieved handle identifies the window of the same type that is lowest
     *  in the Z order. If the specified window is a topmost window, the handle identifies a topmost
     *  window. If the specified window is a top-level window, the handle identifies a top-level window.
     *  If the specified window is a child window, the handle identifies a sibling window.
     *
     * - GW_HwndNEXT - 2 - The retrieved handle identifies the window below the specified window in
     *  the Z order. If the specified window is a topmost window, the handle identifies a topmost
     *  window. If the specified window is a top-level window, the handle identifies a top-level
     *  window. If the specified window is a child window, the handle identifies a sibling window.
     *
     * - GW_HwndPREV - 3 - The retrieved handle identifies the window above the specified window in
     *  the Z order. If the specified window is a topmost window, the handle identifies a topmost
     *  window. If the specified window is a top-level window, the handle identifies a top-level
     *  window. If the specified window is a child window, the handle identifies a sibling window.
     *
     * - GW_OWNER - 4 - The retrieved handle identifies the specified window's owner window, if any.
     *  For more information, see Owned Windows.
     */
    static Get(Hwnd, Cmd, Buf?, Offset := 0) => this(DllCall(RectBase.GetWindow, 'ptr', IsObject(Hwnd) ? Hwnd.Hwnd : Hwnd, 'uint', Cmd, 'ptr'), Buf ?? unset, Offset)
    static Make(Cls, Prefix := '', Suffix := '') {
        Proto := Cls.Prototype
        if !HasMethod(Cls, '__Call') {
            Cls.DefineProp('__Call', { Call: RectSetThreadDpiAwareness__Call })
        }
        if !HasMethod(Proto, '__Call') {
            Proto.DefineProp('__Call', { Call: RectSetThreadDpiAwareness__Call })
        }
        Proto.DefineProp(Prefix 'AdjustRectEx' Suffix, { Call: Window32AdjustRectEx })
        Proto.DefineProp(Prefix 'BringToTop' Suffix, { Call: Window32BringToTop })
        Proto.DefineProp(Prefix 'ChildFromCursor' Suffix, { Call: Window32ChildFromCursor })
        Proto.DefineProp(Prefix 'ChildFromCursorEx' Suffix, { Call: Window32ChildFromCursorEx })
        Proto.DefineProp(Prefix 'ChildFromPoint' Suffix, { Call: Window32ChildFromPoint })
        Proto.DefineProp(Prefix 'ChildFromPointEx' Suffix, { Call: Window32ChildFromPointEx })
        Proto.DefineProp(Prefix 'Dispose' Suffix, { Call: Window32Dispose })
        Proto.DefineProp(Prefix 'Dpi' Suffix, { Get: Window32GetDpi })
        Proto.DefineProp(Prefix 'EnumChildWindows' Suffix, { Call: Window32EnumChildWindows })
        Proto.DefineProp(Prefix 'GetChildBoundingRect' Suffix, { Call: Window32GetChildBoundingRect })
        Proto.DefineProp(Prefix 'GetClientRect' Suffix, { Call: Window32GetClientRect })
        Proto.DefineProp(Prefix 'GetExStyle' Suffix, { Call: Window32GetExStyle })
        Proto.DefineProp(Prefix 'Monitor' Suffix, { Get: Window32GetMonitor })
        Proto.DefineProp(Prefix 'GetStyle' Suffix, { Call: Window32GetStyle })
        Proto.DefineProp(Prefix 'HasExStyle' Suffix, { Call: Window32HasExStyle })
        Proto.DefineProp(Prefix 'HasStyle' Suffix, { Call: Window32HasStyle })
        Proto.DefineProp(Prefix 'IsChild' Suffix, { Call: Window32IsChild })
        Proto.DefineProp(Prefix 'IsParent' Suffix, { Call: Window32IsParent })
        Proto.DefineProp(Prefix 'MoveClient' Suffix, { Call: Window32MoveClient })
        Proto.DefineProp(Prefix 'RealChildFromPoint' Suffix, { Call: Window32RealChildFromPoint })
        Proto.DefineProp(Prefix 'SetActive' Suffix, { Call: Window32SetActive })
        Proto.DefineProp(Prefix 'SetForeground' Suffix, { Call: Window32SetForeground })
        Proto.DefineProp(Prefix 'SetParent' Suffix, { Call: Window32SetParent })
        Proto.DefineProp(Prefix 'SetPosKeepAspectRatio' Suffix, { Call: Window32SetPosKeepAspectRatio })
        Proto.DefineProp(Prefix 'Show' Suffix, { Call: Window32Show })
        Proto.DefineProp(Prefix 'Visible' Suffix, { Get: Window32IsVisible })
        Proto.DefineProp('Ptr', { Get: RectGetPtrFromBuffer })
        Proto.DefineProp('Size', { Get: RectGetSizeFromBuffer })
    }
    __New(Hwnd := 0, Buf?, Offset := 0) {
        this.Hwnd := Hwnd
        if IsSet(Buf) {
            if Buf.Size < this.cbSize + Offset {
                throw Error('The buffer`'s size is insufficient. The size must be 60 + offset or greater.')
            }
            this.Buffer := Buf
        } else {
            this.Buffer := Buffer(this.cbSize + Offset)
        }
        this.Offset := Offset
        NumPut('uint', this.cbSize, this.Buffer, this.Offset)
        this.MakeWinRectObjects()
    }
    Call(*) {
        if !DllCall(RectBase.GetWindowInfo, 'ptr', this.Hwnd, 'ptr', this, 'int') {
            throw OSError()
        }
    }
    /**
     * @description - Sets a callback that updates the object's property "Hwnd" when
     * `Window32.Prototype.Call` is called. By default, `Window32.Prototype.Call` does not
     * update the "Hwnd" property, and instead calls `GetWindowRect` with the current "Hwnd". When
     * `Window32.Prototype.SetCallback` is called, a new method "Call" is defined that calls
     * the callback function and uses the return value to update the property "Hwnd", then calls
     * `GetWindowRect` using that new handle. To remove the callback and return the "Call" method
     * to its original functionality, pass zero or an empty string to `Callback`.
     *
     * This library includes a number of functions that are useful for this, each beginning with
     * "Window32Callback". However, your code will likely benefit from knowing when no window handle
     * is returned by one of the functions, so your code can respond in some type of way. To write your
     * own function that makes use of any of the built-in functions, you can define it this way:
     *
     * If your code does not need the `Window32` object, exclude it using the "*" operator:
     * @example
     *  MyHelperFunc(*) {
     *      hwnd := Window32CallbackFromForeground()
     *      if hwnd {
     *          return hwnd
     *      } else {
     *          ; do something
     *      }
     *  }
     *
     *  win := Window32()
     *  win.SetCallback(MyHelperFunc)
     *  win()
     * @
     *
     * If your code does need the `Window32` object, it will be the first and only parameter.
     * @example
     *  MyHelperFunc(win) {
     *      hwnd := Window32CallbackFromParent(win)
     *      if hwnd {
     *          return hwnd
     *      } else {
     *          ; do something
     *      }
     *  }
     *
     *  hwnd := WinExist('A')
     *  if !hwnd {
     *      throw Error('Window not found.')
     *  }
     *  win := Window32(hwnd)
     *  win.SetCallback(MyHelperFunc)
     *  win()
     *  MsgBox(win.Hwnd == hwnd) ; 0 or 1 depending if a parent window exists
     * @
     *
     * Here's how to use a `Point` object to return the window underneath the Cursor. To avoid relying
     * on global variables, we're going to make a function object that retains a `Point` object as
     * a property.
     * @example
     *  MyFuncObj := { Point: Point() }
     *  MyFuncObj.Point.SetCallAction(2)
     *  MyFuncObj.DefineProp('Call', { Call: MyFunc })
     *  win := Window32()
     *  win.SetCallback(MyFuncObj)
     *  MyFuncObj := unset ; to demonstrate no global variables are needed (other than the function)
     *  win()
     *  MsgBox(win.Hwnd)
     *
     *  MyFunc(Self, *) {
     *      hwnd := Self.Point.Call()
     *      if hwnd {
     *          return hwnd
     *      } else {
     *          ; do something
     *      }
     *  }
     * @
     *
     * @param {*} Callback - A `Func` or callable object that accepts the `Window32` object as its
     * only parameter, and that returns a new "Hwnd" value. If the callback returns zero or an empty
     * string, the property "Hwnd" will not be updated and `GetWindowRect` will not be called.
     * If the callback returns an integer, the property "Hwnd" is updated and `GetWindowRect` is
     * called. If the callback returns another type of value, a TypeError is thrown.
     */
    SetCallback(Callback) {
        if Callback {
            this.DefineProp('Callback', { Call: Callback })
            this.DefineProp('Call', Window32.Prototype.GetOwnPropDesc('__CallWithCallback'))
        } else {
            this.DeleteProp('Callback')
            this.DefineProp('Call', Window32.Prototype.GetOwnPropDesc('Call'))
        }
    }
    __CallWithCallback() {
        if hwnd := this.Callback() {
            if IsInteger(hwnd) {
                this.Hwnd := hwnd
            } else {
                throw TypeError('Invalid ``Hwnd`` returned.', -1, Type(hwnd))
            }
            if !DllCall(RectBase.GetWindowInfo, 'ptr', this.Hwnd, 'ptr', this, 'int') {
                throw OSError()
            }
            return hwnd
        }
    }
    Activate() => WinActivate(this.Hwnd)
    Close() => WinClose(this.Hwnd)
    GetControls() => WinGetControls(this.Hwnd)
    GetControlsHwnd() => WinGetControlsHwnd(this.Hwnd)
    Hide() => WinHide(this.Hwnd)
    Kill() => WinKill(this.Hwnd)
    /**
     * @description - Defines a property "Point" with a value of an instance of `Point`.
     * @param {Integer} [Action = 1] - A value to pass to {@link Point#SetCallAction}.
     */
    MakePoint(Action := 1) {
        this.DefineProp('Point', { Value: Point() })
        this.Point.SetCallAction(Action)
    }
    MakeWinRectObjects() {
        if this.Hwnd {
            this()
        }
        this.Rect := WinRect(this.Hwnd, 0, this.Buffer, this.Offset + 4)
        this.ClientRect := WinRect(this.Hwnd, 1, this.Buffer, this.Offset + 20)
    }
    Maximize() => WinMaximize(this.Hwnd)
    Minimize() => WinMinimize(this.Hwnd)
    MoveBottom() => WinMoveBottom(this.Hwnd)
    MoveTop() => WinMoveTop(this.Hwnd)
    Redraw() => WinRedraw(this.Hwnd)
    Restore() => WinRestore(this.Hwnd)
    SetAlwaysOnTop() => WinSetAlwaysOnTop(this.Hwnd)
    SetEnabled(NewSetting) => WinSetEnabled(NewSetting, this.Hwnd)
    SetRegion(Options?) => WinSetRegion(Options ?? unset, this.Hwnd)
    SetStyle(Value) => WinSetStyle(Value, this.Hwnd)
    SetExStyle(Value) => WinSetExStyle(Value, this.Hwnd)
    SetTransparent(N) => WinSetTransparent(N, this.Hwnd)
    WaitActive(Timeout?) => WinWaitActive(this.Hwnd, , Timeout ?? Unset)
    WaitNotActive(Timeout?) => WinWaitNotActive(this.Hwnd, , Timeout ?? unset)
    WaitClose(Timeout?) => WinWaitClose(this.Hwnd, , Timeout ?? unset)
    Active {
        Get => WinActive(this.Hwnd)
        Set {
            if Value {
                WinActivate(this.Hwnd)
            } else {
                WinMinimize(this.Hwnd)
            }
        }
    }
    Atom => NumGet(this, 56, 'short')
    BorderHeight => NumGet(this, 52, 'int')
    BorderWidth => NumGet(this, 48, 'int')
    Class => WinGetClass(this.Hwnd)
    CreatorVersion => NumGet(this, 58, 'short')
    Exist => WinExist(this.Hwnd)
    ExStyle => NumGet(this, 40, 'uint')
    Maximized => WinGetMinMax(this.Hwnd) == 1
    Minimized => WinGetMinMax(this.Hwnd) == -1
    PID => WinGetPid(this.Hwnd)
    ProcessName => WinGetProcessName(this.Hwnd)
    ProcessPath => WinGetProcessPath(this.Hwnd)
    Status => NumGet(this, 44, 'int')
    Style => NumGet(this, 36, 'uint')
    Text => WinGetText(this.Hwnd)
    Title {
        Get => WinGetTitle(this.Hwnd)
        Set => WinSetTitle(Value, this.Hwnd)
    }
    TransColor {
        Get => WinGetTransColor(this.Hwnd)
        Set => WinSetTransColor(Value, this.Hwnd)
    }
}

;@endregion


;@region WinRect cls

class WinRect extends Rect {
    static __New() {
        this.DeleteProp('__New')
        this.Make(this)
    }
    static Make(Cls, Prefix := '', Suffix := '') {
        Proto := Cls.Prototype
        if !HasMethod(Cls, '__Call') {
            Cls.DefineProp('__Call', { Call: RectSetThreadDpiAwareness__Call })
        }
        if !HasMethod(Proto, '__Call') {
            Proto.DefineProp('__Call', { Call: RectSetThreadDpiAwareness__Call })
        }
        Proto.DefineProp(Prefix 'Apply' Suffix, { Call: WinRectApply })
        Proto.DefineProp(Prefix 'Dispose' Suffix, { Call: RectDispose })
        Proto.DefineProp(Prefix 'GetPos' Suffix, { Call: WinRectGetPos })
        Proto.DefineProp(Prefix 'MapPoints' Suffix, { Call: WinRectMapPoints })
        Proto.DefineProp(Prefix 'Move' Suffix, { Call: WinRectMove })
        Proto.DefineProp(Prefix 'Update' Suffix, { Call: WinRectUpdate })
        Proto.DefineProp('Ptr', { Get: RectGetPtrFromBuffer })
        Proto.DefineProp('Size', { Get: RectGetSizeFromBuffer })
    }
    /**
     * @param {Integer} [Hwnd = 0] - The window handle.
     * @param {Integer} [Flag = 0] - A flag that determines what function is called when the
     * buffer's values are updated using `WinRectGetPos` or `WinRectUpdate`.
     * - 0 : `GetWindowRect`
     * - 1 : `GetClientRect`
     * - 2 : `DwmGetWindowAttribute` passing DWMWA_EXTENDED_FRAME_BOUNDS to dwAttribute.
     *
     * Some controls / windows will cause `DwmGetWindowAttribute` to throw an error.
     *
     * For more information see {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowrect}.
     */
    __New(Hwnd := 0, Flag := 0, Buf?, Offset := 0) {
        this.Hwnd := Hwnd
        if IsSet(Buf) {
            if Buf.Size < 16 + Offset {
                throw Error('The buffer`'s size is insufficient. The size must be 16 + offset or greater.')
            }
            this.Buffer := Buf
        } else {
            this.Buffer := Buffer(16 + Offset)
        }
        this.Offset := Offset
        this.Flag := Flag
        if Hwnd {
            this()
        }
    }
    Call(*) {
        switch this.Flag, 0 {
            case 0:
                DllCall(RectBase.GetWindowRect, 'ptr', this.Hwnd, 'ptr', this, 'int')
            case 1:
                DllCall(RectBase.GetClientRect, 'ptr', this.Hwnd, 'ptr', this, 'int')
            case 2:
                if HRESULT := DllCall(RectBase.Dwmapi_DwmGetWindowAttribute, 'ptr', this.Hwnd, 'uint', 9, 'ptr', this.Buffer.Ptr, 'uint', 16, 'uint') {
                    throw oserror('``DwmGetWindowAttribute`` failed.', -1, 'HRESULT: ' Format('{:X}', HRESULT))
                }
        }
    }
}

;@endregion


;@region Rect cls

class Rect extends RectBase {
    static FromDimensions(X, Y, W, H, Buf?, Offset := 0) => this(X, Y, X + W, Y + H, Buf ?? unset, Offset)
    static FromCursor() {
        rc := this()
        DllCall(RectBase.GetCursorPos, 'ptr', rc, 'int')
        rc.R := rc.L
        rc.B := rc.T
        return rc
    }
    __New(L := 0, T := 0, R := 0, B := 0, Buf?, Offset := 0) {
        if IsSet(Buf) {
            if Buf.Size < 16 + Offset {
                throw Error('The buffer`'s size is insufficient. The size must be 16 + offset or greater.')
            }
            this.Buffer := Buf
        } else {
            this.Buffer := Buffer(16 + Offset)
        }
        this.Offset := Offset
        NumPut('int', L, 'int', T, 'int', R, 'int', B, this.Buffer, Offset)
    }
}

;@endregion


;@region RectBase

class RectBase {
    static __New() {
        this.DeleteProp('__New')
        this.Modules := Map()
        this.Addresses := Map()
        this.Modules.CaseSense := this.Addresses.CaseSense := false
        this.ResidentModules := [ 'User32', 'Kernel32', 'ComCtl32', 'Gdi32' ]
        for dllName in this.ResidentModules {
            this.Modules.Set(dllName, DllCall('GetModuleHandle', 'str', dllName, 'ptr'))
        }
        this.Make(this)
    }
    static __Get(Name, Params) {
        if this.Addresses.Has(Name) {
            return this.Addresses.Get(Name)
        }
        if InStr(Name, '_') {
            modName := StrReplace(SubStr(Name, 1, InStr(Name, '_', , , -1) - 1), '_', '\')
            if this.Modules.Has(modName) {
                hModule := this.Modules.Get(modName)
            } else {
                hModule := DllCall('LoadLibrary', 'str', SubStr(Name, 1, InStr(Name, '_', , , -1) - 1) '.dll', 'ptr')
                if hModule {
                    this.Modules.Set(modName, hModule)
                } else {
                    throw Error('Unable to locate module.', -1, modName)
                }
            }
            _name := SubStr(Name, InStr(Name, '_', , , -1) + 1)
            for modName, hModule in this.Modules {
                if address := DllCall('GetProcAddress', 'ptr', hModule, 'Astr', _name, 'ptr') {
                    this.Addresses.Set(Name, address)
                    return address
                }
            }
            for dllName in this.ResidentModules {
                if address := DllCall('GetProcAddress', 'ptr', this.Modules.Get(dllName), 'Astr', _name, 'ptr') {
                    this.Addresses.Set(Name, address)
                    return address
                }
            }
            throw Error('Unable to locate the function.', -1, Name)
        } else {
            for dllName in this.ResidentModules {
                if address := DllCall('GetProcAddress', 'ptr', this.Modules.Get(dllName), 'Astr', Name, 'ptr') {
                    this.Addresses.Set(Name, address)
                    return address
                }
            }
            return Name
        }
    }
    static UnloadAll(*) {
        for modName, hModule in this.Modules {
            DllCall('FreeLibrary', 'ptr', hModule)
        }
        this.Modules.Clear()
        this.Addresses.Clear()
    }
    static Make(Cls, Prefix := '', Suffix := '') {
        Proto := Cls.Prototype
        if !HasMethod(Cls, '__Call') {
            Cls.DefineProp('__Call', { Call: RectSetThreadDpiAwareness__Call })
        }
        if !HasMethod(Proto, '__Call') {
            Proto.DefineProp('__Call', { Call: RectSetThreadDpiAwareness__Call })
        }
        Proto.DefineProp(Prefix 'B' Suffix, { Get: RectGetCoordinate.Bind(12), Set: RectSetCoordinate.Bind(12) })
        Proto.DefineProp(Prefix 'BL' Suffix, { Get: RectGetPoint.Bind(0, 12) })
        Proto.DefineProp(Prefix 'BR' Suffix, { Get: RectGetPoint.Bind(8, 12) })
        Proto.DefineProp(Prefix 'Clone' Suffix, { Call: RectClone })
        Proto.DefineProp(Prefix 'Dispose' Suffix, { Call: RectDispose })
        Proto.DefineProp(Prefix 'Dpi' Suffix, { Get: RectGetDpi })
        Proto.DefineProp(Prefix 'Equal' Suffix, { Call: RectEqual })
        Proto.DefineProp(Prefix 'GetHeightSegment' Suffix, { Call: RectGetHeightSegment })
        Proto.DefineProp(Prefix 'GetWidthSegment' Suffix, { Call: RectGetWidthSegment })
        Proto.DefineProp(Prefix 'H' Suffix, { Get: RectGetLength.Bind(4), Set: RectSetLength.Bind(4) })
        Proto.DefineProp(Prefix 'Inflate' Suffix, { Call: RectInflate })
        Proto.DefineProp(Prefix 'Intersect' Suffix, { Call: RectIntersect })
        Proto.DefineProp(Prefix 'IsEmpty' Suffix, { Call: RectIsEmpty })
        Proto.DefineProp(Prefix 'L' Suffix, { Get: RectGetCoordinate.Bind(0), Set: RectSetCoordinate.Bind(0) })
        Proto.DefineProp(Prefix 'MidX' Suffix, { Get: (Self) => RectGetWidthSegment(Self, 2) })
        Proto.DefineProp(Prefix 'MidY' Suffix, { Get: (Self) => RectGetHeightSegment(Self, 2) })
        Proto.DefineProp(Prefix 'Monitor' Suffix, { Get: RectGetMonitor })
        Proto.DefineProp(Prefix 'MoveAdjacent' Suffix, { Call: RectMoveAdjacent })
        Proto.DefineProp(Prefix 'OffsetRect' Suffix, { Call: RectOffset })
        Proto.DefineProp(Prefix 'PtIn' Suffix, { Call: RectPtIn })
        Proto.DefineProp(Prefix 'R' Suffix, { Get: RectGetCoordinate.Bind(8), Set: RectSetCoordinate.Bind(8) })
        Proto.DefineProp(Prefix 'Set' Suffix, { Call: RectSet })
        Proto.DefineProp(Prefix 'Subtract' Suffix, { Call: RectSubtract })
        Proto.DefineProp(Prefix 'T' Suffix, { Get: RectGetCoordinate.Bind(4), Set: RectSetCoordinate.Bind(4) })
        Proto.DefineProp(Prefix 'TL' Suffix, { Get: RectGetPoint.Bind(0, 4) })
        Proto.DefineProp(Prefix 'ToClient' Suffix, { Call: RectToClient })
        Proto.DefineProp(Prefix 'ToScreen' Suffix, { Call: RectToScreen })
        Proto.DefineProp(Prefix 'ToString' Suffix, { Call: RectToString })
        Proto.DefineProp(Prefix 'ToStringDeconstructed' Suffix, { Call: RectToStringDeconstructed })
        Proto.DefineProp(Prefix 'TR' Suffix, { Get: RectGetPoint.Bind(8, 4) })
        Proto.DefineProp(Prefix 'Union' Suffix, { Call: RectUnion })
        Proto.DefineProp(Prefix 'Union' Suffix, { Call: RectUnion })
        Proto.DefineProp(Prefix 'W' Suffix, { Get: RectGetLength.Bind(0), Set: RectSetLength.Bind(0) })
        Proto.DefineProp('Ptr', { Get: RectGetPtrFromBuffer })
        Proto.DefineProp('Size', { Get: RectGetSizeFromBuffer })
    }
}

;@endregion


;@region Point cls

class Point {
    static __New() {
        this.DeleteProp('__New')
        this.Make(this)
    }
    static FromCaret() {
        pt := Point()
        DllCall(RectBase.GetCaretPos, 'ptr', pt, 'int')
        return pt
    }
    static FromCursor() {
        pt := Point()
        DllCall(RectBase.GetCursorPos, 'ptr', pt, 'int')
        return pt
    }
    static Make(Cls, Prefix := '', Suffix := '') {
        Proto := Cls.Prototype
        if !HasMethod(Cls, '__Call') {
            Cls.DefineProp('__Call', { Call: RectSetThreadDpiAwareness__Call })
        }
        if !HasMethod(Proto, '__Call') {
            Proto.DefineProp('__Call', { Call: RectSetThreadDpiAwareness__Call })
        }
        Proto.DefineProp(Prefix 'Clone' Suffix, { Call: PtClone })
        Proto.DefineProp(Prefix 'CursorPosToString' Suffix, { Call: PtCursorPosToString })
        Proto.DefineProp(Prefix 'Dispose' Suffix, { Call: RectDispose })
        Proto.DefineProp(Prefix 'Dpi' Suffix, { Get: PtGetDpi })
        Proto.DefineProp(Prefix 'GetCursorPos' Suffix, { Call: PtGetCursorPos })
        Proto.DefineProp(Prefix 'LogicalToPhysical' Suffix, { Call: PtLogicalToPhysical })
        Proto.DefineProp(Prefix 'LogicalToPhysicalForPerMonitorDPI' Suffix, { Call: PtLogicalToPhysicalForPerMonitorDPI })
        Proto.DefineProp(Prefix 'Monitor' Suffix, { Get: PtGetMonitor })
        Proto.DefineProp(Prefix 'PhysicalToLogical' Suffix, { Call: PtPhysicalToLogical })
        Proto.DefineProp(Prefix 'PhysicalToLogicalForPerMonitorDPI' Suffix, { Call: PtPhysicalToLogicalForPerMonitorDPI })
        Proto.DefineProp(Prefix 'SetCaretPos' Suffix, { Call: PtSetCaretPos })
        Proto.DefineProp(Prefix 'ToClient' Suffix, { Call: PtToClient })
        Proto.DefineProp(Prefix 'ToScreen' Suffix, { Call: PtToScreen })
        Proto.DefineProp(Prefix 'Value' Suffix, { Get: PtGetValue })
        Proto.DefineProp(Prefix 'X' Suffix, { Get: RectGetCoordinate.Bind(0), Set: RectSetCoordinate.Bind(0) })
        Proto.DefineProp(Prefix 'Y' Suffix, { Get: RectGetCoordinate.Bind(4), Set: RectSetCoordinate.Bind(4) })
        Proto.DefineProp('Ptr', { Get: RectGetPtrFromBuffer })
        Proto.DefineProp('Size', { Get: RectGetSizeFromBuffer })
    }
    __New(X := 0, Y := 0, Buf?, Offset := 0) {
        if IsSet(Buf) {
            if Buf.Size < 8 + Offset {
                throw Error('The buffer`'s size is insufficient. The size must be 8 + offset or greater.')
            }
            this.Buffer := Buf
        } else {
            this.Buffer := Buffer(8 + Offset)
        }
        this.Offset := Offset
        NumPut('int', X, 'int', Y, this.Buffer, Offset)
    }
    Call(*) {
        if !DllCall(RectBase.GetCursorPos, 'ptr', this, 'int') {
            throw OSError()
        }
    }
    Click(Options := '') => Click(this.X ' ' this.Y ' ' Options)
    ClickDrag(WhichButton, X?, Y?, Speed?, Relative?) => MouseClickDrag(WhichButton, this.X, this.Y, X ?? this.X, Y ?? this.Y, Speed ?? unset, Relative ?? Unset)
    MouseMove(Speed?, Relative?) => MouseMove(this.X, this.Y, Speed ?? Unset, Relative ?? unset)
    GetPixelColor(Mode?) {
        if IsSet(Mode) {
            return PixelGetColor(this.X, this.Y, Mode)
        } else {
            Modes := [ '', 'Alt', 'Slow' ]
            loop {
                if color := PixelGetColor(this.X, this.Y, Modes[A_Index]) || A_Index >= 3 {
                    return color
                }
            }
        }
    }
    /**
     * @param {Integer} Id -
     * - 1 : The default, which updates the object's X and Y values to the cursor's current position.
     * - 2 : Updates the object's X and Y values to the cursor's current position, and calls
     * `WindowFromPoint`, returning the window handle if one is obtained, else returning `0`.
     * - 3 : Updates the object's X and Y values to the cursor's current position, and calls
     * `PixelGetColor`. Note that the X and Y values will always be relative to the screen, and that
     * the default mode for `PixelGetColor` is "Client". Your code must set `CoordMode("Pixel", "Screen")`
     * for this to return the expected result.
     */
    SetCallAction(Id := 1) {
        switch Id, 0 {
            case 1: this.DefineProp('Call', Point.Prototype.GetOwnPropDesc('Call'))
            case 2: this.DefineProp('Call', Point.Prototype.GetOwnPropDesc('__CallGetWindowUnderCursor'))
            case 3: this.DefineProp('Call', Point.Prototype.GetOwnPropDesc('__CallGetPixelUnderCursor'))
        }
    }
    /**
     * @description - `Point.Prototype.SetCallback` changes the method "Call" to do the following:
     * 1. Update's the `Point` object's X and Y values to the cursor's current position relative to
     *    the screen.
     * 2. Calls the callback function, passing the `Point` object to the function.
     * 3. Returns the value from the callback.
     *
     * To disable the callback and return "Call" to the built-in default, pass zero or an empty
     * string to `Callback`.
     */
    SetCallback(Callback) {
        if Callback {
            this.DefineProp('Callback', { Call: Callback })
            this.DefineProp('Call', Point.Prototype.GetOwnPropDesc('__CallWithCallback'))
        } else {
            this.DeleteProp('Callback')
            this.DefineProp('Call', Point.Prototype.GetOwnPropDesc('Call'))
        }
    }
    __CallGetWindowUnderCursor(*) {
        if !DllCall(RectBase.GetCursorPos, 'ptr', this, 'int') {
            throw OSError()
        }
        return DllCall(RectBase.WindowFromPoint, 'int', this.Value, 'ptr')
    }
    __CallGetPixelUnderCursor(*) {
        if !DllCall(RectBase.GetCursorPos, 'ptr', this, 'int') {
            throw OSError()
        }
        return PixelGetColor(this.X, this.Y)
    }
    __CallWithCallback() {
        if !DllCall(RectBase.GetCursorPos, 'ptr', this, 'int') {
            throw OSError()
        }
        return this.Callback()
    }
    PixelColor => this.GetPixelColor()
}

;@endregion


;@region Point funcs

PtClone(pt) => Point(pt.X, pt.Y)
PtCursorPosToString(Pt) {
    DllCall(RectBase.GetCursorPos, 'ptr', pt, 'int')
    return '( ' Pt.X ', ' Pt.Y ' )'
}
PtGetCursorPos(pt) => DllCall(RectBase.GetCursorPos, 'ptr', pt, 'int')
PtGetDpi(pt) {
    if DllCall(RectBase.Shcore_GetDpiForMonitor, 'ptr'
        , DllCall(RectBase.MonitorFromPoint, 'int', pt.Value, 'uint', 0, 'ptr')
    , 'uint', 0, 'uint*', &DpiX := 0, 'uint*', &DpiY := 0, 'int') {
        throw OSError('MonitorFomPoint received an invalid parameter.', -1)
    } else {
        return DpiX
    }
}
PtGetMonitor(pt) {
    return DllCall(RectBase.MonitorFromPoint, 'int', pt.Value, 'uint', 0, 'ptr')
}
PtGetValue(Pt) => (pt.X & 0xFFFFFFFF) | (pt.Y << 32)
PtLogicalToPhysical(pt, Hwnd) {
    DllCall(RectBase.LogicalToPhysical, 'ptr', Hwnd, 'ptr', pt)
}
PtLogicalToPhysicalForPerMonitorDPI(pt, Hwnd) {
    return DllCall(RectBase.LogicalToPhysicalPointForPerMonitorDPI, 'ptr', Hwnd, 'ptr', pt, 'int')
}
PtPhysicalToLogical(pt, Hwnd) {
    DllCall(RectBase.PhysicalToLogical, 'ptr', Hwnd, 'ptr', pt)
}
PtPhysicalToLogicalForPerMonitorDPI(pt, Hwnd) {
    return DllCall(RectBase.PhysicalToLogicalPointForPerMonitorDPI, 'ptr', Hwnd, 'ptr', pt, 'int')
}
PtSetCaretPos(pt) {
    return DllCall(RectBase.SetCaretPos, 'int', pt.X, 'int', pt.Y, 'int')
}
/**
 * @description - Use this to convert screen coordinates (which should already be contained by
 * this `Point` object), to client coordinates.
 * {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-screentoclient}
 * @param {Point} pt - The point.
 * @param {Integer} Hwnd - The handle to the window whose client area will be used for the conversion.
 * @param {Boolean} [InPlace = false] - If true, the function modifies the object's properties.
 * If false, the function creates a new object.
 * @returns {Point}
 */
PtToClient(pt, Hwnd, InPlace := false) {
    if !InPlace {
        pt := Point(pt.X, pt.Y)
    }
    if !DllCall(RectBase.ScreenToClient, 'ptr', Hwnd, 'ptr', pt, 'int') {
        throw OSError()
    }
    return pt
}
/**
 * @description - Use this to convert client coordinates (which should already be contained by
 * this `Point` object), to screen coordinates.
 * {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-clienttoscreen}
 * @param {Point} pt - The point.
 * @param {Integer} Hwnd - The handle to the window whose client area will be used for the conversion.
 * @param {Boolean} [InPlace = false] - If true, the function modifies the object's properties.
 * If false, the function creates a new object.
 * @returns {Point}
 */
PtToScreen(Pt, Hwnd, InPlace := false) {
    if !InPlace {
        pt := Point(pt.X, pt.Y)
    }
    if !DllCall(RectBase.ClientToScreen, 'ptr', Hwnd, 'ptr', pt, 'int') {
        throw OSError()
    }
    return pt
}
PtToString(Pt) {
    return '( ' Pt.X ', ' Pt.Y ' )'
}

;@endregion


;@region Rect funcs

RectClone(rc) => Rect(rc.L, rc.T, rc.R, rc.B)
RectEqual(rc1, rc2) => DllCall(RectBase.EqualRect, 'ptr', rc1, 'ptr', rc2, 'int')
RectGetCoordinate(Offset, rc) => NumGet(rc, Offset, 'int')
RectGetDpi(rc) {
    if DllCall(RectBase.Shcore_GetDpiForMonitor, 'ptr'
        , DllCall(RectBase.Shcore_MonitorFromRect, 'ptr', rc, 'uint', 0, 'ptr')
    , 'uint', 0, 'uint*', &DpiX := 0, 'uint*', &DpiY := 0, 'int') {
        throw OSError('``MonitorFomPoint`` received an invalid parameter.', -1)
    } else {
        return DpiX
    }
}
RectGetHeightSegment(rc, Divisor, DecimalPlaces := 0) => Round(rc.H / Divisor, DecimalPlaces)
RectGetLength(Offset, rc) => NumGet(rc, 8 + Offset, 'int') - NumGet(rc, Offset, 'int')
RectGetMonitor(rc) => DllCall(RectBase.MonitorFromRect, 'ptr', rc, 'UInt', 0, 'Uptr')
RectGetPoint(Offset1, Offset2, rc) => Point(NumGet(rc, Offset1, 'int'), NumGet(rc, Offset2, 'int'))
RectGetPtrFromBuffer(rc) => rc.Buffer.Ptr + rc.Offset
RectGetSizeFromBuffer(rc) => rc.Buffer.Size
RectGetWidthSegment(rc, Divisor, DecimalPlaces := 0) => Round(rc.W / Divisor, DecimalPlaces)
RectInflate(rc, dx, dy) => DllCall(RectBase.InflateRect, 'ptr', rc, 'int', dx, 'int', dy, 'int')
/**
 * @returns {Rect} - If the rectangles intersect, a new `Rect` object is returned. If the rectangles
 * do not intersect, returns an empty string.
 */
RectIntersect(rc1, rc2, Offset := 0) {
    rc := Rect()
    if DllCall(RectBase.IntersectRect, 'ptr', rc, 'ptr', rc1, 'ptr', rc2, 'int') {
        return rc
    }
}
RectIsEmpty(rc) => DllCall(RectBase.IsRectEmpty, 'ptr', rc, 'int')
RectDispose(Obj) {
    if Obj.HasOwnProp('Ptr') {
        ObjRelease(Obj.Ptr)
        Obj.DeleteProp('Ptr')
    }
    if Obj.HasOwnProp('Buffer') {
        Obj.DeleteProp('Buffer')
    }
    Obj.DefineProp('Size', { Value: 0 })
    Obj.DefineProp('Ptr', { Value: 0 })
}
/**
 * @description - Calculates the optimal position to move one rectangle adjacent to another while
 * ensuring that the `Subject` rectangle stays within the monitor's work area. The properties
 * { L, T, R, B } of `Subject` are updated with the new values.
 *
 * @example
 * ; Assume I have Edge and VLC open
 * rcSub := WinRect(WinGetId("ahk_exe msedge.exe"))
 * rcTar := WinRect(WinGetId("ahk_exe vlc.exe"))
 * rcSub.MoveAdjacent(rcTar)
 * rcSub.Apply()
 * @
 *
 * @param {*} Subject - The object representing the rectangle that will be moved. This can be an
 * instance of `Rect` or any class that inherits from `Rect`, or any object with properties
 * { L, T, R, B }. Those four property values will be updated with the result of this function call.
 *
 * @param {*} [Target] - The object representing the rectangle that will be used as reference. This
 * can be an instance of `Rect` or any class that inherits from `Rect`, or any object with properties
 * { L, T, R, B }. If unset, the mouse's current position relative to the screen is used. To use
 * a point instead of a rectangle, set the properties "L" and "R" equivalent to one another, and
 * "T" and "B" equivalent to one another.
 *
 * @param {*} [ContainerRect] - If set, `ContainerRect` defines the boundaries which restrict
 * the area that the window is permitted to be moved within. The object must have poperties
 * { L, T, R, B } to be valid. If unset, the work area of the monitor with the greatest area of
 * intersection with `Target` is used.
 *
 * @param {String} [Dimension = "X"] - Either "X" or "Y", specifying if the window is to be moved
 * adjacent to `Target` on either the X or Y axis. If "X", `Subject` is moved to the left or right
 * of `Target`, and `Subject`'s vertical center is aligned with `Target`'s vertical center. If "Y",
 * `Subject` is moved to the top or bottom of `Target`, and `Subject`'s horizontal center is aligned
 * with `Target`'s horizontal center.
 *
 * @param {String} [Prefer = ""] - A character indicating a preferred side. If `Prefer` is an
 * empty string, the function will move the window to the side the has the greatest amount of
 * space between the monitor's border and `Target`. If `Prefer` is any of the following values,
 * the window will be moved to that side unless doing so would cause the the window to extend
 * outside of the monitor's work area.
 * - "L" - Prefers the left side.
 * - "T" - Prefers the top side.
 * - "R" - Prefers the right side.
 * - "B" - Prefes the bottom.
 *
 * @param {Number} [Padding = 0] - The amount of padding to leave between `Subject` and `Target`.
 *
 * @param {Integer} [InsufficientSpaceAction = 0] - Determines the action taken if there is
 * insufficient space to move the window adjacent to `Target` while also keeping the window
 * entirely within the monitor's work area. The function will always sacrifice some of the padding
 * if it will allow the window to stay within the monitor's work area. If the space is still
 * insufficient, the action can be one of the following:
 * - 0 : The function will not move the window.
 * - 1 : The function will move the window, allowing the window's area to extend into a non-visible
 *   region of the monitor.
 * - 2 : The function will move the window, keeping the window's area within the monitor's work
 *   area by allowing the window to overlap with `Target`.
 *
 * @returns {Integer} - If the insufficient space action was invoked, returns 1. Else, returns 0.
 */
RectMoveAdjacent(Subject, Target?, ContainerRect?, Dimension := 'X', Prefer := '', Padding := 0, InsufficientSpaceAction := 0) {
    Result := 0
    if IsSet(Target) {
        tarL := Target.L
        tarT := Target.T
        tarR := Target.R
        tarB := Target.B
    } else {
        mode := CoordMode('Mouse', 'Screen')
        MouseGetPos(&tarL, &tarT)
        tarR := tarL
        tarB := tarT
        CoordMode('Mouse', mode)
    }
    tarW := tarR - tarL
    tarH := tarB - tarT
    if IsSet(ContainerRect) {
        monL := ContainerRect.L
        monT := ContainerRect.T
        monR := ContainerRect.R
        monB := ContainerRect.B
        monW := monR - monL
        monH := monB - monT
    } else {
        buf := Buffer(16)
        NumPut('int', tarL, 'int', tarT, 'int', tarR, 'int', tarB, buf)
        Hmon := DllCall('MonitorFromRect', 'ptr', buf, 'uint', 0x00000002, 'ptr')
        mon := Buffer(40)
        NumPut('int', 40, mon)
        if !DllCall('GetMonitorInfo', 'ptr', Hmon, 'ptr', mon, 'int') {
            throw OSError()
        }
        monL := NumGet(mon, 20, 'int')
        monT := NumGet(mon, 24, 'int')
        monR := NumGet(mon, 28, 'int')
        monB := NumGet(mon, 32, 'int')
        monW := monR - monL
        monH := monB - monT
    }
    subL := Subject.L
    subT := Subject.T
    subR := Subject.R
    subB := Subject.B
    subW := subR - subL
    subH := subB - subT
    if Dimension = 'X' {
        if Prefer = 'L' {
            if tarL - subW - Padding >= monL {
                X := tarL - subW - Padding
            } else if tarL - subW >= monL {
                X := monL
            }
        } else if Prefer = 'R' {
            if tarR + subW + Padding <= monR {
                X := tarR + Padding
            } else if tarR + subW <= monR {
                X := monR - subW
            }
        } else if Prefer {
            throw _ValueError('Prefer', Prefer)
        }
        if !IsSet(X) {
            flag_nomove := false
            X := _Proc(subW, subL, subR, tarW, tarL, tarR, monW, monL, monR, Prefer = 'L' ? 1 : Prefer = 'R' ? -1 : 0)
            if flag_nomove {
                return Result
            }
        }
        Y := tarT + tarH / 2 - subH / 2
        if Y + subH > monB {
            Y := monB - subH
        } else if Y < monT {
            Y := monT
        }
    } else if Dimension = 'Y' {
        if Prefer = 'T' {
            if tarT - subH - Padding >= monT {
                Y := tarT - subH - Padding
            } else if tarT - subH >= monT {
                Y := monT
            }
        } else if Prefer = 'B' {
            if tarB + subH + Padding <= monB {
                Y := tarB + Padding
            } else if tarB + subH <= monB {
                Y := monB - subH
            }
        } else if Prefer {
            throw _ValueError('Prefer', Prefer)
        }
        if !IsSet(Y) {
            flag_nomove := false
            Y := _Proc(subH, subT, subB, tarH, tarT, tarB, monH, monT, monB, Prefer = 'T' ? 1 : Prefer = 'B' ? -1 : 0)
            if flag_nomove {
                return Result
            }
        }
        X := tarL + tarW / 2 - subW / 2
        if X + subW > monR {
            X := monR - subW
        } else if X < monL {
            X := monL
        }
    } else {
        throw _ValueError('Dimension', Dimension)
    }
    Subject.L := X
    Subject.T := Y
    Subject.R := X + subW
    Subject.B := Y + subH

    return Result

    _Proc(SubLen, SubMainSide, SubAltSide, TarLen, TarMainSide, TarAltSide, MonLen, MonMainSide, MonAltSide, Prefer) {
        if TarMainSide - MonMainSide > MonAltSide - TarAltSide {
            if TarMainSide - SubLen - Padding >= MonMainSide {
                return TarMainSide - SubLen - Padding
            } else if TarMainSide - SubLen >= MonMainSide {
                return MonMainSide + TarMainSide - SubLen
            } else {
                Result := 1
                switch InsufficientSpaceAction, 0 {
                    case 0: flag_nomove := true
                    case 1: return TarMainSide - SubLen
                    case 2: return MonMainSide
                    default: throw _ValueError('InsufficientSpaceAction', InsufficientSpaceAction)
                }
            }
        } else if TarAltSide + SubLen + Padding <= MonAltSide {
            return TarAltSide + Padding
        } else if TarAltSide + SubLen <= MonAltSide {
            return MonAltSide - TarAltSide + SubLen
        } else {
            Result := 1
            switch InsufficientSpaceAction, 0 {
                case 0: flag_nomove := true
                case 1: return TarAltSide
                case 2: return MonAltSide - SubLen
                default: throw _ValueError('InsufficientSpaceAction', InsufficientSpaceAction)
            }
        }
    }
    _ValueError(name, Value) {
        if IsObject(Value) {
            return TypeError('Invalid type passed to ``' name '``.', -2)
        } else {
            return ValueError('Unexpected value passed to ``' name '``.', -2, Value)
        }
    }
}
RectOffset(rc, dx, dy) => DllCall(RectBase.OffsetRect, 'ptr', rc, 'int', dx, 'int', dy, 'int')
RectPtIn(rc, pt) => DllCall(RectBase.PtInRect, 'ptr', rc, 'ptr', pt, 'int')
RectSet(rc, X?, Y?, W?, H?) {
    if IsSet(X) {
        rc.L := X
    }
    if IsSet(Y) {
        rc.T := Y
    }
    if IsSet(W) {
        rc.R := rc.L + W
    }
    if IsSet(H) {
        rc.B := rc.T + H
    }
}
RectSetCoordinate(Offset, rc, Value) => NumPut('int', Value, rc.Ptr, Offset)
RectSetLength(Offset, rc, Value) => NumPut('int', NumGet(rc, Offset, 'int') + Value, rc, 8 + Offset)
RectSetThreadDpiAwareness__Call(Obj, Name, Params) {
    Split := StrSplit(Name, '_')
    if Obj.HasMethod(Split[1]) && Split[2] = 'S' {
        DllCall(RectBase.SetThreadDpiAwarenessContext, 'ptr', HasProp(Obj, 'DpiAwarenessContext') ? Obj.DpiAwarenessContext : DPI_AWARENESS_CONTEXT_DEFAULT ?? -4, 'ptr')
        if Params.Length {
            return Obj.%Split[1]%(Params*)
        } else {
            return Obj.%Split[1]%()
        }
    } else {
        throw PropertyError('Property not found.', -1, Name)
    }
}
RectSubtract(rc1, rc2) {
    rc := Rect()
    DllCall(RectBase.SubtractRect, 'ptr', rc, 'ptr', rc1, 'ptr', rc2, 'int')
    return rc
}
/**
 * Calls `ScreenToClient` for the the rectangle.
 * @param {Integer} Hwnd - The handle to the window to which the rectangle's dimensions
 * will be made relative.
 * @param {Boolean} [InPlace = false] - If true, the function modifies the object's properties.
 * If false, the function creates a new object.
 * @returns {Rect}
 */
RectToClient(rc, Hwnd, InPlace := false) {
    if !InPlace {
        rc := rc.Clone()
    }
    if !DllCall(RectBase.ScreenToClient, 'ptr', Hwnd, 'ptr', rc, 'int') {
        throw OSError()
    }
    if !DllCall(RectBase.ScreenToClient, 'ptr', Hwnd, 'ptr', rc.Ptr + 8, 'int') {
        throw OSError()
    }
    return rc
}
/**
 * Calls `ClientToScreen` for the the rectangle.
 * @param {Integer} Hwnd - The handle to the window to which the rectangle's dimensions
 * are currently relative.
 * @param {Boolean} [InPlace = false] - If true, the function modifies the object's properties.
 * If false, the function creates a new object.
 * @returns {Rect}
 */
RectToScreen(rc, Hwnd, InPlace := false) {
    if !InPlace {
        rc := rc.Clone()
    }
    if !DllCall(RectBase.ClientToScreen, 'ptr', Hwnd, 'ptr', rc.ptr, 'int') {
        throw OSError()
    }
    if !DllCall(RectBase.ClientToScreen, 'ptr', Hwnd, 'ptr', rc.ptr + 8, 'int') {
        throw OSError()
    }
    return rc
}
RectToString(rc, DimensionLen := '-6') {
    return (
        'TL: ' Format('( {}, {} )', rc.L, rc.T)
        '`r`nBR: ' Format('( {}, {} )', rc.R, rc.B)
        '`r`nW: ' Format('{:' DimensionLen '}', rc.W) '  H: ' Format('{:' DimensionLen '}', rc.H)
    )
}
RectToStringDeconstructed(rc, DimensionLen := '-6') {
    return {
        TL: Format('( {}, {} )', rc.L, rc.T)
      , BR: Format('( {}, {} )', rc.R, rc.B)
      , W: Format('{:' DimensionLen '}', rc.W)
      , H: Format('{:' DimensionLen '}', rc.H)
    }
}
/**
 * @returns {Rect} - If the specified structure contains a nonempty rectangle, a new `Rect` is created
 * and retured. If the specified structure does not contain a nonempty rectangle, returns an empty
 * string.
 */
RectUnion(rc1, rc2) {
    rc := Rect()
    if DllCall(RectBase.UnionRect, 'ptr', rc, 'ptr', rc1, 'ptr', rc2, 'int') {
        return rc
    }
}
SetCaretPos(X, Y) {
    return DllCall(RectBase.SetCaretPos, 'int', X, 'int', Y, 'int')
}

;@endregion


;@region Window32 funcs

/**
 * @description - Input the desired client area and `AdjustWindowRectEx` will update the object
 * on the property `Rect` to the position and size that will accommodate the client area. This
 * does not update the window's display; call `Window32Obj.Rect.Apply()`
 */
Window32AdjustRectEx(win, X?, Y?, W?, H?, HasMenuBar := false) {
    rc := win.Rect
    if IsSet(X) {
        rc.X := X
    }
    if IsSet(Y) {
        rc.Y := Y
    }
    if IsSet(W) {
        rc.R := rc.X + W
    }
    if IsSet(H) {
        rc.B := rc.T + H
    }
    if !DllCall(RectBase.AdjustWindowRectEx, 'ptr', rc, 'uint', win.Style, 'int', HasMenuBar, 'uint', win.ExStyle, 'int') {
        throw OSError()
    }
}

Window32BringToTop(win) {
    return DllCall(RectBase.BringWindowToTop, 'ptr', IsObject(win) ? win.Hwnd : win, 'int')
}

Window32CallbackFromDesktop(*) {
    if hwnd := DllCall(RectBase.GetDesktopWindow, 'ptr') {
        return hwnd
    }
}

Window32CallbackFromForeground(*) {
    return DllCall(RectBase.GetForegroundWindow, 'ptr')
}

/**
 * @description - To use this as a callback with `Window32.Prototype.SetCallback`, you must
 * define it as a `BoundFunc` defining the "Cmd" value.
 * @example
 *  hwnd := DllCall(RectBase.GetDesktopWindow, 'ptr')
 *  win := Window32(hwnd)
 *  win.SetCallback(Window32CallbackFromNext.Bind(3))
 *  win()
 * @
 */
Window32CallbackFromNext(Cmd, win) {
    if hwnd := DllCall(RectBase.GetNextWindow, 'ptr', win.Hwnd, 'uint', Cmd, 'ptr') {
        return hwnd
    }
}

Window32CallbackFromParent(win) {
    if hwnd := DllCall(RectBase.GetParent, 'ptr', win.Hwnd, 'ptr') {
        return hwnd
    }
}

Window32CallbackFromShell(*) {
    return DllCall(RectBase.GetShellWindow, 'ptr')
}

Window32CallbackFromTop(win) {
    return DllCall(RectBase.GetTopWindow, 'ptr', win.Hwnd, 'ptr')
}

/**
 * @description - `Window32ChildFromCursor` returns the child window underneath the cursor. To use
 * this function, you must first call the method "MakePoint".
 * @example
 *  win := Window32()
 *  win.MakePoint(2)
 *  ; Now we can get the child window under the cursor like this:
 *  childHwnd := win.ChildFromCursor()
 * @
 *
 * Note that calling the method "ChildFromCursor" also updates the property "Hwnd" with the handle to
 * the window under the cursor.
 */
Window32ChildFromCursor(win) {
    win.Point.Call()
    win.Hwnd := DllCall(RectBase.WindowFromPoint, 'int', win.Point.Value, 'ptr')
    return DllCall(RectBase.ChildWindowFromPoint, 'ptr', win.Hwnd, 'int', win.Point.Value, 'ptr')
}

/**
 * @description - Similar to {@link Window32ChildFromCursor}, except in this case we can also pass
 * a value to the parameter `Flag`, described here: {@link Window32ChildFromPointEx}.
 */
Window32ChildFromCursorEx(win, Flag := 0) {
    win.Point.Call()
    win.Hwnd := DllCall(RectBase.WindowFromPoint, 'int', win.Point.Value, 'ptr')
    return DllCall(RectBase.ChildWindowFromPointEx, 'ptr', win.Hwnd, 'int', win.Point.Value, 'int', Flag, 'ptr')
}

Window32ChildFromPoint(win, X, Y) {
    return DllCall(RectBase.ChildWindowFromPoint, 'ptr', IsObject(win) ? win.Hwnd : win, 'int', (X & 0xFFFFFFFF) | (Y << 32), 'ptr')
}

/**
 * @param {Integer} [flag = 0] -
 * - CWP_ALL - 0x0000 : Does not skip any child windows
 * - CWP_SKIPDISABLED - 0x0002 : Skips disabled child windows
 * - CWP_SKIPINVISIBLE - 0x0001 : Skips invisible child windows
 * - CWP_SKIPTRANSPARENT - 0x0004 : Skips transparent child windows
 */
Window32ChildFromPointEx(win, X, Y, Flag := 0) {
    return DllCall(RectBase.ChildWindowFromPointEx, 'ptr', IsObject(win) ? win.Hwnd : win, 'int', (X & 0xFFFFFFFF) | (Y << 32), 'int', Flag, 'ptr')
}

Window32Dispose(win) {
    for prop in ['Rect', 'ClientRect'] {
        if win.HasOwnProp(prop) {
            if win.%prop%.HasMethod('Dispose') {
                win.%prop%.Dispose()
            }
            win.DeleteProp(prop)
        }
    }
    RectDispose(win)
}

Window32EnumChildWindows(win, Callback, lParam := 0) {
    cb := CallbackCreate(Callback)
    result := DllCall(RectBase.EnumChildWindows, 'ptr', IsObject(win) ? win.Hwnd : win, 'ptr', cb, 'uint', lParam, 'int')
    CallbackFree(cb)
    return result
}

/**
 * @description - Gets the bounding rectangle of all child windows of a given window.
 * @param {Integer} Hwnd - The handle to the parent window.
 * @returns {Rect} - The bounding rectangle of all child windows, specifically the smallest
 * rectangle that contains all child windows.
 */
Window32GetChildBoundingRect(win) {
    rects := [Rect(), Rect(), Rect()]
    DllCall(RectBase.EnumChildWindows, 'ptr', IsObject(win) ? win.Hwnd : win, 'ptr', cb := CallbackCreate(_EnumChildWindowsProc, 'fast',  1), 'int', 0, 'int')
    CallbackFree(cb)
    return rects[1]

    _EnumChildWindowsProc(hwnd) {
        DllCall(RectBase.GetWindowRect, 'ptr', Hwnd, 'ptr', rects[3], 'int')
        DllCall(RectBase.UnionRect, 'ptr', rects[2], 'ptr', rects[3], 'ptr', rects[1], 'int')
        rects.Push(rects.RemoveAt(1))
        return 1
    }
}

Window32GetClientRect(win) {
    return WinRect(IsObject(win) ? win.Hwnd : win, true)
}

Window32GetDpi(win) {
    return DllCall(RectBase.GetDpiForWindow, 'ptr', IsObject(win) ? win.Hwnd : win, 'int')
}

Window32GetExStyle(win) {
    style := win.ExStyle
    result := []
    result.Capacity := Window32.WindowExStyles.Count
    for k, v in Window32.WindowExStyles {
        if style & v {
            result.Push(k)
        }
    }
    result.Capacity := result.Length
    return result
}

Window32GetMonitor(win) {
    return DllCall(RectBase.MonitorFromWindow, 'ptr', IsObject(win) ? win.Hwnd : win, 'int', 0, 'ptr')
}

Window32GetStyle(win) {
    style := win.Style
    result := []
    result.Capacity := Window32.WindowStyles.Count
    for k, v in Window32.WindowStyles {
        if style & v {
            result.Push(k)
        }
    }
    result.Capacity := result.Length
    return result
}

/**
 * @param {String|Integer} Id - Either the symbol as string (e.g. "WS_EX_WINDOWEDGE") or the integer
 * value (e.g. "0x00000100").
 */
Window32HasExStyle(win, Id) {
    return win.ExStyle & (IsNumber(Id) ? Id : Window32.WindowExStyles.Get(Id))
}

/**
 * @param {String|Integer} Id - Either the symbol as string (e.g. "WS_CAPTION") or the integer value
 * (e.g. "0x00C00000").
 */
Window32HasStyle(win, Id) {
    return win.Style & (IsNumber(Id) ? Id : Window32.WindowStyles.Get(Id))
}

Window32IsChild(win, HwndChild) {
    return DllCall(RectBase.IsChild, 'ptr', IsObject(win) ? win.Hwnd : win, 'ptr', IsObject(HwndChild) ? HwndChild.Hwnd : HwndChild, 'int')
}

Window32IsParent(win, HwndParent) {
    return DllCall(RectBase.IsChild, 'ptr', HwndParent, 'ptr', IsObject(win) ? win.Hwnd : win, 'int')
}

Window32IsVisible(wrc) {
    return DllCall(RectBase.IsWindowVisible, 'ptr', IsObject(wrc) ? wrc.Hwnd : wrc, 'int')
}

/**
 * Input the dimensions of the desired client area, and the window is moved to accommodate that
 * area.
 */
Window32MoveClient(win, X := 0, Y := 0, W := 0, H := 0, InsertAfter := 0, Flags := 0) {
    win := win.Rect
    win.X := X
    win.Y := Y
    win.W := W
    win.H := H
    if !DllCall(RectBase.AdjustWindowRectEx, 'ptr', win, 'uint', win.Style, 'int', win.MenuBar ? 1 : 0, 'uint', win.ExStyle, 'int') {
        throw OSError()
    }
    if !DllCall(RectBase.SetWindowPos, 'ptr', win.Hwnd, 'ptr', InsertAfter, 'int', X, 'int', Y, 'int', W, 'int', H, 'uint', Flags, 'int') {
        throw OSError()
    }
    ; Update the AHK Rect object's property values.
    if !DllCall(RectBase.GetWindowRect, 'ptr', win.Hwnd, 'ptr', win, 'int') {
        throw OSError()
    }
}

Window32RealChildFromPoint(win, X, Y) {
    return DllCall(RectBase.RealChildWindowFromPoint, 'ptr', IsObject(win) ? win.Hwnd : win, 'int', (X & 0xFFFFFFFF) | (Y << 32), 'ptr')
}

/**
 * @description - See {@link Window32ChildFromCursor}.
 */
Window32RealChildFromCursor(win) {
    win.Point.Call()
    win.Hwnd := DllCall(RectBase.WindowFromPoint, 'int', win.Point.Value, 'ptr')
    return DllCall(RectBase.RealChildWindowFromPoint, 'ptr', IsObject(win) ? win.Hwnd : win, 'int', win.Point.Value, 'ptr')
}

Window32SetActive(win) {
    return DllCall(RectBase.SetActiveWindow, 'ptr', IsObject(win) ? win.Hwnd : win, 'int')
}

Window32SetForeground(win) {
    return DllCall(RectBase.SetForegroundWindow, 'ptr', IsObject(win) ? win.Hwnd : win, 'int')
}

Window32SetParent(win, HwndNewParent := 0) {
    return DllCall(RectBase.SetParent, 'ptr', IsObject(win) ? win.Hwnd : win, 'ptr', IsObject(HwndNewParent) ? HwndNewParent.Hwnd : HwndNewParent, 'ptr')
}

Window32SetPosKeepAspectRatio(win, Width, Height, AspectRatio?) {
    if !IsSet(AspectRatio) {
        AspectRatio := win.W / win.H
    }
    WidthFromHeight := Height / AspectRatio
    HeightFromWidth := Width * AspectRatio
    if WidthFromHeight > Width {
        win.H := HeightFromWidth
        win.W := Width
    } else {
        win.W := WidthFromHeight
        win.H := Height
    }
}

/**
 * @description - Shows the window.
 * @param {Integer} [Flag = 0] - One of the following.
 * - SW_HIDE - 0 - Hides the window and activates another window.
 * - SW_SHOWNORMAL / SW_NORMAL - 1 - Activates and displays a window. If the window is
 *   minimized, maximized, or arranged, the system restores it to its original size and position.
 *   An application should specify this flag when displaying the window for the first time.
 * - SW_SHOWMINIMIZED - 2 - Activates the window and displays it as a minimized window.
 * - SW_SHOWMAXIMIZED / SW_MAXIMIZE - 3 - Activates the window and displays it as a maximized
 *   window.
 * - SW_SHOWNOACTIVATE - 4 - Displays a window in its most recent size and position. This value
 *   is similar to SW_SHOWNORMAL, except that the window is not activated.
 * - SW_SHOW - 5 - Activates the window and displays it in its current size and position.
 * - SW_MINIMIZE - 6 - Minimizes the specified window and activates the next top-level window in
 *   the Z order.
 * - SW_SHOWMINNOACTIVE - 7 - Displays the window as a minimized window. This value is similar
 *   to SW_SHOWMINIMIZED, except the window is not activated.
 * - SW_SHOWNA - 8 - Displays the window in its current size and position. This value is similar
 *   to SW_SHOW, except that the window is not activated.
 * - SW_RESTORE - 9 - Activates and displays the window. If the window is minimized, maximized,
 *   or arranged, the system restores it to its original size and position. An application should
 *   specify this flag when restoring a minimized window.
 * - SW_SHOWDEFAULT - 10 - Sets the show state based on the SW_ value specified
 *   in the structure passed to the function by the program that started the application.
 * - SW_FORCEMINIMIZE - 11 - Minimizes a window, even if the thread that owns the window is not
 *   responding. This flag should only be used when minimizing windows from a different thread.
 * @returns {Boolean} - If the window was previously visible, the return value is nonzero. If
 * the window was previously hidden, the return value is zero.
 */
Window32Show(win, Flag := 0) {
    return DllCall(RectBase.ShowWindow, 'ptr', IsObject(win) ? win.Hwnd : win, 'uint', Flag, 'int')
}

;@endregion


;@region WinFrom funcs

WinFromDesktop() {
    return DllCall(RectBase.GetDesktopWindow, 'ptr')
}

WinFromForeground() {
    return DllCall(RectBase.GetForegroundWindow, 'ptr')
}

WinFromCursor() {
    pt := Point()
    if !DllCall(RectBase.GetCursorPos, 'ptr', pt, 'int') {
        throw OSError()
    }
    return DllCall(RectBase.WindowFromPoint, 'int', pt.Value, 'ptr')
}

WinFromParent(Hwnd) {
    return DllCall(RectBase.GetParent, 'ptr', IsObject(Hwnd) ? Hwnd.Hwnd : Hwnd, 'ptr')
}

WinFromPoint(X, Y) {
    return DllCall(RectBase.WindowFromPoint, 'int', (X & 0xFFFFFFFF) | (Y << 32), 'ptr')
}

WinFromShell() {
    return DllCall(RectBase.GetShellWindow, 'ptr')
}

WinFromTop(Hwnd := 0) {
    return DllCall(RectBase.GetTopWindow, 'ptr', IsObject(Hwnd) ? Hwnd.Hwnd : Hwnd, 'ptr')
}

/**
 * @param Cmd -
 * - GW_CHILD - 5 - The retrieved handle identifies the child window at the top of the Z order,
 *  if the specified window is a parent window; otherwise, the retrieved handle is NULL. The
 *  function examines only child windows of the specified window. It does not examine descendant
 *  windows.
 *
 * - GW_ENABLEDPOPUP - 6 - The retrieved handle identifies the enabled popup window owned by the
 *  specified window (the search uses the first such window found using GW_HwndNEXT); otherwise,
 *  if there are no enabled popup windows, the retrieved handle is that of the specified window.
 *
 * - GW_HwndFIRST - 0 - The retrieved handle identifies the window of the same type that is highest
 *  in the Z order. If the specified window is a topmost window, the handle identifies a topmost
 *  window. If the specified window is a top-level window, the handle identifies a top-level
 *  window. If the specified window is a child window, the handle identifies a sibling window.
 *
 * - GW_HwndLAST - 1 - The retrieved handle identifies the window of the same type that is lowest
 *  in the Z order. If the specified window is a topmost window, the handle identifies a topmost
 *  window. If the specified window is a top-level window, the handle identifies a top-level window.
 *  If the specified window is a child window, the handle identifies a sibling window.
 *
 * - GW_HwndNEXT - 2 - The retrieved handle identifies the window below the specified window in
 *  the Z order. If the specified window is a topmost window, the handle identifies a topmost
 *  window. If the specified window is a top-level window, the handle identifies a top-level
 *  window. If the specified window is a child window, the handle identifies a sibling window.
 *
 * - GW_HwndPREV - 3 - The retrieved handle identifies the window above the specified window in
 *  the Z order. If the specified window is a topmost window, the handle identifies a topmost
 *  window. If the specified window is a top-level window, the handle identifies a top-level
 *  window. If the specified window is a child window, the handle identifies a sibling window.
 *
 * - GW_OWNER - 4 - The retrieved handle identifies the specified window's owner window, if any.
 *  For more information, see Owned Windows.
 */
WinGet(Hwnd, Cmd) {
    return DllCall(RectBase.GetWindow, 'ptr', IsObject(Hwnd) ? Hwnd.Hwnd : Hwnd, 'uint', Cmd, 'ptr')
}

;@endregion


;@region WinRect funcs

WinRectApply(wrc, InsertAfter := 0, Flags := 0) {
    return DllCall(WinRect.SetWindowPos, 'ptr', wrc.Hwnd, 'ptr', InsertAfter, 'int', wrc.L, 'int', wrc.T, 'int', wrc.W, 'int', wrc.H, 'uint', Flags, 'int')
}

WinRectGetPos(wrc, &X?, &Y?, &W?, &H?) {
    WinRectUpdate(wrc)
    X := wrc.L
    Y := wrc.T
    W := wrc.R - wrc.L
    H := wrc.B - wrc.T
}

WinRectMapPoints(wrc1, wrc2, points) {
    buf := Buffer(points.Length * 4)
    for coord in points {
        NumPut('int', coord, buf, A_Index * 4 - 4)
    }
    result := DllCall(RectBase.MapWindowPoints, 'ptr', IsObject(wrc1) ? wrc1.Hwnd : wrc1, 'ptr', IsObject(wrc2) ? wrc2.Hwnd : wrc2, 'ptr', buf, 'uint', points.Length / 2)
    loop points.Length {
        points[A_Index] := NumGet(buf, A_Index * 4 - 4, 'int')
    }
    return result
}

/**
 * @param {Integer} [X] - The new x-coordinate of the window.
 * @param {Integer} [Y] - The new y-coordinate of the window.
 * @param {Integer} [W] - The new Width of the window.
 * @param {Integer} [H] - The new Height of the window.
 * @param {Integer} [InsertAfter = 0] - Either the handle of another window to insert this
 * window after, or one of the following:
 * - HWND_BOTTOM - (HWND)1 : Places the window at the bottom of the Z order. If the <i>hWnd</i>
 *   parameter identifies a topmost window, the window loses its topmost status and is placed at
 *   the bottom of all other windows.
 * - HWND_NOTOPMOST - (HWND)-2 : Places the window above all non-topmost windows (that is, behind
 *   all topmost windows). This flag has no effect if the window is already a non-topmost window.
 * - HWND_TOP - (HWND)0 : Places the window at the top of the Z order.
 * - HWND_TOPMOST - (HWND)-1 : Places the window above all non-topmost windows. The window
 *   maintains its topmost position even when it is deactivated.
 * @param {Integer} [Flags = 0] - A combination of the following. Use "|" to combine, e.g.
 * `Flags := 0x4000 | 0x0020 | 0x0010`.
 * - SWP_ASYNCWINDOWPOS - 0x4000 : If the calling thread and the thread that owns the window are
 *   attached to different input queues, the system posts the request to the thread that owns the
 *   window. This prevents the calling thread from blocking its execution while other threads
 *   process the request.
 * - SWP_DEFERERASE - 0x2000 : Prevents generation of the WM_SYNCPAINT message.
 * - SWP_DRAWFRAME - 0x0020 : Draws a frame (defined in the window's class description) around the
 *   window.
 * - SWP_FRAMECHANGED - 0x0020 : Applies new frame styles set using the SetWindowLong
 *   function. Sends a WM_NCCALCSIZE message to the window, even if the window's size is not being
 *   changed. If this flag is not specified, <b>WM_NCCALCSIZE</b> is sent only when the window's
 *   size is being changed.
 * - SWP_HIDEWINDOW - 0x0080 : Hides the window.
 * - SWP_NOACTIVATE - 0x0010 : Does not activate the window. If this flag is not set, the window
 *   is activated and moved to the top of either the topmost or non-topmost group (depending on the
 *   setting of the <i>hWndInsertAfter</i> parameter).
 * - SWP_NOCOPYBITS - 0x0100 : Discards the entire contents of the client area. If this flag is
 *   not specified, the valid contents of the client area are saved and copied back into the client
 *   area after the window is sized or repositioned.
 * - SWP_NOMOVE - 0x0002 : Retains the current position (ignores <i>X</i> and <i>Y</i>
 *   parameters).
 * - SWP_NOOWNERZORDER - 0x0200 : Does not change the owner window's position in the Z order.
 * - SWP_NOREDRAW - 0x0008 : Does not redraw changes. If this flag is set, no repainting of any
 *   kind occurs. This applies to the client area, the nonclient area (including the title bar and
 *   scroll bars), and any part of the parent window uncovered as a result of the window being
 *   moved. When this flag is set, the application must explicitly invalidate or redraw any parts
 *   of the window and parent window that need redrawing.
 * - SWP_NOREPOSITION - 0x0200 : Same as the <b>SWP_NOOWNERZORDER</b> flag.
 * - SWP_NOSENDCHANGING - 0x0400 : Prevents the window from receiving the WM_WINDOWPOSCHANGING
 *   message.
 * - SWP_NOSIZE - 0x0001 : Retains the current size (ignores the <i>cx</i> and <i>cy</i>
 *   parameters).
 * - SWP_NOZORDER - 0x0004 : Retains the current Z order (ignores the <i>hWndInsertAfter</i>
 *   parameter).
 * - SWP_SHOWWINDOW - 0x0040 : Displays the window.
 */
WinRectMove(wrc, X := 0, Y := 0, W := 0, H := 0, InsertAfter := 0, Flags := 0) {
    if !DllCall(WinRect.SetWindowPos, 'ptr', wrc.Hwnd, 'ptr', InsertAfter, 'int', X, 'int', Y, 'int', W, 'int', H, 'uint', Flags, 'int') {
        throw OSError()
    }
    ; Update the AHK Rect object's property values.
    if !DllCall(WinRect.GetWindowRect, 'ptr', wrc.Hwnd, 'ptr', wrc, 'int') {
        throw OSError()
    }
}

WinRectUpdate(wrc) {
    if IsObject(wrc) && HasProp(wrc, 'Flag') {
        switch wrc.Flag, 0 {
            case 0:
                DllCall(RectBase.GetWindowRect, 'ptr', wrc.Hwnd, 'ptr', wrc, 'int')
            case 1:
                DllCall(RectBase.GetClientRect, 'ptr', wrc.Hwnd, 'ptr', wrc, 'int')
            case 2:
                if hresult := DllCall(RectBase.Dwmapi_DwmGetWindowAttribute, 'ptr', wrc.Hwnd, 'uint', 9, 'ptr', wrc, 'uint', 16, 'uint') {
                    throw oserror('DwmGetWindowAttribute failed.', -1, hresult)
                }
        }
    } else {
        DllCall(RectBase.GetWindowRect, 'ptr', wrc.Hwnd, 'ptr', wrc, 'int')
    }
}

;@endregion


;@region Misc


/**
 * @description - Reorders the objects in an array according to the input options.
 * @example
 *  List := [
 *      { L: 100, T: 100, Name: 1 }
 *    , { L: 100, T: 150, Name: 2 }
 *    , { L: 200, T: 100, Name: 3 }
 *    , { L: 200, T: 150, Name: 4 }
 *  ]
 *  Rect.Order(List, L2R := true, T2B := true, 'H')
 *  OutputDebug(_GetOrder()) ; 1 2 3 4
 *  Rect.Order(List, L2R := true, T2B := true, 'V')
 *  OutputDebug(_GetOrder()) ; 1 3 2 4
 *  Rect.Order(List, L2R := false, T2B := true, 'H')
 *  OutputDebug(_GetOrder()) ; 3 4 1 2
 *  Rect.Order(List, L2R := false, T2B := false, 'H')
 *  OutputDebug(_GetOrder()) ; 4 3 2 1
 *
 *  _GetOrder() {
 *      for item in List {
 *          Str .= item.Name ' '
 *      }
 *      return Trim(Str, ' ')
 *  }
 * @
 * @param {Array} List - The array containing the objects to be ordered.
 * @param {String} [Primary='X'] - Determines which axis is primarily considered when ordering
 * the objects. When comparing two objects, if their positions along the Primary axis are
 * equal, then the alternate axis is compared and used to break the tie. Otherwise, the alternate
 * axis is ignored for that pair.
 * - X: Check horizontal first.
 * - Y: Check vertical first.
 * @param {Boolean} [LeftToRight=true] - If true, the objects are ordered in ascending order
 * along the X axis when the X axis is compared.
 * @param {Boolean} [TopToBottom=true] - If true, the objects are ordered in ascending order
 * along the Y axis when the Y axis is compared.
 */
OrderRects(List, Primary := 'X', LeftToRight := true, TopToBottom := true) {
    ConditionH := LeftToRight ? (a, b) => a.L < b.L : (a, b) => a.L > b.L
    ConditionV := TopToBottom ? (a, b) => a.T < b.T : (a, b) => a.T > b.T
    if Primary = 'X' {
        _InsertionSort(List, _ConditionFnH)
    } else if Primary = 'Y' {
        _InsertionSort(List, _ConditionFnV)
    } else {
        throw ValueError('Unexpected ``Primary`` value.', -1, Primary)
    }

    return

    _InsertionSort(Arr, CompareFn) {
        i := 1
        loop Arr.Length - 1 {
            Current := Arr[++i]
            j := i - 1
            loop j {
                if CompareFn(Arr[j], Current) < 0
                    break
                Arr[j + 1] := Arr[j--]
            }
            Arr[j + 1] := Current
        }
    }
    _ConditionFnH(a, b) {
        if a.L == b.L {
            if ConditionV(a, b) {
                return -1
            }
        } else if ConditionH(a, b) {
            return -1
        }
        return 1
    }
    _ConditionFnV(a, b) {
        if a.T == b.T {
            if ConditionH(a, b) {
                return -1
            }
        } else if ConditionV(a, b) {
            return -1
        }
        return 1
    }
}

;@endregion




class TreeViewExCollection extends Container {
    static __New() {
        this.DeleteProp('__New')
        proto := Container.CbNumber(TreeViewEx_CallbackValue_Hwnd)
        proto.__Class := this.Prototype.__Class
        this.Prototype := proto
    }
}

; This does not use sort / find capabilities because the position where values are added depends
; on the parameter `AddRemove`.
class TreeViewExCollection_Callback extends Container {
    __New(Code) {
        this.Code := Code
    }
    DeleteCallback(Callback) {
        ptr := ObjPtr(Callback)
        for cb in this {
            if ptr = ObjPtr(cb) {
                this.RemoveAt(A_Index)
                return this.Length
            }
        }
        throw UnsetItemError('Callback not found.', , HasProp(Callback, 'Name') ? Callback.Name : '')
    }
}

class TreeViewExCollection_Code extends Container {
    static __New() {
        this.DeleteProp('__New')
        proto := Container.CbNumber(TreeViewEx_CallbackValue_Code)
        proto.__Class := this.Prototype.__Class
        this.Prototype := proto
    }
}

class TreeViewExCollection_LabelEditDestroyNotification extends Container {
    static __New() {
        this.DeleteProp('__New')
        proto := Container.CbNumber(TreeViewEx_CallbackValue_Handle)
        proto.__Class := this.Prototype.__Class
        this.Prototype := proto
    }
}

class TreeViewExCollection_Node extends Container {
    static __New() {
        this.DeleteProp('__New')
        proto := Container.CbNumber(TreeViewEx_CallbackValue_Handle)
        proto.__Class := this.Prototype.__Class
        this.Prototype := proto
    }
}

class TreeViewExCollection_Template extends Map {
    __New(CaseSense := false) {
        this.CaseSense := CaseSense
    }
}

class TreeViewExCollection_ContextMenuItem extends Container {
    static __New() {
        this.DeleteProp('__New')
        proto := Container.CbString(TreeViewEx_CallbackValue_Name, , LINGUISTIC_IGNORECASE)
        proto.__Class := this.Prototype.__Class
        this.Prototype := proto
    }
}

class PropsInfoTreeCollection_NodeConstructor extends Map {
    __New(Items*) {
        this.CaseSense := false
        if Items.Length {
            this.Set(Items*)
        }
    }
}

class TreeViewExCollection_TvexTabCollection extends Map {
    __New(Items*) {
        this.CaseSense := false
        if Items.Length {
            this.Set(Items*)
        }
    }
}


/**
 * Sets the global constant variables.
 *
 * @param {Boolean} [force = false] - When false, if `TreeViewEx_SetConstants` has already been called
 * (more specifically, if `TreeViewEx_constants_set` has been set), the function returns immediately.
 * If true, the function executes in its entirety.
 */
TreeViewEx_SetConstants(force := false, font := true, customDraw := false) {
    global
    if IsSet(TreeViewEx_constants_set) && !force {
        return
    }
    if InStr(DllCall('GetCommandLine', 'str'), '/Debug') < InStr(DllCall('GetCommandLine', 'str'), A_ScriptName) {
        OnError(__TreeViewEx_OnError, 1)
    }
    g_comctl32_DefSubclassProc :=
    g_comctl32_RemoveWindowSubclass :=
    g_comctl32_SetWindowSubclass :=
    g_gdi32_CreateFontIndirectW :=
    g_gdi32_DeleteObject :=
    g_gdi32_GetObjectW :=
    g_gdi32_GetTextExtentExPointW :=
    g_gdi32_GetTextExtentPoint32W :=
    g_msvcrt__wcsrev :=
    g_msvcrt_memmove :=
    g_user32_CreateWindowExW :=
    g_user32_DestroyWindow :=
    g_user32_GetDlgCtrlID :=
    g_user32_EnableWindow :=
    g_user32_GetDpiForWindow :=
    g_user32_IsWindowEnabled :=
    g_user32_IsWindowVisible :=
    g_user32_RedrawWindow :=
    g_user32_SetWindowLongPtrW :=
    g_user32_SetWindowPos :=
    g_user32_ShowWindow :=
    0

    TreeViewEx.LibToken := LibraryManager(Map(
        'comctl32', [ 'DefSubclassProc', 'RemoveWindowSubclass', 'SetWindowSubclass' ]
      , 'msvcrt', [ 'memmove', '_wcsrev' ]
      , 'user32', [ 'CreateWindowExW', 'DestroyWindow', 'EnableWindow', 'GetDlgCtrlID'
                  , 'GetDpiForWindow', 'IsWindowEnabled', 'IsWindowVisible', 'RedrawWindow'
                  , 'SetWindowLongPtrW', 'SetWindowPos', 'ShowWindow' ]
      , 'gdi32', [ 'CreateFontIndirectW', 'DeleteObject', 'GetObjectW', 'GetTextExtentExPointW', 'GetTextExtentPoint32W' ]
    ))

	TVEX_DEFAULT_ENCODING                       := 'cp1200'
    TVEX_DEFAULT_TEXT_MAX                       := 256
    TVEX_SENDNOTIFY_USECACHE                    := true
    TVEX_MAX_RECURSION                          := 7
    TVEX_SPACE_CHAR_START := 0x2000
    TVEX_SPACE_CHAR_END := 0x200B

	TV_FIRST                                    := 0x1100
	TVN_FIRST                                   := -400
	TVN_LAST                                    := -499

    ; https://learn.microsoft.com/en-us/windows/win32/controls/bumper-tree-view-tree-view-control-reference
	TVM_CREATEDRAGIMAGE                         := TV_FIRST + 18
	TVM_DELETEITEM                              := TV_FIRST + 1
	TVM_EDITLABELW                              := TV_FIRST + 65
	TVM_ENDEDITLABELNOW                         := TV_FIRST + 22
	TVM_ENSUREVISIBLE                           := TV_FIRST + 20
	TVM_EXPAND                                  := TV_FIRST + 2
	TVM_GETBKCOLOR                              := TV_FIRST + 31
	TVM_GETCOUNT                                := TV_FIRST + 5
	TVM_GETEDITCONTROL                          := TV_FIRST + 15
	TVM_GETEXTENDEDSTYLE                        := TV_FIRST + 45
	TVM_GETIMAGELIST                            := TV_FIRST + 8
	TVM_GETINDENT                               := TV_FIRST + 6
	TVM_GETINSERTMARKCOLOR                      := TV_FIRST + 38
	TVM_GETISEARCHSTRINGW                       := TV_FIRST + 64
	TVM_GETITEMHEIGHT                           := TV_FIRST + 28
	TVM_GETITEMRECT                             := TV_FIRST + 4
	TVM_GETITEMSTATE                            := TV_FIRST + 39
	TVM_GETITEMW                                := TV_FIRST + 62
	TVM_GETLINECOLOR                            := TV_FIRST + 41
	TVM_GETNEXTITEM                             := TV_FIRST + 10
	TVM_GETSCROLLTIME                           := TV_FIRST + 34
	TVM_GETSELECTEDCOUNT                        := TV_FIRST + 70
	TVM_GETTEXTCOLOR                            := TV_FIRST + 32
	TVM_GETTOOLTIPS                             := TV_FIRST + 25
	TVM_GETVISIBLECOUNT                         := TV_FIRST + 16
	TVM_HITTEST                                 := TV_FIRST + 17
	TVM_INSERTITEMW                             := TV_FIRST + 50
	TVM_MAPACCIDTOHTREEITEM                     := TV_FIRST + 42
	TVM_MAPHTREEITEMTOACCID                     := TV_FIRST + 43
	TVM_SELECTITEM                              := TV_FIRST + 11
	TVM_SETAUTOSCROLLINFO                       := TV_FIRST + 59
	TVM_SETBKCOLOR                              := TV_FIRST + 29
	TVM_SETBORDER                               := TV_FIRST + 35
	TVM_SETEXTENDEDSTYLE                        := TV_FIRST + 44
	TVM_SETHOT                                  := TV_FIRST + 58
	TVM_SETIMAGELIST                            := TV_FIRST + 9
	TVM_SETINDENT                               := TV_FIRST + 7
	TVM_SETINSERTMARK                           := TV_FIRST + 26
	TVM_SETINSERTMARKCOLOR                      := TV_FIRST + 37
	TVM_SETITEMHEIGHT                           := TV_FIRST + 27
	TVM_SETITEMW                                := TV_FIRST + 63
	TVM_SETLINECOLOR                            := TV_FIRST + 40
	TVM_SETSCROLLTIME                           := TV_FIRST + 33
	TVM_SETTEXTCOLOR                            := TV_FIRST + 30
	TVM_SETTOOLTIPS                             := TV_FIRST + 24
	TVM_SHOWINFOTIP                             := TV_FIRST + 71
	TVM_SORTCHILDREN                            := TV_FIRST + 19
	TVM_SORTCHILDRENCB                          := TV_FIRST + 21

	; TVM_EDITLABELA                              := TV_FIRST + 14
	; TVM_GETISEARCHSTRINGA                       := TV_FIRST + 23
	; TVM_GETITEMA                                := TV_FIRST + 12
	; TVM_INSERTITEMA                             := TV_FIRST + 0
	; TVM_SETITEMA                                := TV_FIRST + 13

    ; https://learn.microsoft.com/en-us/windows/win32/controls/bumper-tree-view-control-reference-notifications
    ; TVN_ and NM_ messages are all sent via WM_NOTIFY, use `TreeViewEx.Prototype.OnNotify`.
	TVN_ASYNCDRAW                               := TVN_FIRST - 20
	TVN_BEGINDRAGW                              := TVN_FIRST - 56
	TVN_BEGINLABELEDITW                         := TVN_FIRST - 59
	TVN_BEGINRDRAGW                             := TVN_FIRST - 57
	TVN_DELETEITEMW                             := TVN_FIRST - 58
	TVN_ENDLABELEDITW                           := TVN_FIRST - 60
	TVN_GETDISPINFOW                            := TVN_FIRST - 52
	TVN_GETINFOTIPW                             := TVN_FIRST - 14
	TVN_ITEMCHANGEDW                            := TVN_FIRST - 19
	TVN_ITEMCHANGINGW                           := TVN_FIRST - 17
	TVN_ITEMEXPANDEDW                           := TVN_FIRST - 55
	TVN_ITEMEXPANDINGW                          := TVN_FIRST - 54
	TVN_KEYDOWN                                 := TVN_FIRST - 12
	TVN_SELCHANGEDW                             := TVN_FIRST - 51
	TVN_SELCHANGINGW                            := TVN_FIRST - 50
	TVN_SETDISPINFOW                            := TVN_FIRST - 53
	TVN_SINGLEEXPAND                            := TVN_FIRST - 15

    ; TVN_ and NM_ messages are all sent via WM_NOTIFY, use `TreeViewEx.Prototype.OnNotify`.
    NM_FIRST                                    := 0

    NM_OUTOFMEMORY                              := NM_FIRST - 1
    NM_CLICK                                    := NM_FIRST - 2    ; uses NMCLICK struct
    NM_DBLCLK                                   := NM_FIRST - 3
    NM_RETURN                                   := NM_FIRST - 4
    NM_RCLICK                                   := NM_FIRST - 5    ; uses NMCLICK struct
    NM_RDBLCLK                                  := NM_FIRST - 6
    NM_SETFOCUS                                 := NM_FIRST - 7
    NM_KILLFOCUS                                := NM_FIRST - 8
    NM_CUSTOMDRAW                               := NM_FIRST - 12
    NM_HOVER                                    := NM_FIRST - 13
    NM_NCHITTEST                                := NM_FIRST - 14   ; uses NMMOUSE struct
    NM_KEYDOWN                                  := NM_FIRST - 15   ; uses NMKEY struct
    NM_RELEASEDCAPTURE                          := NM_FIRST - 16
    NM_SETCURSOR                                := NM_FIRST - 17   ; uses NMMOUSE struct
    NM_CHAR                                     := NM_FIRST - 18   ; uses NMCHAR struct
    NM_TOOLTIPSCREATED                          := NM_FIRST - 19   ; notify of when the tooltips window is create
    NM_LDOWN                                    := NM_FIRST - 20
    NM_RDOWN                                    := NM_FIRST - 21
    NM_THEMECHANGED                             := NM_FIRST - 22
    NM_FONTCHANGED                              := NM_FIRST - 23
    NM_CUSTOMTEXT                               := NM_FIRST - 24   ; uses NMCUSTOMTEXT struct
    NM_TVSTATEIMAGECHANGING                     := NM_FIRST - 24   ; uses NMTVSTATEIMAGECHANGING struct, defined after HTREEITEM

	; TVN_BEGINDRAGA                              := TVN_FIRST - 7
	; TVN_BEGINLABELEDITA                         := TVN_FIRST - 10
	; TVN_BEGINRDRAGA                             := TVN_FIRST - 8
	; TVN_DELETEITEMA                             := TVN_FIRST - 9
	; TVN_ENDLABELEDITA                           := TVN_FIRST - 11
	; TVN_GETDISPINFOA                            := TVN_FIRST - 3
	; TVN_GETINFOTIPA                             := TVN_FIRST - 13
	; TVN_ITEMCHANGEDA                            := TVN_FIRST - 18
	; TVN_ITEMCHANGINGA                           := TVN_FIRST - 16
	; TVN_ITEMEXPANDEDA                           := TVN_FIRST - 6
	; TVN_ITEMEXPANDINGA                          := TVN_FIRST - 5
	; TVN_SELCHANGEDA                             := TVN_FIRST - 2
	; TVN_SELCHANGINGA                            := TVN_FIRST - 1
	; TVN_SETDISPINFOA                            := TVN_FIRST - 4

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvn-singleexpand
	TVNRET_DEFAULT                              := 0
	TVNRET_SKIPOLD                              := 1
	TVNRET_SKIPNEW                              := 2

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvn-selchanged
	TVC_UNKNOWN                                 := 0x0000
	TVC_BYMOUSE                                 := 0x0001
	TVC_BYKEYBOARD                              := 0x0002

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvm-expand
	TVE_COLLAPSE                                := 0x0001
	TVE_EXPAND                                  := 0x0002
	TVE_TOGGLE                                  := 0x0003
	TVE_EXPANDPARTIAL                           := 0x4000
	TVE_COLLAPSERESET                           := 0x8000

    ; https://learn.microsoft.com/en-us/windows/win32/api/commctrl/ns-commctrl-tvinsertstructw
	TVI_FIRST                                   := -0x0FFFF
	TVI_LAST                                    := -0x0FFFE
	TVI_ROOT                                    := -0x10000
	TVI_SORT                                    := -0x0FFFD

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setimagelist
	TVSIL_NORMAL                                := 0
	TVSIL_STATE                                 := 2

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvm-getnextitem
    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvm-selectitem
	TVGN_CARET                                  := 0x0009
	TVGN_CHILD                                  := 0x0004
	TVGN_DROPHILITE                             := 0x0008
	TVGN_FIRSTVISIBLE                           := 0x0005
	TVGN_LASTVISIBLE                            := 0x000A
	TVGN_NEXT                                   := 0x0001
	TVGN_NEXTSELECTED                           := 0x000B
	TVGN_NEXTVISIBLE                            := 0x0006
	TVGN_PARENT                                 := 0x0003
	TVGN_PREVIOUS                               := 0x0002
	TVGN_PREVIOUSVISIBLE                        := 0x0007
	TVGN_ROOT                                   := 0x0000
	TVSI_NOSINGLEEXPAND                         := 0x8000

	; https://learn.microsoft.com/en-us/windows/win32/api/commctrl/ns-commctrl-tvitemexa
	TVIF_CHILDREN                               := 0x0040
	TVIF_DI_SETITEM                             := 0x1000
	TVIF_EXPANDEDIMAGE                          := 0x0200
	TVIF_HANDLE                                 := 0x0010
	TVIF_IMAGE                                  := 0x0002
	TVIF_INTEGRAL                               := 0x0080
	TVIF_PARAM                                  := 0x0004
	TVIF_SELECTEDIMAGE                          := 0x0020
	TVIF_STATE                                  := 0x0008
	TVIF_STATEEX                                := 0x0100
	TVIF_TEXT                                   := 0x0001

    ; https://learn.microsoft.com/en-us/windows/win32/api/commctrl/ns-commctrl-tvhittestinfo
	TVHT_ABOVE                                  := 0x0100
	TVHT_BELOW                                  := 0x0200
	TVHT_NOWHERE                                := 0x0001
	TVHT_ONITEMBUTTON                           := 0x0010
	TVHT_ONITEMICON                             := 0x0002
	TVHT_ONITEMINDENT                           := 0x0008
	TVHT_ONITEMLABEL                            := 0x0004
	TVHT_ONITEMRIGHT                            := 0x0020
	TVHT_ONITEMSTATEICON                        := 0x0040
	TVHT_TOLEFT                                 := 0x0800
	TVHT_TORIGHT                                := 0x0400
	TVHT_ONITEM                                 := TVHT_ONITEMICON | TVHT_ONITEMLABEL | TVHT_ONITEMSTATEICON

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setborder
	TVSBF_XBORDER                               := 0x00000001
	TVSBF_YBORDER                               := 0x00000002

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tree-view-control-window-styles
	TVS_CHECKBOXES                              := 0x0100
	TVS_DISABLEDRAGDROP                         := 0x0010
	TVS_EDITLABELS                              := 0x0008
	TVS_FULLROWSELECT                           := 0x1000
	TVS_HASBUTTONS                              := 0x0001
	TVS_HASLINES                                := 0x0002
	TVS_INFOTIP                                 := 0x0800
	TVS_LINESATROOT                             := 0x0004
	TVS_NOHSCROLL                               := 0x8000
	TVS_NONEVENHEIGHT                           := 0x4000
	TVS_NOSCROLL                                := 0x2000
	TVS_NOTOOLTIPS                              := 0x0080
	TVS_RTLREADING                              := 0x0040
	TVS_SHOWSELALWAYS                           := 0x0020
	TVS_SINGLEEXPAND                            := 0x0400
	TVS_TRACKSELECT                             := 0x0200

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tree-view-control-window-extended-styles
	TVS_EX_AUTOHSCROLL                          := 0x0020
	TVS_EX_DIMMEDCHECKBOXES                     := 0x0200
	TVS_EX_DOUBLEBUFFER                         := 0x0004
	TVS_EX_DRAWIMAGEASYNC                       := 0x0400
	TVS_EX_EXCLUSIONCHECKBOXES                  := 0x0100
	TVS_EX_FADEINOUTEXPANDOS                    := 0x0040
	TVS_EX_MULTISELECT                          := 0x0002
	TVS_EX_NOINDENTSTATE                        := 0x0008
	TVS_EX_NOSINGLECOLLAPSE                     := 0x0001
	TVS_EX_PARTIALCHECKBOXES                    := 0x0080
	TVS_EX_RICHTOOLTIP                          := 0x0010

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tree-view-control-item-states
	TVIS_BOLD                                   := 0x0010
	TVIS_CUT                                    := 0x0004
	TVIS_DROPHILITED                            := 0x0008
	TVIS_EXPANDED                               := 0x0020
	TVIS_EXPANDEDONCE                           := 0x0040
	TVIS_EXPANDPARTIAL                          := 0x0080
	TVIS_OVERLAYMASK                            := 0x0F00
	TVIS_SELECTED                               := 0x0002
	TVIS_STATEIMAGEMASK                         := 0xF000
	TVIS_USERMASK                               := 0xF000

    ; https://learn.microsoft.com/en-us/windows/win32/api/commctrl/ns-commctrl-tvitemexw
	TVIS_EX_FLAT                                := 0x0001
	TVIS_EX_DISABLED                            := 0x0002
	TVIS_EX_ALL                                 := 0x0002 ; TVIS_EX_ALL == TVIS_EX_DISABLED
    ; None of my header files contain TVIS_EX_HWND, not sure where it is defined

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvn-getdispinfo
	I_CHILDRENCALLBACK                          := -1
	I_CHILDRENAUTO                              := -2
	LPSTR_TEXTCALLBACKW                         := -1
	I_IMAGECALLBACK                             := -1
	I_IMAGENONE                                 := -2

    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvm-getlinecolor
    ; https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setlinecolor
	CLR_NONE                                    := 0xFFFFFFFF
	CLR_DEFAULT                                 := 0xFF000000

    SWP_NONE                                    := 0x0000
    SWP_NOSIZE                                  := 0x0001
    SWP_NOMOVE                                  := 0x0002
    SWP_NOZORDER                                := 0x0004
    SWP_NOREDRAW                                := 0x0008
    SWP_NOACTIVATE                              := 0x0010
    SWP_FRAMECHANGED                            := 0x0020
    SWP_SHOWWINDOW                              := 0x0040
    SWP_HIDEWINDOW                              := 0x0080
    SWP_NOCOPYBITS                              := 0x0100
    SWP_NOOWNERZORDER                           := 0x0200
    SWP_NOSENDCHANGING                          := 0x0400
    SWP_DEFERERASE                              := 0x2000
    SWP_ASYNCWINDOWPOS                          := 0x4000
    SWP_DRAWFRAME                               := SWP_FRAMECHANGED
    SWP_NOREPOSITION                            := SWP_NOOWNERZORDER

    ; https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles
	WS_BORDER                                   := 0x00800000
	WS_CAPTION                                  := 0x00C00000
	WS_CHILD                                    := 0x40000000
	WS_CHILDWINDOW                              := 0x40000000
	WS_CLIPCHILDREN                             := 0x02000000
	WS_CLIPSIBLINGS                             := 0x04000000
	WS_DISABLED                                 := 0x08000000
	WS_DLGFRAME                                 := 0x00400000
	WS_GROUP                                    := 0x00020000
	WS_HSCROLL                                  := 0x00100000
	WS_ICONIC                                   := 0x20000000
	WS_MAXIMIZE                                 := 0x01000000
	WS_MAXIMIZEBOX                              := 0x00010000
	WS_MINIMIZE                                 := 0x20000000
	WS_MINIMIZEBOX                              := 0x00020000
	WS_OVERLAPPED                               := 0x00000000
	WS_POPUP                                    := 0x80000000
	WS_SIZEBOX                                  := 0x00040000
	WS_SYSMENU                                  := 0x00080000
	WS_TABSTOP                                  := 0x00010000
	WS_THICKFRAME                               := 0x00040000
	WS_TILED                                    := 0x00000000
	WS_VISIBLE                                  := 0x10000000
	WS_VSCROLL                                  := 0x00200000
	WS_POPUPWINDOW                              := WS_POPUP | WS_BORDER | WS_SYSMENU
	WS_TILEDWINDOW                              := WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX
	WS_OVERLAPPEDWINDOW                         := WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX

    ; https://learn.microsoft.com/en-us/windows/win32/winmsg/extended-window-styles
	WS_EX_ACCEPTFILES                           := 0x00000010
	WS_EX_APPWINDOW                             := 0x00040000
	WS_EX_CLIENTEDGE                            := 0x00000200
	WS_EX_COMPOSITED                            := 0x02000000
	WS_EX_CONTEXTHELP                           := 0x00000400
	WS_EX_CONTROLPARENT                         := 0x00010000
	WS_EX_DLGMODALFRAME                         := 0x00000001
	WS_EX_LAYERED                               := 0x00080000
	WS_EX_LAYOUTRTL                             := 0x00400000
	WS_EX_LEFT                                  := 0x00000000
	WS_EX_LEFTSCROLLBAR                         := 0x00004000
	WS_EX_LTRREADING                            := 0x00000000
	WS_EX_MDICHILD                              := 0x00000040
	WS_EX_NOACTIVATE                            := 0x08000000
	WS_EX_NOINHERITLAYOUT                       := 0x00100000
	WS_EX_NOPARENTNOTIFY                        := 0x00000004
	WS_EX_NOREDIRECTIONBITMAP                   := 0x00200000
	WS_EX_RIGHT                                 := 0x00001000
	WS_EX_RIGHTSCROLLBAR                        := 0x00000000
	WS_EX_RTLREADING                            := 0x00002000
	WS_EX_STATICEDGE                            := 0x00020000
	WS_EX_TOOLWINDOW                            := 0x00000080
	WS_EX_TOPMOST                               := 0x00000008
	WS_EX_TRANSPARENT                           := 0x00000020
	WS_EX_WINDOWEDGE                            := 0x00000100
	WS_EX_OVERLAPPEDWINDOW                      := WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
	WS_EX_PALETTEWINDOW                         := WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST

    ; https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw
	CW_USEDEFAULT                               := 0x80000000

    ; https://learn.microsoft.com/en-us/windows/win32/menurc/wm-command
    WM_COMMAND                                  := 0x0111
    ; https://learn.microsoft.com/en-us/windows/win32/controls/wm-notify
    WM_NOTIFY                                   := 0x004E
    ; https://learn.microsoft.com/en-us/windows/win32/menurc/wm-contextmenu
    WM_CONTEXTMENU                              := 0x007B
    ; https://learn.microsoft.com/en-us/windows/win32/controls/wm-hscroll
    WM_HSCROLL                                  := 0x0114
    ; https://learn.microsoft.com/en-us/windows/win32/controls/wm-vscroll
    WM_VSCROLL                                  := 0x0115
    ; https://learn.microsoft.com/en-us/windows/win32/winmsg/wm-destroy
    WM_DESTROY                                  := 0x0002
    ; https://learn.microsoft.com/en-us/windows/win32/winmsg/wm-close
    WM_CLOSE                                    := 0x0010
    ; https://learn.microsoft.com/en-us/windows/win32/winmsg/wm-ncdestroy
    WM_NCDESTROY                                := 0x0082
    ; If the user clicks the "X" to close the gui window
    ; https://learn.microsoft.com/en-us/windows/win32/menurc/wm-syscommand
    WM_SYSCOMMAND                               := 0x0112
    SC_CLOSE                                    := 0xF060
    ; https://learn.microsoft.com/en-us/windows/win32/gdi/wm-setredraw
    WM_SETREDRAW                                := 0x000B
    ; https://learn.microsoft.com/en-us/windows/win32/winmsg/wm-getfont
    WM_GETFONT                                  := 0x0031
    ; https://learn.microsoft.com/en-us/windows/win32/winmsg/wm-setfont
    WM_SETFONT                                  := 0x0030
    ; https://learn.microsoft.com/en-us/windows/win32/winmsg/wm-size
    WM_SIZE                                     := 0x0005

    ; https://learn.microsoft.com/en-us/windows/win32/api/Winuser/nf-winuser-redrawwindow
    RDW_INVALIDATE                              := 0x0001
    RDW_INTERNALPAINT                           := 0x0002
    RDW_ERASE                                   := 0x0004
    RDW_VALIDATE                                := 0x0008
    RDW_NOINTERNALPAINT                         := 0x0010
    RDW_NOERASE                                 := 0x0020
    RDW_NOCHILDREN                              := 0x0040
    RDW_ALLCHILDREN                             := 0x0080
    RDW_UPDATENOW                               := 0x0100
    RDW_ERASENOW                                := 0x0200
    RDW_FRAME                                   := 0x0400
    RDW_NOFRAME                                 := 0x0800

    ; Messages sent when editing a tree-view item's label, not currently implemented.
    ; EN_SETFOCUS                                 := 0x0100
    ; EN_KILLFOCUS                                := 0x0200
    ; EN_CHANGE                                   := 0x0300
    ; EN_UPDATE                                   := 0x0400
    ; EN_ERRSPACE                                 := 0x0500
    ; EN_MAXTEXT                                  := 0x0501
    ; EN_HSCROLL                                  := 0x0601
    ; EN_VSCROLL                                  := 0x0602

    ; These are messages that might be sent to the tree-view control. Handling messages to the tree-view
    ; control is not implemented currently.
    ; Message                     Value        Description                                   Purpose
    ; WM_CHAR                                     := 0x0102     ; Translated key input (character).             Hotkey text entry, search filtering, rename activation.
    ; WM_CONTEXTMENU                              := 0x007B     ; Right-click menu trigger.                     Override context menu position or contents.
    ; WM_CREATE                                   := 0x0001     ; Sent when control is being created.           Initialize custom data, fonts, or subclass child edit control.
    ; WM_DPICHANGED                               := 0x02E0     ; Monitor DPI changed.                          Recompute item spacing, icons.
    ; WM_ENABLE                                   := 0x000A     ; Control enabled/disabled.                     Repaint to show disabled state.
    ; WM_ERASEBKGND                               := 0x0014     ; Erase background before paint.                Return nonzero to prevent flicker (double-buffering).
    ; WM_GETDLGCODE                               := 0x0087     ; Query input handling.                         Allow Enter/Tab to behave differently.
    ; WM_GETOBJECT                                := 0x003D     ; Accessibility (UIA/MSAA).                     Let default handler process this or accessibility breaks.
    ; WM_HITTEST                                  := 0x0084     ; Non-client hit test (rare).                   Custom resizing, border drag.
    ; WM_KEYDOWN                                  := 0x0100     ; A key pressed.                                Custom shortcuts (e.g. Delete key behavior).
    ; WM_KEYUP                                    := 0x0101     ; A key released.                               Often ignored.
    ; WM_KILLFOCUS                                := 0x0008     ; TreeView loses focus.                         Clear hover/selection highlight.
    ; WM_LBUTTONDBLCLK                            := 0x0203     ; Double-click.                                 Suppress expansion or override default behavior.
    ; WM_LBUTTONDOWN                              := 0x0201     ; Left click pressed/released.                  Custom drag-drop, selection tweaks, hit-testing.
    ; WM_LBUTTONUP                                := 0x0202     ; Left click pressed/released.                  Custom drag-drop, selection tweaks, hit-testing.
    ; WM_MOUSEHOVER                               := 0x02A1     ; Hover state tracking.                         Show custom tooltip or highlight node.
    ; WM_MOUSELEAVE                               := 0x02A3     ; Hover state tracking.                         Show custom tooltip or highlight node.
    ; WM_MOUSEMOVE                                := 0x0200     ; Mouse moved.                                  Hover effects, tooltips, auto-scroll.
    ; WM_MOUSEWHEEL                               := 0x020A     ; Wheel scrolled.                               Custom scroll behavior (e.g., zoom or horizontal scroll).
    ; WM_MOVE                                     := 0x0003     ; Control moved.                                Update coordinate-dependent resources.
    ; WM_NCDESTROY                                := 0x0082     ; Window non-client area destroyed.             Clean up subclass pointers (you usually restore old WndProc here).
    ; WM_NOTIFYFORMAT                             := 0x0055     ; Unicode/ANSI negotiation.                     Return NFR_UNICODE to force Unicode notifications.
    ; WM_PAINT                                    := 0x000F     ; Paints the control.                           Owner-draw / custom background or highlight logic.
    ; WM_PRINT                                    := 0x0317     ; Used by system for Print/Preview.             Usually ignored.
    ; WM_PRINTCLIENT                              := 0x0318     ; Used by system for Print/Preview.             Usually ignored.
    ; WM_RBUTTONDOWN                              := 0x0204     ; Right-click.                                  Custom context menus, multi-select.
    ; WM_RBUTTONUP                                := 0x0205     ; Right-click.                                  Custom context menus, multi-select.
    ; WM_SETCURSOR                                := 0x0020     ; Mouse cursor moves over control.              Custom cursor per region/item.
    ; WM_SETFOCUS                                 := 0x0007     ; TreeView gains focus.                         Custom highlight or state behavior.
    ; WM_SIZE                                     := 0x0005     ; TreeView resized.                             Recalculate layout, reposition overlay elements.
    ; WM_STYLECHANGED                             := 0x007D     ; Window style modified.                        Respond to checkboxes, lines, root toggling.
    ; WM_STYLECHANGING                            := 0x007C     ; Window style modified.                        Respond to checkboxes, lines, root toggling.
    ; WM_SYSKEYDOWN                               := 0x0104     ; Alt key combinations.                         Custom menu accelerators.
    ; WM_SYSKEYUP                                 := 0x0105     ; Alt key combinations.                         Custom menu accelerators.
    ; WM_THEMECHANGED                             := 0x031A     ; Theme or visual style changed.                Re-query theme data (UXTheme).
    ; WM_TIMER                                    := 0x0113     ; Used internally by hover-select / scroll.     Avoid interfering unless you own the timer ID.
    ; WM_WINDOWPOSCHANGED                         := 0x0047     ; Z-order / position changes.                   Adjust or lock layout behavior.
    ; WM_WINDOWPOSCHANGING                        := 0x0046     ; Z-order / position changes.                   Adjust or lock layout behavior.

    ; https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptrw
    ; GWL_WNDPROC                                 := -4
    ; GWL_HINSTANCE                               := -6
    ; GWL_HWNDPARENT                              := -8
    ; GWL_STYLE                                   := -16
    ; GWL_EXSTYLE                                 := -20
    ; GWL_USERDATA                                := -21
    ; GWL_ID                                      := -12
    ; GWLP_WNDPROC                                := -4
    ; GWLP_HINSTANCE                              := -6
    ; GWLP_HWNDPARENT                             := -8
    ; GWLP_USERDATA                               := -21
    GWLP_ID                                     := -12

	if font {
		TreeViewEx_SetConstants_Font(force)
	}
	if customDraw {
		TreeViewEx_SetConstants_CustomDraw(force)
	}

    TreeViewEx_constants_set := 1
}

/**
 * Sets the global constant variables.
 *
 * @param {Boolean} [force = false] - When false, if `TreeViewEx_SetConstants` has already been called
 * (more specifically, if `TreeViewEx_constants_font_set` has been set), the function returns immediately.
 * If true, the function executes in its entirety.
 */
TreeViewEx_SetConstants_Font(force := false) {
    global
    if IsSet(TreeViewEx_constants_font_set) && !force {
        return
    }
    ; https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-logfontw
	OUT_CHARACTER_PRECIS                        := 2
	OUT_DEFAULT_PRECIS                          := 0
	OUT_DEVICE_PRECIS                           := 5
	OUT_OUTLINE_PRECIS                          := 8
	OUT_PS_ONLY_PRECIS                          := 10
	OUT_RASTER_PRECIS                           := 6
	OUT_SCREEN_OUTLINE_PRECIS                   := 9
	OUT_STRING_PRECIS                           := 1
	OUT_STROKE_PRECIS                           := 3
	OUT_TT_ONLY_PRECIS                          := 7
	OUT_TT_PRECIS                               := 4

    ; https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-logfontw
	CLIP_CHARACTER_PRECIS                       := 1
	CLIP_DEFAULT_PRECIS                         := 0
	CLIP_DFA_DISABLE                            := 4 << 4
	CLIP_EMBEDDED                               := 8 << 4
	CLIP_LH_ANGLES                              := 1 << 4
	CLIP_MASK                                   := 0xf
	CLIP_STROKE_PRECIS                          := 2
	CLIP_TT_ALWAYS                              := 2 << 4

    ; https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-logfontw
	ANTIALIASED_QUALITY                         := 4
	DEFAULT_QUALITY                             := 0
	DRAFT_QUALITY                               := 1
	NONANTIALIASED_QUALITY                      := 3
	PROOF_QUALITY                               := 2

    ; https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-logfontw
	CLEARTYPE_NATURAL_QUALITY                   := 6
	CLEARTYPE_QUALITY                           := 5

    ; https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-logfontw
	DEFAULT_PITCH                               := 0
	FIXED_PITCH                                 := 1
	MONO_FONT                                   := 8
	VARIABLE_PITCH                              := 2

    ; https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-logfontw
	ANSI_CHARSET                                := 0
	ARABIC_CHARSET                              := 178
	CHINESEBIG5_CHARSET                         := 136
	DEFAULT_CHARSET                             := 1
	EASTEUROPE_CHARSET                          := 238
	GB2312_CHARSET                              := 134
	GREEK_CHARSET                               := 161
	HANGEUL_CHARSET                             := 129
	HANGUL_CHARSET                              := 129
	HEBREW_CHARSET                              := 177
	JOHAB_CHARSET                               := 130
	OEM_CHARSET                                 := 255
	RUSSIAN_CHARSET                             := 204
	SHIFTJIS_CHARSET                            := 128
	SYMBOL_CHARSET                              := 2
	THAI_CHARSET                                := 222
	TURKISH_CHARSET                             := 162
	VIETNAMESE_CHARSET                          := 163
	BALTIC_CHARSET                              := 186
	MAC_CHARSET                                 := 77

    ; https://learn.microsoft.com/en-us/windows/win32/intl/code-page-bitfields
	FS_LATIN1                                   := 0x00000001
	FS_LATIN2                                   := 0x00000002
	FS_CYRILLIC                                 := 0x00000004
	FS_GREEK                                    := 0x00000008
	FS_TURKISH                                  := 0x00000010
	FS_HEBREW                                   := 0x00000020
	FS_ARABIC                                   := 0x00000040
	FS_BALTIC                                   := 0x00000080
	FS_VIETNAMESE                               := 0x00000100
	FS_THAI                                     := 0x00010000
	FS_JISJAPAN                                 := 0x00020000
	FS_CHINESESIMP                              := 0x00040000
	FS_WANSUNG                                  := 0x00080000
	FS_CHINESETRAD                              := 0x00100000
	FS_JOHAB                                    := 0x00200000
	FS_SYMBOL                                   := 0x80000000

    ; https://learn.microsoft.com/en-us/windows/win32/api/dimm/ns-dimm-logfontw
	FF_DECORATIVE                               := 0x50 ; 80    Old English, etc.
	FF_DONTCARE                                 := 0x00 ; 0     Don't care or don't know.
	FF_MODERN                                   := 0x30 ; 48    Constant stroke width, serifed or sans-serifed. Pica, Elite, Courier, etc.
	FF_ROMAN                                    := 0x10 ; 16    Variable stroke width, serifed. Times Roman, Century Schoolbook, etc.
	FF_SCRIPT                                   := 0x40 ; 64    Cursive, etc.
	FF_SWISS                                    := 0x20 ; 32    Variable stroke width, sans-serifed. Helvetica, Swiss, etc.

    ; https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-logfontw
	FW_BOLD                                     := 700
	FW_DONTCARE                                 := 0
	FW_EXTRABOLD                                := 800
	FW_EXTRALIGHT                               := 200
	FW_HEAVY                                    := 900
	FW_LIGHT                                    := 300
	FW_MEDIUM                                   := 500
	FW_NORMAL                                   := 400
	FW_SEMIBOLD                                 := 600
	FW_THIN                                     := 100
	FW_BLACK                                    := FW_HEAVY
	FW_DEMIBOLD                                 := FW_SEMIBOLD
	FW_REGULAR                                  := FW_NORMAL
	FW_ULTRABOLD                                := FW_EXTRABOLD
	FW_ULTRALIGHT                               := FW_EXTRALIGHT

    ; https://learn.microsoft.com/en-us/windows/win32/gdi/enumerating-the-installed-fonts
	RASTER_FONTTYPE                             := 0x0001
	DEVICE_FONTTYPE                             := 0x0002
	TRUETYPE_FONTTYPE                           := 0x0004

	TreeViewEx_constants_font_set := true
}

/**
 * Sets the global constant variables.
 *
 * @param {Boolean} [force = false] - When false, if `TreeViewEx_SetConstants` has already been called
 * (more specifically, if `TreeViewEx_constants_set` has been set), the function returns immediately.
 * If true, the function executes in its entirety.
 */
TreeViewEx_SetConstants_CustomDraw(force := false) {
    global
    if IsSet(TreeViewEx_constants_custom_draw_set) && !force {
        return
    }
    CDRF_DODEFAULT             := 0x00000000
    CDRF_NEWFONT               := 0x00000002
    CDRF_SKIPDEFAULT           := 0x00000004
    CDRF_DOERASE               := 0x00000008 ; draw the background
    CDRF_SKIPPOSTPAINT         := 0x00000100 ; don't draw the focus rect

    CDRF_NOTIFYPOSTPAINT       := 0x00000010
    CDRF_NOTIFYITEMDRAW        := 0x00000020
    CDRF_NOTIFYSUBITEMDRAW     := 0x00000020  ; flags are the same, we can distinguish by context
    CDRF_NOTIFYPOSTERASE       := 0x00000040

    ; drawstage flags
    ; values under 0x00010000 are reserved for global custom draw values.
    ; above that are for specific controls
    CDDS_PREPAINT              := 0x00000001
    CDDS_POSTPAINT             := 0x00000002
    CDDS_PREERASE              := 0x00000003
    CDDS_POSTERASE             := 0x00000004
    ; the 0x000010000 bit means it's individual item specific
    CDDS_ITEM                  := 0x00010000
    CDDS_ITEMPREPAINT          := CDDS_ITEM | CDDS_PREPAINT
    CDDS_ITEMPOSTPAINT         := CDDS_ITEM | CDDS_POSTPAINT
    CDDS_ITEMPREERASE          := CDDS_ITEM | CDDS_PREERASE
    CDDS_ITEMPOSTERASE         := CDDS_ITEM | CDDS_POSTERASE
    CDDS_SUBITEM               := 0x00020000

    CDIS_SELECTED              := 0x0001
    CDIS_GRAYED                := 0x0002
    CDIS_DISABLED              := 0x0004
    CDIS_CHECKED               := 0x0008
    CDIS_FOCUS                 := 0x0010
    CDIS_DEFAULT               := 0x0020
    CDIS_HOT                   := 0x0040
    CDIS_MARKED                := 0x0080
    CDIS_INDETERMINATE         := 0x0100
    CDIS_SHOWKEYBOARDCUES      := 0x0200
    CDIS_NEARHOT               := 0x0400
    CDIS_OTHERSIDEHOT          := 0x0800
    CDIS_DROPHILITED           := 0x1000

	TreeViewEx_constants_custom_draw_set := true
}

; This is a workaround of an issue that occurs when exiting a script from a debugger.
__TreeViewEx_OnError(thrown, *) {
    if thrown.Message = 'This value of type "Object" has no method named "Call".' {
        return 1
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * {@link https://learn.microsoft.com/en-us/windows/win32/api/commctrl/nc-commctrl-subclassproc}
 *
 * The {@link TreeViewEx} class is completely custom-built; it does not inherit from `Gui.TreeView`
 * nor `Gui.Control`. Consequently, {@link TreeViewEx} instances are unable to be used with
 * `Gui.Control.Prototype.OnCommand`, `Gui.Control.Prototype.OnNotify`, and `Gui.Control.Prototype.OnEvent`.
 *
 * To monitor, intercept, and handle system commands, notifications, and window messages,
 * this library uses {@link https://learn.microsoft.com/en-us/windows/win32/api/commctrl/nf-commctrl-setwindowsubclass SetWindowSubclass},
 * facilitated by the {@link TreeViewEx_WindowSubclass} class.
 * {@link TreeViewEx_ParentSubclassProc} is the function that is called for messages sent to the
 * {@link TreeViewEx} object's parent window, i.e. the gui.
 *
 * {@link TreeViewEx_ParentSubclassProc} expects that {@link TreeViewEx_ParentSubclassProc~uIdSubclass}
 * is the hwnd to a {@link TreeViewEx} control, and that {@link TreeViewEx_ParentSubclassProc~dwRefData}
 * is the ptr to the {@link TreeViewEx_Subclass} object set to property
 * {@link TreeViewEx#ParentSubclass}. This is done automatically when
 * {@link TreeViewEx.Prototype.OnCommand}, {@link TreeViewEx.Prototype.OnNotify},
 * or {@link TreeViewEx.Prototype.OnMessage} is called.
 *
 * {@link TreeViewEx_Subclass} allows for any single code to have multiple callbacks. The callbacks
 * are called one at a time, and if any of the callbacks return a nonzero value, that halts processing
 * and {@link TreeViewEx_ParentSubclassProc} returns that value instead of calling `DefSubclassProc`.
 * If all callbacks return zero or an empty string, `DefSubclassProc` is called.
 *
 * @param {Integer} HwndSubclass - The handle to the subclassed window (the handle passed to `SetWindowSubclass`).
 * This is expected to be the handle to the gui window to which the {@link TreeViewEx} control was added.
 *
 * @param {Integer} uMsg - The message being passed.
 *
 * @param {Integer} wParam - Additional message information. The contents of this parameter depend
 * on the value of uMsg.
 *
 * @param {Integer} lParam - Additional message information. The contents of this parameter depend on the value of uMsg.
 *
 * @param {Integer} uIdSubclass - The subclass ID. This is expected to be the hwnd to a {@link TreeViewEx}
 * control.
 *
 * @param {Integer} dwRefData - The reference data provided to the SetWindowSubclass function. This
 * is expected to be the ptr to the {@link TreeViewEx_Subclass} object set to property
 * {@link TreeViewEx#ParentSubclass}.
 */
TreeViewEx_ParentSubclassProc(HwndSubclass, uMsg, wParam, lParam, uIdSubclass, dwRefData) {
    if !HasMethod(Object, 'Call') {
        return
    }
    originalCritical := Critical(-1)
    subclass := ObjFromPtrAddRef(dwRefData)
    switch uMsg {
        case WM_COMMAND:
            ; In this case, we don't need the control ID (low word wParam value). The control ID
            ; has the advantage of being defined by the application and consistent across sessions,
            ; whereas the hwnd changes every time the control is created.
            ; For example, if I create a custom dialogue with an OK button, I would assign the same
            ; ID to the button every time it is created. Then, in my window procedure, I can target
            ; the button using that ID. In the case of this function and the TreeViewEx library,
            ; control IDs are not used (unless defined by the caller) and the "OnCommand" logic
            ; targets the control using the parent hwnd (HwndSubclass) and control hwnd
            ; (uIdSubclass).
            if subclass.flag_Command {
                if collectionCallback := subclass.CommandGet((wParam >> 16) & 0xFFFF) {
                    tvex := TreeViewEx.Get(uIdSubclass)
                    for cb in collectionCallback {
                        if result := cb(tvex) {
                            return result
                        }
                    }
                }
            }
        case WM_NOTIFY:
            if subclass.flag_Notify {
                hdr := TvNmHdr.FromPtr(lParam)
                if hdr.hwndFrom = uIdSubclass {
                    if collectionCallback := subclass.NotifyGet(hdr.code_int) {
                        struct := hdr.Cast()
                        tvex := TreeViewEx.Get(uIdSubclass)
                        for cb in collectionCallback {
                            if result := cb(tvex, struct) {
                                return result
                            }
                        }
                    }
                }
            }
        default:
            if subclass.flag_Message {
                if collectionCallback := subclass.MessageGet(uMsg) {
                    tvex := TreeViewEx.Get(uIdSubclass)
                    for cb in collectionCallback {
                        if result := cb(tvex, wParam, lParam, uMsg, HwndSubclass) {
                            return result
                        }
                    }
                }
            }
    }
    Critical(originalCritical)
    return DllCall(
        g_comctl32_DefSubclassProc
      , 'ptr', HwndSubclass
      , 'uint', uMsg
      , 'uptr', wParam
      , 'ptr', lParam
      , 'ptr'
    )
}

/**
 * Destroys the TreeViewEx object when the control window is destroyed.
 */
TreeViewEx_ControlSubclassProc(HwndSubclass, uMsg, wParam, lParam, uIdSubclass, dwRefData) {
    if !HasMethod(Object, 'Call') {
        return
    }
    if uMsg == WM_NCDESTROY {
        TreeViewEx.Get(HwndSubclass).Dispose()
    }
    return DllCall(
        g_comctl32_DefSubclassProc
      , 'ptr', HwndSubclass
      , 'uint', uMsg
      , 'uptr', wParam
      , 'ptr', lParam
      , 'ptr'
    )
}

/**
 * Returns the TreeViewEx object using the hwnd set to property "HwndControl". This function is
 * used in the body of {@link TreeViewEx.Prototype.SetNodeConstructor}. This is analagous
 * to the native `GuiCtrlFromHwnd`.
 */
TreeViewEx_GetTreeViewExCtrl(self) {
    return TreeViewEx.Get(self.HwndCtrl)
}

/**
 * Destroys the TreeViewEx object when the script is exiting. This is necessary to avoid errors
 * from {@link TreeViewEx_ParentSubclassProc}.
 */
TreeViewEx_CallbackOnExit(Hwnd, *) {
    TreeViewEx.Get(Hwnd).Dispose()
}

/**
 * Displays the context menu.
 */
TreeViewEx_HandlerContextMenu(tvex, wParam, lParam, *) {
    if tvex.Enabled {
        MouseGetPos(&mx, &my)
        x := lParam & 0xFFFF
        y := (lParam >> 16) & 0xFFFF
        ; If the context menu was activated by a keyboard button instead of right-click
        if x = -1 && y = -1 {
            handle := tvex.GetSelected()
            rc := tvex.GetItemRect(handle)
            x := rc.L
            y := rc.T
            IsRightClick := 0
        ; If the context menu was activated by right-click
        } else {
            pt := Point(X, Y)
            pt.ToClient(tvex.Hwnd, true)
            if hitTestInfo := tvex.HitTest(pt.X, pt.Y) {
                handle := hitTestInfo.hItem
            } else {
                handle := 0
            }
            IsRightClick := 1
            x := pt.X
            y := pt.Y
        }
        tvex.ContextMenu.Call(tvex, Handle, IsRightClick, X, Y)
    }
}

/**
 * Returns a COLORREF integer.
 *
 * @param {Integer} [r = 0] - The red value.
 * @param {Integer} [g = 0] - The green value.
 * @param {Integer} [b = 0] - The blue value.
 * @returns {Integer}
 */
TreeViewEx_RGB(r := 0, g := 0, b := 0) {
    return (r & 0xFF) | ((g & 0xFF) << 8) | ((b & 0xFF) << 16)
}

/**
 * Parses a COLORREF integer.
 *
 * @param {Integer} colorref - The COLORREF integer.
 * @param {VarRef} [OutR] - A variable that will receive the red value.
 * @param {VarRef} [OutG] - A variable that will receive the green value.
 * @param {VarRef} [OutB] - A variable that will receive the blue value.
 */
TreeViewEx_ParseColorRef(colorref, &OutR?, &OutG?, &OutB?) {
    OutR := colorref & 0xFF
    OutG := (colorref >> 8) & 0xFF
    OutB := (colorref >> 16) & 0xFF
}

/**
 * Calls a callback when the edit control from an edit label action is destroyed. See
 * {@link TreeViewEx_LabelEditDestroyNotification.Prototype.__New}.
 */
TreeViewEx_LabelEditSubclassProc(HwndSubclass, uMsg, wParam, lParam, uIdSubclass, dwRefData) {
    Critical('Off')
    if uMsg == WM_NCDESTROY {
        TreeViewEx_LabelEditDestroyNotification.Process(HwndSubclass)
    }
    return DllCall(
        g_comctl32_DefSubclassProc
      , 'ptr', HwndSubclass
      , 'uint', uMsg
      , 'uptr', wParam
      , 'ptr', lParam
      , 'ptr'
    )
}

/**
 * Deselects any selected items when the mouse is not on-top of an item.
 */
TreeViewEx_OnClick(tvex, *) {
    if tvex.Enabled {
        hitTestInfo := tvex.HitTest()
        if !hitTestInfo || !hitTestInfo.hItem || !hitTestInfo.OnItemGeneral {
            tvex.Select(0)
        }
    }
}

/**
 * A {@link Container} CallbackValue function for the property "Hwnd".
 */
TreeViewEx_CallbackValue_Hwnd(value) {
    return value.Hwnd
}

/**
 * A {@link Container} CallbackValue function for the property "Handle".
 */
TreeViewEx_CallbackValue_Handle(value) {
    return value.Handle
}

/**
 * A {@link Container} CallbackValue function for the property "Code".
 */
TreeViewEx_CallbackValue_Code(value) {
    return value.Code
}

/**
 * A {@link Container} CallbackValue function for the property "Name".
 */
TreeViewEx_CallbackValue_Name(value) {
    return value.Name
}

/**
 * Returns an array of {@link TreeViewEx_Size} objects, each representing the text extent of a
 * non-visible space character. The objects have an additional property added to them "ord", which
 * is the integer your code can pass to `Chr` to get the space character.
 *
 * The characters evaluated by this function are 0x2000 - 0x200F.
 *
 * @param {Integer} Context - Either the handle to the window which will be used to obtain a
 * device context, or a handle to the device context to use.
 * @param {Boolean} [ContextIsHwnd = true] - If true, `Context` is a window handle. If false,
 * `Context` is a handle to a device context.
 * @param {Boolean} [UniqueWidth = true] - If true, only the first character with a given
 * text extent will be represented in the container; all others are skipped.
 * @param {Boolean} [NonzeroWidth = true] - If true, zero-width characters are skipped.
 * @returns {Container} - A container with {@link TreeViewEx_Size} objects with an extra "ord" property
 * specifying the character associated with the object.
 */
TreeViewEx_GetSpaceExtentList(Context, ContextIsHwnd := true, UniqueWidth := true, NonzeroWidth := true) {
    local c := Container.CbNumber((value) => value.W)
    , i := TVEX_SPACE_CHAR_START - 1
    , str, sz
    if ContextIsHwnd {
        context := TreeViewEx_SelectFontIntoDc(Context)
        hdc := context.hdc
    } else {
        hdc := Context
    }
    if UniqueWidth {
        sz := TreeViewEx_Size()
        loop TVEX_SPACE_CHAR_END - i {
            str := Chr(++i)
            if DllCall(
                g_gdi32_GetTextExtentPoint32W
                , 'Ptr', hdc
                , 'Ptr', StrPtr(str)
                , 'Int', StrLen(str)
                , 'Ptr', sz
                , 'Int'
            ) {
                if sz.W || !NonzeroWidth {
                    if c.InsertIfAbsent(sz) {
                        sz.ord := i
                        sz := TreeViewEx_Size()
                    }
                }
            } else {
                if ContextIsHwnd {
                    context()
                }
                throw OSError()
            }
        }
    } else {
        loop TVEX_SPACE_CHAR_END - i {
            str := Chr(++i)
            sz := TreeViewEx_Size()
            if DllCall(
                g_gdi32_GetTextExtentPoint32W
                , 'Ptr', hdc
                , 'Ptr', StrPtr(str)
                , 'Int', StrLen(str)
                , 'Ptr', sz
                , 'Int'
            ) {
                if sz.W || !NonzeroWidth {
                    sz.ord := i
                    c.Push(sz)
                }
            } else {
                if ContextIsHwnd {
                    context()
                }
                throw OSError()
            }
        }
    }
    str := '...'
    sz := TreeViewEx_Size()
    if DllCall(
        g_gdi32_GetTextExtentPoint32W
        , 'Ptr', hdc
        , 'Ptr', StrPtr(str)
        , 'Int', StrLen(str)
        , 'Ptr', sz
        , 'Int'
    ) {
        c.Ellipses := sz
    } else {
        if ContextIsHwnd {
            context()
        }
        throw OSError()
    }
    str := '"'
    sz := TreeViewEx_Size()
    if DllCall(
        g_gdi32_GetTextExtentPoint32W
        , 'Ptr', hdc
        , 'Ptr', StrPtr(str)
        , 'Int', StrLen(str)
        , 'Ptr', sz
        , 'Int'
    ) {
        c.Quote := sz
    } else {
        if ContextIsHwnd {
            context()
        }
        throw OSError()
    }
    if ContextIsHwnd {
        context()
    }
    return c
}

/**
 * @description - Converts a string path to an object reference. The object at the input path must
 * exist in the global scope.
 * @param {String} Str - The object path.
 * @param {Object} [InitialObj] - If set, the object path will be parsed as a property / item of
 * this object.
 * @returns {Object} - The object reference.
 * @example
 *
 *  Obj := {
 *      Prop1: [1, 2, Map(
 *              'key1', 'value1',
 *              'key2', {prop2: 2, prop3: [3, 4]}
 *          )
 *      ]
 *  }
 *  Path := 'obj.prop1[3]["key2"].prop3'
 *  ObjReference := GetObjectFromString(Path)
 *  OutputDebug(ObjReference[2]) ; 4
 * @
 * This is compatible with class references.
 * @example
 *
 *  class Test {
 *      class NestedClass {
 *          InstanceProp {
 *              Get{
 *                  return ['Val1', { Prop: 'Hello, world!' }]
 *              }
 *          }
 *      }
 *  }
 *  Path := 'Test.NestedClass.Prototype.InstanceProp[2]'
 *  Obj := GetObjectFromString(Path)
 *  OutputDebug(Obj.Prop) ; Hello, world!
 * @
 * Using an initial object.
 * @example
 *  Obj := {
 *      Prop1: [1, 2, Map(
 *              'key1', 'value1',
 *              'key2', {prop2: 2, prop3: [3, 4]}
 *          )
 *      ]
 *  }
 *  Path := '[3]["key2"].prop3'
 *  Arr := Obj.Prop1
 *  InnerArr := GetObjectFromString(Path, Arr)
 *  OutputDebug(InnerArr[2]) ; 4
 * @
 *
 */
TreeViewEx_GetObjectFromString(Str, InitialObj?) {
    static Pattern := 'S)(?<=\.)[\w_\d]+(?COnProp)|\[\s*\K-?\d+(?COnIndex)|\[\s*(?<quote>[`'"])(?<key>.*?)(?<!``)(?:````)*\g{quote}(?COnKey)'
    if IsSet(InitialObj) {
        NewObj := InitialObj
        Pos := 1
        if SubStr(Str, 1, 1) !== '.' {
            Str := '.' Str
        }
    } else {
        RegExMatch(Str, '^[\w\d_]+', &InitialSegment)
        Pos := InitialSegment.Pos + InitialSegment.Len
        NewObj := %InitialSegment[0]%
    }
    while RegExMatch(Str, Pattern, &Match, Pos)
        Pos := Match.Pos + Match.Len

    return NewObj

    OnProp(Match, *) {
        NewObj := NewObj.%Match[0]%
    }
    OnIndex(Match, *) {
        NewObj := NewObj[Number(Match[0])]
    }
    OnKey(Match, *) {
        NewObj := NewObj[Match['key']]
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class NmTreeView extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol                Offset                 Padding
        A_PtrSize + ; HWND         hwndFrom              0
        A_PtrSize + ; UINT_PTR     idFrom                0 + A_PtrSize * 1
        A_PtrSize + ; UINT         code                  0 + A_PtrSize * 2      +4 on x64 only
        A_PtrSize + ; UINT         action                0 + A_PtrSize * 3      +4 on x64 only
        A_PtrSize + ; UINT         mask_old              0 + A_PtrSize * 4      +4 on x64 only
        A_PtrSize + ; HTREEITEM    hItem_old             0 + A_PtrSize * 5
        4 +         ; UINT         state_old             0 + A_PtrSize * 6
        4 +         ; UINT         stateMask_old         4 + A_PtrSize * 6
        A_PtrSize + ; LPWSTR       pszText_old           8 + A_PtrSize * 6
        4 +         ; int          cchTextMax_old        8 + A_PtrSize * 7
        4 +         ; int          iImage_old            12 + A_PtrSize * 7
        4 +         ; int          iSelectedImage_old    16 + A_PtrSize * 7
        4 +         ; int          cChildren_old         20 + A_PtrSize * 7
        A_PtrSize + ; LPARAM       lParam_old            24 + A_PtrSize * 7
        A_PtrSize + ; UINT         mask_new              24 + A_PtrSize * 8     +4 on x64 only
        A_PtrSize + ; HTREEITEM    hItem_new             24 + A_PtrSize * 9
        4 +         ; UINT         state_new             24 + A_PtrSize * 10
        4 +         ; UINT         stateMask_new         28 + A_PtrSize * 10
        A_PtrSize + ; LPWSTR       pszText_new           32 + A_PtrSize * 10
        4 +         ; int          cchTextMax_new        32 + A_PtrSize * 11
        4 +         ; int          iImage_new            36 + A_PtrSize * 11
        4 +         ; int          iSelectedImage_new    40 + A_PtrSize * 11
        4 +         ; int          cChildren_new         44 + A_PtrSize * 11
        A_PtrSize + ; LPARAM       lParam_new            48 + A_PtrSize * 11
        4 +         ; LONG         x                     48 + A_PtrSize * 12
        4           ; LONG         y                     52 + A_PtrSize * 12
        proto.offset_hwndFrom            := 0
        proto.offset_idFrom              := 0 + A_PtrSize * 1
        proto.offset_code                := 0 + A_PtrSize * 2
        proto.offset_action              := 0 + A_PtrSize * 3
        proto.offset_mask_old            := 0 + A_PtrSize * 4
        proto.offset_hItem_old           := 0 + A_PtrSize * 5
        proto.offset_state_old           := 0 + A_PtrSize * 6
        proto.offset_stateMask_old       := 4 + A_PtrSize * 6
        proto.offset_pszText_old         := 8 + A_PtrSize * 6
        proto.offset_cchTextMax_old      := 8 + A_PtrSize * 7
        proto.offset_iImage_old          := 12 + A_PtrSize * 7
        proto.offset_iSelectedImage_old  := 16 + A_PtrSize * 7
        proto.offset_cChildren_old       := 20 + A_PtrSize * 7
        proto.offset_lParam_old          := 24 + A_PtrSize * 7
        proto.offset_mask_new            := 24 + A_PtrSize * 8
        proto.offset_hItem_new           := 24 + A_PtrSize * 9
        proto.offset_state_new           := 24 + A_PtrSize * 10
        proto.offset_stateMask_new       := 28 + A_PtrSize * 10
        proto.offset_pszText_new         := 32 + A_PtrSize * 10
        proto.offset_cchTextMax_new      := 32 + A_PtrSize * 11
        proto.offset_iImage_new          := 36 + A_PtrSize * 11
        proto.offset_iSelectedImage_new  := 40 + A_PtrSize * 11
        proto.offset_cChildren_new       := 44 + A_PtrSize * 11
        proto.offset_lParam_new          := 48 + A_PtrSize * 11
        proto.offset_x                   := 48 + A_PtrSize * 12
        proto.offset_y                   := 52 + A_PtrSize * 12

        proto.__pszText_old := proto.__pszText_new := ''
    }
    SetTextBuffer(Suffix, Bytes := TVEX_DEFAULT_TEXT_MAX) {
        this.__pszText%Suffix% := Buffer(Bytes)
        this.cchTextMax%Suffix% := Floor(Bytes / 2)
        NumPut('ptr', this.__pszText%Suffix%.Ptr, this.Buffer, this.offset_pszText%Suffix%)
    }

    hwndFrom {
        Get => NumGet(this.Buffer, this.offset_hwndFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwndFrom)
        }
    }
    idFrom {
        Get => NumGet(this.Buffer, this.offset_idFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_idFrom)
        }
    }
    code {
        Get => NumGet(this.Buffer, this.offset_code, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_code)
        }
    }
    code_int {
        Get => NumGet(this.Buffer, this.offset_code, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_code)
        }
    }
    action {
        Get => NumGet(this.Buffer, this.offset_action, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_action)
        }
    }
    mask_old {
        Get => NumGet(this.Buffer, this.offset_mask_old, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_mask_old)
        }
    }
    hItem_old {
        Get => NumGet(this.Buffer, this.offset_hItem_old, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hItem_old)
        }
    }
    state_old {
        Get => NumGet(this.Buffer, this.offset_state_old, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_state_old)
        }
    }
    stateMask_old {
        Get => NumGet(this.Buffer, this.offset_stateMask_old, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_stateMask_old)
        }
    }
    pszText_old {
        Get {
            Value := NumGet(this.Buffer, this.offset_pszText_old, 'ptr')
            if Value > 0 {
                return StrGet(Value, TVEX_DEFAULT_ENCODING)
            } else {
                return Value
            }
        }
        Set {
            if Value == LPSTR_TEXTCALLBACKW {
                NumPut('ptr', Value, this.Buffer, this.offset_pszText_old)
            } else {
                if ptr := NumGet(this.Buffer, this.offset_pszText_old, 'ptr') {
                    if this.__pszText_old {
                        bytes := StrPut(Value, TVEX_DEFAULT_ENCODING)
                        if bytes > this.__pszText_old.Size {
                            this.__pszText_old.Size := bytes
                            ptr := this.__pszText_old.Ptr
                            NumPut('ptr', ptr, this.Buffer, this.offset_pszText_old)
                        }
                    }
                } else {
                    this.__pszText_old := Buffer(StrPut(Value, TVEX_DEFAULT_ENCODING))
                    ptr := this.__pszText_old.Ptr
                    NumPut('ptr', ptr, this.Buffer, this.offset_pszText_old)
                }
                if chars := this.cchTextMax_old {
                    StrPut(SubStr(Value, 1, chars - 1), ptr, TVEX_DEFAULT_ENCODING)
                } else {
                    StrPut(Value, ptr, TVEX_DEFAULT_ENCODING)
                }
            }
        }
    }
    cchTextMax_old {
        Get => NumGet(this.Buffer, this.offset_cchTextMax_old, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cchTextMax_old)
        }
    }
    iImage_old {
        Get => NumGet(this.Buffer, this.offset_iImage_old, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iImage_old)
        }
    }
    iSelectedImage_old {
        Get => NumGet(this.Buffer, this.offset_iSelectedImage_old, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iSelectedImage_old)
        }
    }
    cChildren_old {
        Get => NumGet(this.Buffer, this.offset_cChildren_old, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cChildren_old)
        }
    }
    lParam_old {
        Get => NumGet(this.Buffer, this.offset_lParam_old, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lParam_old)
        }
    }
    mask_new {
        Get => NumGet(this.Buffer, this.offset_mask_new, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_mask_new)
        }
    }
    hItem_new {
        Get => NumGet(this.Buffer, this.offset_hItem_new, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hItem_new)
        }
    }
    state_new {
        Get => NumGet(this.Buffer, this.offset_state_new, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_state_new)
        }
    }
    stateMask_new {
        Get => NumGet(this.Buffer, this.offset_stateMask_new, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_stateMask_new)
        }
    }
    pszText_new {
        Get {
            Value := NumGet(this.Buffer, this.offset_pszText_new, 'ptr')
            if Value > 0 {
                return StrGet(Value, TVEX_DEFAULT_ENCODING)
            } else {
                return Value
            }
        }
        Set {
            if Value == LPSTR_TEXTCALLBACKW {
                NumPut('ptr', Value, this.Buffer, this.offset_pszText_new)
            } else {
                if ptr := NumGet(this.Buffer, this.offset_pszText_new, 'ptr') {
                    if this.__pszText_new {
                        bytes := StrPut(Value, TVEX_DEFAULT_ENCODING)
                        if bytes > this.__pszText_new.Size {
                            this.__pszText_new.Size := bytes
                            ptr := this.__pszText_new.Ptr
                            NumPut('ptr', ptr, this.Buffer, this.offset_pszText_new)
                        }
                    }
                } else {
                    this.__pszText_new := Buffer(StrPut(Value, TVEX_DEFAULT_ENCODING))
                    ptr := this.__pszText_new.Ptr
                    NumPut('ptr', ptr, this.Buffer, this.offset_pszText_new)
                }
                if chars := this.cchTextMax {
                    StrPut(SubStr(Value, 1, chars - 1), ptr, TVEX_DEFAULT_ENCODING)
                } else {
                    StrPut(Value, ptr, TVEX_DEFAULT_ENCODING)
                }
            }
        }
    }
    cchTextMax_new {
        Get => NumGet(this.Buffer, this.offset_cchTextMax_new, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cchTextMax_new)
        }
    }
    iImage_new {
        Get => NumGet(this.Buffer, this.offset_iImage_new, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iImage_new)
        }
    }
    iSelectedImage_new {
        Get => NumGet(this.Buffer, this.offset_iSelectedImage_new, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iSelectedImage_new)
        }
    }
    cChildren_new {
        Get => NumGet(this.Buffer, this.offset_cChildren_new, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cChildren_new)
        }
    }
    lParam_new {
        Get => NumGet(this.Buffer, this.offset_lParam_new, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lParam_new)
        }
    }
    x {
        Get => NumGet(this.Buffer, this.offset_x, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_x)
        }
    }
    y {
        Get => NumGet(this.Buffer, this.offset_y, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_y)
        }
    }
}

/**
 * Used to handle NM_CUSTOMDRAW notifications.
 */
class NmTvCustomDraw extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol         Offset                Padding
        A_PtrSize + ; HWND         hwndFrom       0
        A_PtrSize + ; UINT_PTR     idFrom         0 + A_PtrSize * 1
        A_PtrSize + ; UINT         code           0 + A_PtrSize * 2     +4 on x64 only
        A_PtrSize + ; DWORD        dwDrawStage    0 + A_PtrSize * 3     +4 on x64 only
        A_PtrSize + ; HDC          hdc            0 + A_PtrSize * 4
        4 +         ; INT          left           0 + A_PtrSize * 5
        4 +         ; INT          top            4 + A_PtrSize * 5
        4 +         ; INT          right          8 + A_PtrSize * 5
        4 +         ; INT          bottom         12 + A_PtrSize * 5
        A_PtrSize + ; DWORD_PTR    dwItemSpec     16 + A_PtrSize * 5
        A_PtrSize + ; UINT         uItemState     16 + A_PtrSize * 6    +4 on x64 only
        A_PtrSize + ; LPARAM       lItemlParam    16 + A_PtrSize * 7
        4 +         ; COLORREF     clrText        16 + A_PtrSize * 8
        4 +         ; COLORREF     clrTextBk      20 + A_PtrSize * 8
        A_PtrSize   ; int          iLevel         24 + A_PtrSize * 8    +4 on x64 only
        proto.offset_hwndFrom     := 0
        proto.offset_idFrom       := 0 + A_PtrSize * 1 8
        proto.offset_code         := 0 + A_PtrSize * 2 16
        proto.offset_dwDrawStage  := 0 + A_PtrSize * 3 24
        proto.offset_hdc          := 0 + A_PtrSize * 4 32
        proto.offset_left         := 0 + A_PtrSize * 5 40
        proto.offset_top          := 4 + A_PtrSize * 5 44
        proto.offset_right        := 8 + A_PtrSize * 5 48
        proto.offset_bottom       := 12 + A_PtrSize * 5 52
        proto.offset_dwItemSpec   := 16 + A_PtrSize * 5 56
        proto.offset_uItemState   := 16 + A_PtrSize * 6 64
        proto.offset_lItemlParam  := 16 + A_PtrSize * 7 72
        proto.offset_clrText      := 16 + A_PtrSize * 8 80
        proto.offset_clrTextBk    := 20 + A_PtrSize * 8 84
        proto.offset_iLevel       := 24 + A_PtrSize * 8 88
    }
    hwndFrom {
        Get => NumGet(this.Buffer, this.offset_hwndFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwndFrom)
        }
    }
    idFrom {
        Get => NumGet(this.Buffer, this.offset_idFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_idFrom)
        }
    }
    code {
        Get => NumGet(this.Buffer, this.offset_code, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_code)
        }
    }
    dwDrawStage {
        Get => NumGet(this.Buffer, this.offset_dwDrawStage, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwDrawStage)
        }
    }
    hdc {
        Get => NumGet(this.Buffer, this.offset_hdc, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hdc)
        }
    }
    left {
        Get => NumGet(this.Buffer, this.offset_left, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_left)
        }
    }
    top {
        Get => NumGet(this.Buffer, this.offset_top, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_top)
        }
    }
    right {
        Get => NumGet(this.Buffer, this.offset_right, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_right)
        }
    }
    bottom {
        Get => NumGet(this.Buffer, this.offset_bottom, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_bottom)
        }
    }
    dwItemSpec {
        Get => NumGet(this.Buffer, this.offset_dwItemSpec, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_dwItemSpec)
        }
    }
    uItemState {
        Get => NumGet(this.Buffer, this.offset_uItemState, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_uItemState)
        }
    }
    lItemlParam {
        Get => NumGet(this.Buffer, this.offset_lItemlParam, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lItemlParam)
        }
    }
    clrText {
        Get => NumGet(this.Buffer, this.offset_clrText, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_clrText)
        }
    }
    clrTextBk {
        Get => NumGet(this.Buffer, this.offset_clrTextBk, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_clrTextBk)
        }
    }
    iLevel {
        Get => NumGet(this.Buffer, this.offset_iLevel, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iLevel)
        }
    }
    Ptr => this.Buffer.Ptr
    Size => this.Buffer.Size
}

TreeViewEx_HandlerBeginLabelEdit_Node_C(Ctrl, _tvDispInfoEx) {
    if _tvDispInfoEx.pszText {
        if node := Ctrl.GetNode_C(_tvDispInfoEx.hItem) {
            return node.OnBeginLabelEdit(_tvDispInfoEx)
        }
    }
}
TreeViewEx_HandlerDeleteItem_Node_C(Ctrl, _nmTreeView) {
    return Ctrl.GetNode_C(_nmTreeView.hItem_old).OnDeleteItem(_nmTreeView)
}
TreeViewEx_HandlerEndLabelEdit_Node_C(Ctrl, _tvDispInfoEx) {
    if _tvDispInfoEx.pszText {
        if node := Ctrl.GetNode_C(_tvDispInfoEx.hItem) {
            return node.OnEndLabelEdit(_tvDispInfoEx)
        }
    }
}
TreeViewEx_HandlerGetDispInfo_Node_C(Ctrl, _tvDispInfoEx) {
    if node := Ctrl.GetNode_C(_tvDispInfoEx.hItem) {
        if _tvDispInfoEx.mask & TVIF_TEXT {
            node.OnGetInfoName(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_IMAGE {
            node.OnGetInfoImage(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_SELECTEDIMAGE {
            node.OnGetInfoSelectedImage(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_CHILDREN {
            node.OnGetInfoChildren(_tvDispInfoEx)
        }
    }
}
TreeViewEx_HandlerGetInfoTip_Node_C(Ctrl, _tvGetInfoTip) {
    return Ctrl.GetNode_C(_tvGetInfoTip.hItem).OnGetInfoTip(_tvGetInfoTip)
}
TreeViewEx_HandlerItemChanged_Node_C(Ctrl, _tvItemChanged) {
    return Ctrl.GetNode_C(_tvItemChanged.hItem).OnItemChanged(_tvItemChanged)
}
TreeViewEx_HandlerItemChanging_Node_C(Ctrl, _tvItemChanged) {
    return Ctrl.GetNode_C(_tvItemChanged.hItem).OnItemChanging(_tvItemChanged)
}
TreeViewEx_HandlerItemExpanded_Node_C(Ctrl, _nmTreeView) {
    return Ctrl.GetNode_C(_nmTreeView.hItem_new).OnItemExpanded(_nmTreeView)
}
TreeViewEx_HandlerItemExpanding_Node_C(Ctrl, _nmTreeView) {
    return Ctrl.GetNode_C(_nmTreeView.hItem_new).OnItemExpanding(_nmTreeView)
}
TreeViewEx_HandlerSetDispInfo_Node_C(Ctrl, _tvDispInfoEx) {
    if node := Ctrl.GetNode_C(_tvDispInfoEx.hItem) {
        if _tvDispInfoEx.mask & TVIF_TEXT {
            node.OnSetInfoName(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_IMAGE {
            node.OnSetInfoImage(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_SELECTEDIMAGE {
            node.OnSetInfoSelectedImage(_tvDispInfoEx)
        }
    }
}
TreeViewEx_HandlerSingleExpand_Node_C(Ctrl, _nmTreeView) {
    return Ctrl.GetNode_C(_nmTreeView.hItem_new).OnSingleExpand(_nmTreeView)
}

TreeViewEx_HandlerBeginLabelEdit_Node_Ptr(Ctrl, _tvDispInfoEx) {
    if _tvDispInfoEx.lParam {
        if _tvDispInfoEx.pszText {
            return ObjFromPtrAddRef(_tvDispInfoEx.lParam).OnBeginLabelEdit(_tvDispInfoEx)
        }
    } else {
        return g_TreeViewEx_Node.OnBeginLabelEdit(_tvDispInfoEx)
    }
}
TreeViewEx_HandlerDeleteItem_Node_Ptr(Ctrl, _nmTreeView) {
    if _nmTreeView.lParam_old {
        return ObjFromPtrAddRef(_nmTreeView.lParam_old).OnDeleteItem(_nmTreeView)
    } else {
        g_TreeViewEx_Node.OnDeleteItem(_nmTreeView)
    }
}
TreeViewEx_HandlerEndLabelEdit_Node_Ptr(Ctrl, _tvDispInfoEx) {
    if _tvDispInfoEx.pszText {
        if _tvDispInfoEx.lParam {
            return ObjFromPtrAddRef(_tvDispInfoEx.lParam).OnEndLabelEdit(_tvDispInfoEx)
        } else {
            g_TreeViewEx_Node.OnEndLabelEdit(_tvDispInfoEx)
        }
    }
}
TreeViewEx_HandlerGetDispInfo_Node_Ptr(Ctrl, _tvDispInfoEx) {
    node := _tvDispInfoEx.lParam ? ObjFromPtrAddRef(_tvDispInfoEx.lParam) : g_TreeViewEx_Node
    if _tvDispInfoEx.mask & TVIF_TEXT {
        node.OnGetInfoName(_tvDispInfoEx)
    }
    if _tvDispInfoEx.mask & TVIF_IMAGE {
        node.OnGetInfoImage(_tvDispInfoEx)
    }
    if _tvDispInfoEx.mask & TVIF_SELECTEDIMAGE {
        node.OnGetInfoSelectedImage(_tvDispInfoEx)
    }
    if _tvDispInfoEx.mask & TVIF_CHILDREN {
        node.OnGetInfoChildren(_tvDispInfoEx)
    }
}
TreeViewEx_HandlerGetInfoTip_Node_Ptr(Ctrl, _tvGetInfoTip) {
    if _tvGetInfoTip.lParam {
        return ObjFromPtrAddRef(_tvGetInfoTip.lParam).OnGetInfoTip(_tvGetInfoTip)
    } else {
        g_TreeViewEx_Node.OnGetInfoTip(_tvGetInfoTip)
    }
}
TreeViewEx_HandlerItemChanged_Node_Ptr(Ctrl, _tvItemChanged) {
    if _tvItemChanged.lParam {
        return ObjFromPtrAddRef(_tvItemChanged.lParam).OnItemChanged(_tvItemChanged)
    } else {
        g_TreeViewEx_Node.OnItemChanged(_tvItemChanged)
    }
}
TreeViewEx_HandlerItemChanging_Node_Ptr(Ctrl, _tvItemChanged) {
    if _tvItemChanged.lParam {
        return ObjFromPtrAddRef(_tvItemChanged.lParam).OnItemChanging(_tvItemChanged)
    } else {
        g_TreeViewEx_Node.OnItemChanging(_tvItemChanged)
    }
}
TreeViewEx_HandlerItemExpanded_Node_Ptr(Ctrl, _nmTreeView) {
    if _nmTreeView.lParam_new {
        return ObjFromPtrAddRef(_nmTreeView.lParam_new).OnItemExpanded(_nmTreeView)
    } else {
        g_TreeViewEx_Node.OnItemExpanded(_nmTreeView.action, _nmTreeView)
    }
}
TreeViewEx_HandlerItemExpanding_Node_Ptr(Ctrl, _nmTreeView) {
    if _nmTreeView.lParam_new {
        return ObjFromPtrAddRef(_nmTreeView.lParam_new).OnItemExpanding(_nmTreeView)
    } else {
        g_TreeViewEx_Node.OnItemExpanding(_nmTreeView.action, _nmTreeView)
    }
}
TreeViewEx_HandlerSetDispInfo_Node_Ptr(Ctrl, _tvDispInfoEx) {
    node := _tvDispInfoEx.lParam ? ObjFromPtrAddRef(_tvDispInfoEx.lParam) : g_TreeViewEx_Node
    if _tvDispInfoEx.mask & TVIF_TEXT {
        node.OnSetInfoName(_tvDispInfoEx)
    }
    if _tvDispInfoEx.mask & TVIF_IMAGE {
        node.OnSetInfoImage(_tvDispInfoEx)
    }
    if _tvDispInfoEx.mask & TVIF_SELECTEDIMAGE {
        node.OnSetInfoSelectedImage(_tvDispInfoEx)
    }
}
TreeViewEx_HandlerSingleExpand_Node_Ptr(Ctrl, _nmTreeView) {
    if _nmTreeView.lParam_new {
        return ObjFromPtrAddRef(_nmTreeView.lParam_new).OnSingleExpand(_nmTreeView)
    } else {
        g_TreeViewEx_Node.OnSingleExpand(_nmTreeView)
    }
}


TreeViewEx_HandlerBeginLabelEdit_Node(Ctrl, _tvDispInfoEx) {
    if _tvDispInfoEx.pszText {
        return Ctrl.GetNode(_tvDispInfoEx.hItem).OnBeginLabelEdit(_tvDispInfoEx)
    }
}
TreeViewEx_HandlerDeleteItem_Node(Ctrl, _nmTreeView) {
    return Ctrl.GetNode(_nmTreeView.hItem_old).OnDeleteItem(_nmTreeView)
}
TreeViewEx_HandlerEndLabelEdit_Node(Ctrl, _tvDispInfoEx) {
    if _tvDispInfoEx.pszText {
        return Ctrl.GetNode(_tvDispInfoEx.hItem).OnEndLabelEdit(_tvDispInfoEx)
    }
}
TreeViewEx_HandlerGetDispInfo_Node(Ctrl, _tvDispInfoEx) {
    if node := Ctrl.GetNode(_tvDispInfoEx.hItem) {
        if _tvDispInfoEx.mask & TVIF_TEXT {
            node.OnGetInfoName(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_IMAGE {
            node.OnGetInfoImage(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_SELECTEDIMAGE {
            node.OnGetInfoSelectedImage(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_CHILDREN {
            node.OnGetInfoChildren(_tvDispInfoEx)
        }
    }
}
TreeViewEx_HandlerGetInfoTip_Node(Ctrl, _tvGetInfoTip) {
    return Ctrl.GetNode(_tvGetInfoTip.hItem).OnGetInfoTip(_tvGetInfoTip)
}
TreeViewEx_HandlerItemChanged_Node(Ctrl, _tvItemChanged) {
    return Ctrl.GetNode(_tvItemChanged.hItem).OnItemChanged(_tvItemChanged)
}
TreeViewEx_HandlerItemChanging_Node(Ctrl, _tvItemChanged) {
    return Ctrl.GetNode(_tvItemChanged.hItem).OnItemChanging(_tvItemChanged)
}
TreeViewEx_HandlerItemExpanded_Node(Ctrl, _nmTreeView) {
    return Ctrl.GetNode(_nmTreeView.hItem_new).OnItemExpanded(_nmTreeView)
}
TreeViewEx_HandlerItemExpanding_Node(Ctrl, _nmTreeView) {
    return Ctrl.GetNode(_nmTreeView.hItem_new).OnItemExpanding(_nmTreeView)
}
TreeViewEx_HandlerSetDispInfo_Node(Ctrl, _tvDispInfoEx) {
    if node := Ctrl.GetNode(_tvDispInfoEx.hItem) {
        if _tvDispInfoEx.mask & TVIF_TEXT {
            node.OnSetInfoName(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_IMAGE {
            node.OnSetInfoImage(_tvDispInfoEx)
        }
        if _tvDispInfoEx.mask & TVIF_SELECTEDIMAGE {
            node.OnSetInfoSelectedImage(_tvDispInfoEx)
        }
    }
}
TreeViewEx_HandlerSingleExpand_Node(Ctrl, _nmTreeView) {
    return Ctrl.GetNode(_nmTreeView.hItem_new).OnSingleExpand(_nmTreeView)
}

class TreeViewEx_LabelEditDestroyNotification {
    static __New() {
        this.DeleteProp('__New')
        this.Collection := TreeViewExCollection_LabelEditDestroyNotification()
    }
    static Add(LabelEditDestroyNotificationObj) {
        if !this.Collection.InsertIfAbsent(LabelEditDestroyNotificationObj) {
            throw Error('The handle already exists in the collection.', , LabelEditDestroyNotificationObj.Handle)
        }
    }
    static Process(Handle) {
        this.Collection.Remove(Handle, &LabelEditDestroyNotificationObj)
        LabelEditDestroyNotificationObj.WindowSubclass.Dispose()
        LabelEditDestroyNotificationObj.Callback.Call()
    }
    /**
     * Sets a callback that is called when the label edit control is destroyed. Use this to perform
     * any other actions related to editing the label of a TreeViewEx item, such as disabling hotkeys.
     *
     * @param {Integer} Handle - The handle to the label edit control. This can be obtained with
     * {@link TreeViewEx.Prototype.GetEditControl}.
     *
     * @param {*} Callback - A `Func` or callable object to call when the edit control is destroyed.
     */
    __New(Handle, Callback) {
        this.Handle := Handle
        this.Callback := Callback
        TreeViewEx_LabelEditDestroyNotification.Add(this)
        this.WindowSubclass := TreeViewEx_WindowSubclass(TreeViewEx_LabelEditSubclassProc, Handle)
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * @classdesc - A wrapper around the LOGFONT structure.
 * {@link https://learn.microsoft.com/en-us/windows/win32/api/dimm/ns-dimm-logfontw}
 */
class TreeViewEx_LogFont extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        Proto := this.Prototype
        Proto.Encoding := TVEX_DEFAULT_ENCODING
        /**
         * The structure's size.
         * @memberof Logfont
         * @instance
         */
        Proto.cbSizeInstance :=
        4 + ; LONG  lfHeight                    0
        4 + ; LONG  lfWidth                     4
        4 + ; LONG  lfEscapement                8
        4 + ; LONG  lfOrientation               12
        4 + ; LONG  lfWeight                    16
        1 + ; BYTE  lfItalic                    20
        1 + ; BYTE  lfUnderline                 21
        1 + ; BYTE  lfStrikeOut                 22
        1 + ; BYTE  lfCharSet                   23
        1 + ; BYTE  lfOutPrecision              24
        1 + ; BYTE  lfClipPrecision             25
        1 + ; BYTE  lfQuality                   26
        1 + ; BYTE  lfPitchAndFamily            27
        64  ; WCHAR lfFaceName[LF_FACESIZE]     28
        Proto.Handle := Proto.Hwnd := 0
    }
    /**
     * @param {Integer} [Hwnd = 0] - The window handle to associate with the {@link TreeViewEx_LogFont}
     * object. If `Hwnd` is set with a nonzero value, {@link TreeViewEx_LogFont.Prototype.Call} is
     * called to initialize this object's properties with values obtained from the window. If `Hwnd`
     * is zero, the value of each property is 0.
     *
     * @param {Object} [Options] - An object with zero or more options as property : value pairs.
     * The value of any instance property can be assigned using the `Options` object.
     *
     * @param {Integer} [Options.CharSet] - The value to assign to CharSet.
     * @param {Integer} [Options.ClipPrecision] - The value to assign to ClipPrecision.
     * @param {Integer} [Options.Escapement] - The value to assign to Escapement.
     * @param {String} [Options.FaceName] - The value to assign to FaceName.
     * @param {Integer} [Options.Family] - The value to assign to Family.
     * @param {Integer} [Options.FontSize] - The value to assign to FontSize.
     * @param {Integer} [Options.Height] - The value to assign to Height.
     * @param {Integer} [Options.Italic] - The value to assign to Italic.
     * @param {Integer} [Options.Orientation] - The value to assign to Orientation.
     * @param {Integer} [Options.OutPrecision] - The value to assign to OutPrecision.
     * @param {Integer} [Options.Pitch] - The value to assign to Pitch.
     * @param {Integer} [Options.Quality] - The value to assign to Quality.
     * @param {Integer} [Options.StrikeOut] - The value to assign to StrikeOut.
     * @param {Integer} [Options.Underline] - The value to assign to Underline.
     * @param {Integer} [Options.Weight] - The value to assign to Weight.
     * @param {Integer} [Options.Width] - The value to assign to Width.
     *
     * @return {Logfont}
     */
    __New(Hwnd := 0, Options?) {
        /**
         * A reference to the buffer object which is used as the LOGFONT structure.
         * @memberof Logfont
         * @instance
         */
        this.Buffer := Buffer(this.cbSizeInstance, 0)
        /**
         * The handle to the window associated with this object, if any.
         * @memberof Logfont
         * @instance
         */
        if this.Hwnd := Hwnd {
            this()
        }
        if IsSet(Options) {
            for opt in TreeViewEx_LogFont.Options.Number {
                if HasProp(Options, opt) && IsNumber(options.%opt%) {
                    this.%opt% := options.%opt%
                }
            }
            for opt in TreeViewEx_LogFont.Options.String {
                if HasProp(Options, opt) && StrLen(options.%opt%) {
                    this.%opt% := options.%opt%
                }
            }
            this.Apply()
        }
    }
    /**
     * @description - Calls `CreateFontIndirectW` then sends WM_SETFONT to the window associated
     * with this `Logfont` object.
     * @param {Boolean} [Redraw = true] - The value to pass to the `lParam` parameter when sending
     * WM_SETFONT. If true, the control redraws itself.
     */
    Apply(Redraw := true) {
        hFontOld := SendMessage(WM_GETFONT,,, this.Hwnd)
        Flag := this.Handle = hFontOld
        this.Handle := DllCall(g_gdi32_CreateFontIndirectW, 'ptr', this, 'ptr')
        SendMessage(WM_SETFONT, this.Handle, Redraw, this.Hwnd)
        if Flag {
            DllCall(g_gdi32_DeleteObject, 'ptr', hFontOld, 'int')
        }
    }
    /**
     * @description - Sends WM_GETFONT to the window associated with this `Logfont` object, updating
     * this object's properties with the values obtained from the window.
     * @throws {OSError} - Failed to get font object.
     */
    Call(*) {
        hFont := SendMessage(WM_GETFONT,,, this.Hwnd)
        if !DllCall(g_gdi32_GetObjectW, 'ptr', hFont, 'int', this.Size, 'ptr', this, 'uint') {
            throw OSError()
        }
    }
    /**
     * @description - If a font object has been created by this `Logfont` object, the font object
     * is deleted.
     */
    Dispose() {
        if this.Handle {
            DllCall(g_gdi32_DeleteObject, 'ptr', this.Handle)
            this.Handle := 0
        }
    }
    /**
     * @description - Updates a property's value and calls `Logfont.Prototype.Apply` immediately afterward.
     * @param {String} Name - The name of the property.
     * @param {String|Number} Value - The value.
     */
    Set(Name, Value) {
        this.%Name% := Value
        this.Apply()
    }
    __Delete() {
        if this.Handle {
            DllCall(g_gdi32_DeleteObject, 'ptr', this.Handle)
            this.Handle := 0
        }
    }
    /**
     * Gets or sets the character set.
     * @memberof Logfont
     * @instance
     */
    CharSet {
        Get => NumGet(this, 23, 'uchar')
        Set => NumPut('uchar', Value, this, 23)
    }
    /**
     * Gets or sets the behavior when part of a character is clipped.
     * @memberof Logfont
     * @instance
     */
    ClipPrecision {
        Get => NumGet(this, 25, 'uchar')
        Set => NumPut('uchar', Value, this, 25)
    }
    /**
     * If this `Logfont` object is associated with a window, returns the dpi for the window.
     * @memberof Logfont
     * @instance
     */
    Dpi => this.Hwnd ? DllCall(g_user32_GetDpiForWindow, 'Ptr', this.Hwnd, 'UInt') : ''
    /**
     * Gets or sets the escapement measured in tenths of a degree.
     * @memberof Logfont
     * @instance
     */
    Escapement {
        Get => NumGet(this, 8, 'int')
        Set => NumPut('int', Value, this, 8)
    }
    /**
     * Gets or sets the font facename.
     * @memberof Logfont
     * @instance
     */
    FaceName {
        Get => StrGet(this.ptr + 28, 32, this.Encoding)
        Set => StrPut(SubStr(Value, 1, 31), this.Ptr + 28, 32, TVEX_DEFAULT_ENCODING)
    }
    /**
     * Gets or sets the font family.
     * @memberof Logfont
     * @instance
     */
    Family {
        Get => NumGet(this, 27, 'uchar') & 0xF0
        Set => NumPut('uchar', (this.Family & 0x0F) | (Value & 0xF0), this, 27)
    }
    /**
     * Gets or sets the font size. "FontSize" requires that the `Logfont` object is associated
     * with a window handle because it needs a dpi value to work with.
     * @memberof Logfont
     * @instance
     */
    FontSize {
        Get => this.Hwnd ? Round(this.Height * -72 / this.Dpi, 2) : ''
        Set => this.Height := Round(Value * this.Dpi / -72)
    }
    /**
     * Gets or sets the font height.
     * @memberof Logfont
     * @instance
     */
    Height {
        Get => NumGet(this, 0, 'int')
        Set => NumPut('int', Value, this, 0)
    }
    /**
     * Gets or sets the italic flag.
     * @memberof Logfont
     * @instance
     */
    Italic {
        Get => NumGet(this, 20, 'uchar')
        Set => NumPut('uchar', Value ? 1 : 0, this, 20)
    }
    /**
     * Gets or sets the orientation measured in tenths of degrees.
     * @memberof Logfont
     * @instance
     */
    Orientation {
        Get => NumGet(this, 12, 'int')
        Set => NumPut('int', Value, this, 12)
    }
    /**
     * Gets or sets the behavior when multiple fonts with the same name exist on the system.
     * @memberof Logfont
     * @instance
     */
    OutPrecision {
        Get => NumGet(this, 24, 'uchar')
        Set => NumPut('uchar', Value, this, 24)
    }
    /**
     * Gets or sets the pitch.
     * @memberof Logfont
     * @instance
     */
    Pitch {
        Get => NumGet(this, 27, 'uchar') & 0x0F
        Set => NumPut('uchar', (this.Pitch & 0xF0) | (Value & 0x0F), this, 27)
    }
    /**
     * Gets or sets the quality flag.
     * @memberof Logfont
     * @instance
     */
    Quality {
        Get => NumGet(this, 26, 'uchar')
        Set => NumPut('uchar', Value, this, 26)
    }
    /**
     * Gets or sets the strikeout flag.
     * @memberof Logfont
     * @instance
     */
    StrikeOut {
        Get => NumGet(this, 22, 'uchar')
        Set => NumPut('uchar', Value ? 1 : 0, this, 22)
    }
    /**
     * Gets or sets the underline flag.
     * @memberof Logfont
     * @instance
     */
    Underline {
        Get => NumGet(this, 21, 'uchar')
        Set => NumPut('uchar', Value ? 1 : 0, this, 21)
    }
    /**
     * Gets or sets the weight flag.
     * @memberof Logfont
     * @instance
     */
    Weight {
        Get => NumGet(this, 16, 'int')
        Set => NumPut('int', Value, this, 16)
    }
    /**
     * Gets or sets the width.
     * @memberof Logfont
     * @instance
     */
    Width {
        Get => NumGet(this, 4, 'int')
        Set => NumPut('int', Value, this, 4)
    }

    class Options {
        static __New() {
            this.DeleteProp('__New')
            this.Number := [
                'CharSet'
              , 'ClipPrecision'
              , 'Escapement'
              , 'Family'
              , 'FontSize'
              , 'Height'
              , 'Italic'
              , 'Orientation'
              , 'OutPrecision'
              , 'Pitch'
              , 'Quality'
              , 'StrikeOut'
              , 'Underline'
              , 'Weight'
              , 'Width'
            ]
            this.String := [ 'FaceName' ]
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TreeViewEx_Node {
    static SetHandlerBeginLabelEdit(Callback) {
        this.__SetHandler(Callback, 'OnBeginLabelEdit')
    }
    static SetHandlerChildren(CallbackGet) {
        this.__SetHandler(CallbackGet, 'OnGetInfoChildren')
    }
    static SetHandlerDeleteItem(Callback) {
        this.__SetHandler(Callback, 'OnDeleteItem')
    }
    static SetHandlerEndLabelEdit(Callback) {
        this.__SetHandler(Callback, 'OnEndLabelEdit')
    }
    static SetHandlerImage(CallbackGet?, CallbackSet?) {
        if IsSet(CallbackGet) {
            this.__SetHandler(CallbackGet, 'OnGetInfoImage')
        }
        if IsSet(CallbackSet) {
            this.__SetHandler(CallbackSet, 'OnSetInfoImage')
        }
    }
    static SetHandlerInfoTip(CallbackGet) {
        this.__SetHandler(CallbackGet, 'OnGetInfoTip')
    }
    static SetHandlerItemChanged(Callback) {
        this.__SetHandler(Callback, 'OnItemChanged')
    }
    static SetHandlerItemChanging(Callback) {
        this.__SetHandler(Callback, 'OnItemChanging')
    }
    static SetHandlerItemExpanded(Callback) {
        this.__SetHandler(Callback, 'OnItemExpanded')
    }
    static SetHandlerItemExpanding(Callback) {
        this.__SetHandler(Callback, 'OnItemExpanding')
    }
    static SetHandlerName(CallbackGet?, CallbackSet?) {
        if IsSet(CallbackGet) {
            this.__SetHandler(CallbackGet, 'OnGetInfoName')
        }
        if IsSet(CallbackSet) {
            this.__SetHandler(CallbackSet, 'OnSetInfoName')
        }
    }
    static SetHandlerSelectedImage(CallbackGet?, CallbackSet?) {
        if IsSet(CallbackGet) {
            this.__SetHandler(CallbackGet, 'OnGetInfoSelectedImage')
        }
        if IsSet(CallbackSet) {
            this.__SetHandler(CallbackSet, 'OnSetInfoSelectedImage')
        }
    }
    static SetHandlerSingleExpand(Callback) {
        this.__SetHandler(Callback, 'OnSingleExpand')
    }
    static __SetHandler(Callback, Name) {
        if Callback {
            this.Prototype.DefineProp(Name, { Call: Callback })
        } else {
            this.Prototype.DefineProp(Name, { Call: ((Name, *) => TreeViewEx_ThrowOverrideMethodError(Name)).Bind(this.Prototype.__Class '.Prototype.' Name) } )
        }
    }
    __New(Handle := '') {
        this.Handle := Handle
    }

    AddChild(Name := '', Options?) => this.Ctrl.Add(Name, this.Handle, Options ?? unset)
    Copy() => A_Clipboard := this.Ctrl.GetText(this.Handle)
    CopyItemId() {
        A_Clipboard := this.Handle
    }
    Collapse() => SendMessage(TVM_EXPAND, TVE_COLLAPSE, this.Handle, this.HwndCtrl)
    CollapseReset() => SendMessage(TVM_EXPAND, TVE_COLLAPSERESET, this.Handle, this.HwndCtrl)
    CreateDragImage() => SendMessage(TVM_CREATEDRAGIMAGE, 0, this.Handle, this.HwndCtrl)
    Delete() => SendMessage(TVM_DELETEITEM, 0, this.Handle, this.HwndCtrl)
    EnsureVisible() => SendMessage(TVM_ENSUREVISIBLE, 0, this.Handle, this.HwndCtrl)
    EnumChildren(VarCount?) => this.Ctrl.EnumChildren(this.Handle, VarCount ?? unset)
    EnumChildrenRecursive(VarCount?) => this.Ctrl.EnumChildrenRecursive(this.Handle, VarCount ?? unset)
    Expand() => SendMessage(TVM_EXPAND, TVE_EXPAND, this.Handle, this.HwndCtrl)
    ExpandPartial() => SendMessage(TVM_EXPAND, TVE_EXPANDPARTIAL, this.Handle, this.HwndCtrl)
    GetItemState(Mask) => SendMessage(TVM_GETITEMSTATE, this.Handle, Mask, this.HwndCtrl)
    GetRect() => this.Ctrl.GetItemRect(this.Handle)
    GetText() => this.Ctrl.GetText(this.Handle)
    MapHTreeItemToAccId() => SendMessage(TVM_MAPHTREEITEMTOACCID, this.Handle, 0, this.HwndCtrl)
    Select() => SendMessage(TVM_SELECTITEM, TVGN_CARET, this.Handle, this.HwndCtrl)
    SetHandle(Handle) => this.Handle := Handle
    SetLabel(Text) => this.Ctrl.SetLabel(Text, this.Handle)
    SetInsertMark(AfterItem := false) => SendMessage(TVM_SETINSERTMARK, AfterItem, this.Handle, this.HwndCtrl)
    SetTreeView(Hwnd) {
        this.HwndCtrl := Hwnd
    }
    ShowInfoTip() => SendMessage(TVM_SHOWINFOTIP, 0, this.Handle, this.HwndCtrl)
    SortChildren(Recursive := true) => SendMessage(TVM_SORTCHILDREN, Recursive, this.Handle, this.HwndCtrl)
    SortChildrenCb(Callback, lParam?) => this.Ctrl.SortChildrenCb(this.Handle, Callback, lParam ?? 0)
    Toggle() => SendMessage(TVM_EXPAND, TVE_TOGGLE, this.Handle, this.HwndCtrl)

    ; These are intended to be overridden by classes which inherit from `TreeViewEx_Node` or by calling
    ; one of the static "Set<Name>Handler" methods. See README.md for more info.
    OnBeginLabelEdit(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnDeleteItem(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnEndLabelEdit(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnGetInfoChildren(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnGetInfoImage(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnGetInfoName(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnGetInfoSelectedImage(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnGetInfoTip(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnItemChanged(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnItemChanging(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnItemExpanded(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnItemExpanding(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnSetInfoImage(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnSetInfoName(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnSetInfoSelectedImage(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }
    OnSingleExpand(Struct) {
        TreeViewEx_ThrowOverrideMethodError(A_ThisFunc)
    }

    Child => SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, this.Handle, this.HwndCtrl)
    Ctrl => TreeViewEx.Get(this.HwndCtrl)
    Gui => GuiFromHwnd(this.HwndCtrl).Gui
    IsExpanded => this.Ctrl.IsExpanded(this.Handle)
    HasChildren => SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, this.Handle, this.HwndCtrl) ? 1 : 0
    IsRoot => !SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, this.Handle, this.HwndCtrl)
    LineRect => this.Ctrl.GetLineRect(this.Handle)
    Next => SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, this.Handle, this.HwndCtrl)
    Parent => SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, this.Handle, this.HwndCtrl)
    Previous => SendMessage(TVM_GETNEXTITEM, TVGN_PREVIOUS, this.Handle, this.HwndCtrl)
    Root => SendMessage(TVM_GETNEXTITEM, TVGN_ROOT, this.Handle, this.HwndCtrl)
    Rect => this.Ctrl.GetItemRect(this.Handle)
}

TreeViewEx_ThrowOverrideMethodError(fn) {
    throw Error('This method must be overridden.', -1, fn)
}

/**
 * @classdesc - The purpose of {@link TreeViewEx_NodeConstructor} is to provide a systematic entry
 * point for making changes to the node base object.
 *
 * When our code calls {@link TreeViewEx.Prototype.SetNodeConstructor}, the function creates an
 * intermediate base object that acts as a bridge between the class passed to the `NodeClass`
 * parameter and the instances of the class which get created through the use of the
 * {@link TreeViewEx} object.
 *
 * @example
 * SetNodeConstructor(NodeClass) {
 *     this.NodeConstructor := TreeViewEx_NodeConstructor()
 *     this.NodeConstructor.Base := NodeClass
 *     this.NodeConstructor.Prototype := {
 *         HwndCtrl: this.Hwnd
 *       , __Class: NodeClass.Prototype.__Class
 *     }
 *     ObjSetBase(this.NodeConstructor.Prototype, NodeClass.Prototype)
 *     this.Collection := TreeViewExCollection_Node()
 * }
 * @
 *
 * There's a number of benefits to doing this, each benefit an extension of one fundamental purpose -
 * this allows our code to make changes to all of the node objects associated with this
 * {@link TreeViewEx} object, without influencing the node objects associated with any other
 * {@link TreeViewEx} object.
 */
class TreeViewEx_NodeConstructor extends Class {
    Call(Params*) {
        obj := {}
        ObjSetBase(obj, this.Prototype)
        this.Prototype.__New.Call(obj, Params*)
        return obj
    }
    ProtoDefineProp(Name, Descriptor) {
        this.Prototype.DefineProp(Name, Descriptor)
    }
    ProtoDeleteProp(Name) {
        this.Prototype.DeleteProp(Name)
    }
    ProtoDeletePropIf(Name) {
        if this.Prototype.HasOwnProp(Name) {
            this.Prototype.DeleteProp(Name)
            return 1
        }
    }
    ProtoGetProp(Name) {
        return this.Prototype.%Name%
    }
    ProtoGetPropIf(Name, &OutValue) {
        if HasProp(this.Prototype, Name) {
            OutValue := this.Prototype.%Name%
            return 1
        }
    }
    ProtoGetPropDesc(Name) {
        return this.Prototype.GetOwnPropDesc(Name)
    }
    ProtoGetPropDescIf(Name, &OutValue) {
        if this.Prototype.HasOwnProp(Name) {
            OutValue := this.Prototype.GetOwnPropDesc(Name)
            return 1
        }
    }
    ProtoHasProp(Name) {
        return HasProp(this.Prototype, Name)
    }
    ProtoHasOwnProp(Name) {
        return this.Prototype.HasOwnProp(Name)
    }
    ProtoSetProp(Name, Value) {
        this.Prototype.DefineProp(Name, { Value: Value })
    }
}

/**
 * @classdesc - Use this as a safe way to access a window's font object. This handles accessing and
 * releasing the device context and font object.
 *
 * @example
 * g := gui()
 * tvex := TreeViewEx(g)
 * lf := tvex.GetFont()
 * lf.FaceName := Cascadia Mono
 * lf.FontSize := 12
 * lf.Apply()
 * context := TreeViewEx_SelectFontIntoDc(hwnd)
 * ; do work with the device context, located on property "hdc"
 * ; when finished just call the object and let it go out of scope
 * context()
 * @
 */
class TreeViewEx_SelectFontIntoDc {

    __New(hWnd) {
        this.hWnd := hWnd
        if !(this.hdc := DllCall('GetDC', 'Ptr', hWnd, 'ptr')) {
            throw OSError()
        }
        OnError(this.Callback := ObjBindMethod(this, '__ReleaseOnError'), 1)
        if !(this.hFont := SendMessage(0x0031, 0, 0, , hWnd)) { ; WM_GETFONT
            throw OSError()
        }
        if !(this.oldFont := DllCall('SelectObject', 'ptr', this.hdc, 'ptr', this.hFont, 'ptr')) {
            throw OSError()
        }
    }

    /**
     * @description - Selects the old font back into the device context, then releases the
     * device context.
     */
    Call() {
        if err := this.__Release() {
            throw err
        }
    }

    __ReleaseOnError(thrown, mode) {
        if err := this.__Release() {
            thrown.Message .= '; ' err.Message
        }
        throw thrown
    }

    __Release() {
        if this.oldFont {
            if !DllCall('SelectObject', 'ptr', this.hdc, 'ptr', this.oldFont, 'int') {
                err := OSError()
            }
            this.DeleteProp('oldFont')
        }
        if this.hdc {
            if !DllCall('ReleaseDC', 'ptr', this.hWnd, 'ptr', this.hdc, 'int') {
                if IsSet(err) {
                    err.Message .= '; Another error occurred: ' OSError().Message
                }
            }
            this.DeleteProp('hdc')
        }
        OnError(this.Callback, 0)
        return err ?? ''
    }

    __Delete() => this()

    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.DefineProp('hdc', { Value: '' })
        proto.DefineProp('hFont', { Value: '' })
        proto.DefineProp('oldFont', { Value: '' })
    }
}

/**
 * {@link https://learn.microsoft.com/en-us/windows/win32/api/windef/ns-windef-size}
 */
class TreeViewEx_Size extends Buffer {
    /**
     * @description - The `Size` constructor.
     * @param [W] - The width value.
     * @param [H] - The height value.
     * @returns {Size}
     */
    __New(W?, H?) {
        this.Size := 8
        if IsSet(W) {
            this.W := W
        }
        if IsSet(H) {
            this.H := H
        }
    }
    W {
        Get => NumGet(this, 0, 'int')
        Set => NumPut('int', Value, this)
    }
    H {
        Get => NumGet(this, 4, 'int')
        Set => NumPut('int', Value, this, 4)
    }
}

class TreeViewEx_Subclass {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.WindowSubclass := proto.NotifyCollection := proto.MessageCollection := proto.CommandCollection :=
        ''
        proto.flag_Command := proto.flag_Message := proto.flag_Notify := 0
    }
    __New(SubclassProc, HwndSubclass, uIdSubclass) {
        this.WindowSubclass := TreeViewEx_WindowSubclass(SubclassProc, HwndSubclass, uIdSubclass, ObjPtr(this))
    }
    Add(Name, Code, Callback, AddRemove := 1) {
        if !this.flag_%Name% {
            if !this.HasOwnProp(Name 'Collection') {
                this.%Name%Collection := TreeViewExCollection_Code()
            }
            this.flag_%Name% := 1
            if !this.WindowSubclass.IsInstalled {
                this.WindowSubclass.Install()
            }
        }
        Collection := this.%Name%Collection
        if !Collection.Find(Code, &collectionCallback) {
            collectionCallback := TreeViewExCollection_Callback(Code)
            Collection.Insert(collectionCallback)
        }
        switch AddRemove, 0 {
            case 1: collectionCallback.Push(Callback)
            case -1: collectionCallback.InsertAt(1, Callback)
        }
    }
    CommandAdd(CommandCode, Callback, AddRemove := true) {
        this.Add('Command', CommandCode, Callback, AddRemove)
    }
    CommandDelete(CommandCode, Callback?) {
        this.Delete('Command', CommandCode, Callback ?? unset)
    }
    CommandGet(Code) {
        if this.CommandCollection.Find(Code, &collectionCallback) {
            return collectionCallback
        }
    }
    Delete(Name, Code, Callback?) {
        Collection := this.%Name%Collection
        if IsSet(Callback) {
            if !Collection.Find(Code, &collectionCallback) {
                throw UnsetItemError('Code not found.', , Code)
            }
            ; DeleteCallback returns the number of items in the collection after deletion.
            if !collectionCallback.DeleteCallback(Callback) {
                Collection.Remove(Code)
            }
        } else {
            Collection.Remove(Code)
        }
        if !Collection.Length {
            this.flag_%Name% := 0
        }
        if this.flag_Notify + this.flag_Message + this.flag_Command = 0 {
            this.WindowSubclass.Uninstall()
        }
    }
    Dispose() {
        if this.WindowSubclass {
            this.WindowSubclass.Dispose()
        }
        for name in [ 'Command', 'Message', 'Notify' ] {
            if this.HasOwnProp(name 'Collection') {
                collection := this.%name%Collection
                for callback in collection {
                    callback.Length := 0
                }
                collection.Length := 0
                this.DeleteProp(name 'Collection')
            }
        }
    }
    MessageAdd(MessageCode, Callback, AddRemove := true) {
        this.Add('Message', MessageCode, Callback, AddRemove)
    }
    MessageDelete(MessageCode, Callback?) {
        this.Delete('Message', MessageCode, Callback ?? unset)
    }
    MessageGet(Code) {
        if this.MessageCollection.Find(Code, &collectionCallback) {
            return collectionCallback
        }
    }
    NotifyAdd(NotifyCode, Callback, AddRemove := true) {
        this.Add('Notify', NotifyCode, Callback, AddRemove)
    }
    NotifyDelete(NotifyCode, Callback?) {
        this.Delete('Notify', NotifyCode, Callback ?? unset)
    }
    NotifyGet(Code) {
        if this.NotifyCollection.Find(Code, &collectionCallback) {
            return collectionCallback
        }
    }
    __Delete() {
        this.Dispose()
    }
    HwndSubclass => this.WindowSubclass.HwndSubclass
    uIdSubclass => this.WindowSubclass.uIdSubclass
}

/**
 * @classdesc -
 * BOOL SetTreeViewEx_WindowSubclass
 *   HWND          hWnd,
 *   SUBCLASSPROC  pfnSubclass,
 *   UINT_PTR      uIdSubclass,
 *   DWORD_PTR     dwRefData
 * );
 */
class TreeViewEx_WindowSubclass {
    static __New() {
        this.DeleteProp('__New')
        this.Ids := Map()
        Proto := this.Prototype
        Proto.pfnSubclass := proto.__flag_callbackFree := 0
    }
    static GetUid() {
        loop 100 { ; 100 is arbitrary
            id := Random(0, 2 ** 32 - 1)
            if !this.Ids.Has(id) {
                this.Ids.Set(id, 1)
                return id
            }
        }
        throw Error('Failed to create a unique id.')
    }
    /**
     * Calls {@link https://learn.microsoft.com/en-us/windows/win32/api/commctrl/nf-commctrl-setwindowsubclass SetWindowSubclass}
     *
     * @see {@link https://learn.microsoft.com/en-us/windows/win32/controls/subclassing-overview}
     *
     * @see {@link https://learn.microsoft.com/en-us/windows/win32/api/commctrl/nf-commctrl-defsubclassproc}
     *
     * Each hWnd can have multiple active subclass procedures, as long as each one has a unique uIdSubclass.
     *
     * - Calling SetWindowSubclass with the same hwnd and same uIdSubclass:
     *   - The system will replace the existing subclass proc.
     *   - The system will update `dwRefData` with the new data.
     * - Calling with the same hwnd and a different uIdSubclass:
     *   - The system adds an additional subclass to the chain.
     *   - All subclass procedures are called in reverse order (newest first) during message dispatch.
     * - Calling with a different hwnd and the same uIdSubclass:
     *   - The system will add the uIdSubclass to the window's subclass list, as each window maintains
     *     a separate subclass list.
     *
     * @class
     *
     * @param {Func|Integer} [SubclassProc = 0] - The function that will be used as the
     * subclass procedure, or the pointer to the function. This is set to property
     * {@link TreeViewEx_WindowSubclass#SubclassProc}. If `SubclassProc` is 0, `SetWindowSubclass`
     * is not called; your code can set the property by calling {@link TreeViewEx_WindowSubclass.Prototype.SetSubclassProc}.
     *
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/commctrl/nc-commctrl-subclassproc}.
     *
     * @param {Integer} [HwndSubclass] - The handle to the window for which `SubclassProc` will intercept
     * its messages and notifications. If unset, `A_ScriptHwnd` is used.
     *
     * @param {Integer} [uIdSubclass] - Serves as the unique id for this subclass. If set, it must
     * be a ptr-sized integer. If unset, a random integer is generated. This is set to property
     * {@link TreeViewEx_WindowSubclass#uIdSubclass}.
     *
     * @param {Buffer|Integer} [dwRefData = 0] - A buffer containing data that will be passed to the
     * subclass procedure, or a pointer to a memory address containing the data, or the data itself
     * if the data can be represented as a ptr-sized value.
     *
     * @param {Boolean} [DeferActivation = false] - If true, `SetWindowSubclass` is not called, your
     * code must call {@link TreeViewEx_WindowSubclass.Prototype.Install}. If `SubclassProc` is 0,
     * `DeferActivation` is ignored; `SetWindowSubclass` is not called if `SubclassProc` is 0.
     */
    __New(SubclassProc := 0, HwndSubclass?, uIdSubclass?, dwRefData := 0, DeferActivation := false) {
        this.SubclassProc := SubclassProc
        this.Hwnd := HwndSubclass ?? A_ScriptHwnd
        if IsSet(uIdSubclass) {
            if TreeViewEx_WindowSubclass.Ids.Has(uIdSubclass) {
                throw Error('The ``uIdSubclass`` is already in use.', , uIdSubclass)
            }
            this.uIdSubclass := uIdSubclass
            TreeViewEx_WindowSubclass.Ids.Set(uIdSubclass, 1)
        } else {
            this.uIdSubclass := TreeViewEx_WindowSubclass.GetUid()
        }
        this.dwRefData := dwRefData
        if !DeferActivation {
            this.Install()
        }
    }
    Dispose() {
        if this.pfnSubclass {
            this.Uninstall()
        }
        TreeViewEx_WindowSubclass.Ids.Delete(this.uIdSubclass)
        for prop in ['Hwnd', 'uIdSubclass', 'SubclassProc', 'dwRefData'] {
            if this.HasOwnProp(prop) {
                this.DeleteProp(prop)
            }
        }
    }
    /**
     * Installs the subclass.
     * @throws {Error} - The subclass is already installed.
     * @throws {OSError} - The call to `SetWindowSubclass` failed.
     */
    Install() {
        if this.pfnSubclass {
            throw Error('The subclass is already installed.')
        }
        if IsObject(this.SubclassProc) {
            this.pfnSubclass := CallbackCreate(this.SubclassProc)
            this.__flag_callbackFree := 1
        } else {
            this.pfnSubclass := this.SubclassProc
            this.__flag_callbackFree := 0
        }
        if !DllCall(
            g_comctl32_SetWindowSubclass
          , 'ptr', this.Hwnd
          , 'ptr', this.pfnSubclass
          , 'ptr', this.uIdSubclass
          , 'ptr', this.dwRefData
          , 'int'
        ) {
            if this.__flag_callbackFree {
                CallbackFree(this.pfnSubclass)
                this.__flag_callbackFree := 0
            }
            throw OSError('The call to ``SetWindowSubclass`` failed.', -1)
        }
    }
    /**
     * Calls `SetWindowSubclass` with new `dwRefData`, replacing the old data if present.
     *
     * @param {Buffer|Integer} dwRefData - A buffer containing data that will be passed to the
     * subclass procedure, or a pointer to a memory address containing the data.
     *
     * @returns {Buffer|Integer} - The previous value.
     */
    SetRefData(dwRefData) {
        previous := this.dwRefData
        this.dwRefData := dwRefData
        this.Install()
        return previous
    }
    /**
     * @param {Func|Integer} SubclassProc - The function that will be used as the
     * subclass procedure, or the pointer to the function. This is set to property
     * {@link TreeViewEx_WindowSubclass#SubclassProc}.
     *
     * @param {Boolean} [Activate = true] - If true, installs the subclass. If the subclass is already
     * installed, it is first uninstalled, then reinstalled using the new function.
     *
     * If false, only the {@link TreeViewEx_WindowSubclass#SubclassProc} property is changed.
     *
     * @returns {Func|Integer} - The previous value.
     */
    SetSubclassProc(SubclassProc, Activate := true) {
        previous := this.SubclassProc
        this.SubclassProc := SubclassProc
        if Activate {
            if this.IsInstalled {
                this.Uninstall()
            }
            this.Install()
        }
        return previous
    }
    /**
     * Uninstalls the subclass by calling
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/commctrl/nf-commctrl-removewindowsubclass RemoveWindowSubclass}.
     * Sets property {@link TreeViewEx_WindowSubclass#pfnSubclass} := 0.
     * @throws {Error} - The subclass is not installed.
     * @throws {OSError} - The call to `RemoveWindowSubclass` failed.
     */
    Uninstall() {
        if this.IsInstalled {
            pfnSubclass := this.pfnSubclass
            this.pfnSubclass := 0
            if !DllCall(
                g_comctl32_RemoveWindowSubclass
              , 'ptr', this.Hwnd
              , 'ptr', pfnSubclass
              , 'ptr', this.uIdSubclass
              , 'int'
            ) {
                err := OSError('The call to ``RemoveWindowSubclass`` failed.', -1)
            }
            if this.__flag_callbackFree {
                CallbackFree(pfnSubclass)
                this.__flag_callbackFree := 0
            }
            if IsSet(err) {
                throw err
            }
        } else {
            throw Error('The subclass is not installed.')
        }
    }
    __Delete() {
        if this.pfnSubclass {
            this.Uninstall()
        }
    }

    IsInstalled => this.pfnSubclass ? 1 : 0
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

; See the README for tested methods and properties.

class TreeViewEx {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.NodeConstructor := proto.Collection := proto.ParentSubclass := proto.Subclass :=
        proto.CallbackOnExit := proto.ContextMenu := proto.TvexTabId := ''
        this.ClassName := Buffer(StrPut('SysTreeView32', TVEX_DEFAULT_ENCODING))
        StrPut('SysTreeView32', this.ClassName, TVEX_DEFAULT_ENCODING)
        this.Collection_TVEX := TreeViewExCollection()
    }
    static Add(TreeViewExObj) {
        return this.Collection_TVEX.InsertIfAbsent(TreeViewExObj)
    }
    static Delete(Hwnd) {
        return this.Collection_TVEX.RemoveIf(Hwnd)
    }
    static Get(Hwnd) {
        if this.Collection_TVEX.Find(Hwnd, &tvex) {
            return tvex
        } else {
            throw UnsetItemError('Failed to find a value with the input hwnd.', , Hwnd)
        }
    }
    /**
     * {@link TreeViewEx} is a custom tree-view control. It does not inherit from `Gui.Control`
     * nor `Gui.TreeView`, and so the behavior adding it is different from `Gui.Prototype.Add`.
     *
     * When the {@link TreeViewEx} control is created, it will not be affected by AutoHotkey's
     * auto-positioning mechanic; your code will need to set the size and position options
     * directly.
     *
     * If neither `Options.Height` nor `Options.Rows` are set, the height defaults to 1 row.
     *
     * When using `Options.Rows`, the height calculation automatically accounts for the WS_BORDER
     * style, adding 2 additional pixels to the height.
     *
     * Style options are defined using WS and WS_EX style flag constants. Your code can use
     * the global variables (e.g. WS_CHILD, WS_EX_COMPOSITED). If your code encounters a var unset
     * error, call {@link TreeViewEx_SetConstants} any time before using the variables.
     *
     * Font options are defined using `Options.Font`. See {@link TreeViewEx_LogFont}.
     *
     * Most of the {@link https://learn.microsoft.com/en-us/windows/win32/controls/bumper-tree-view-control-reference-messages TVM messages}
     * have been adapted into class instance methods; many of these also expose style and customization
     * capabilities, and are included as available options on the `Options` object.
     *
     * @param {Gui} GuiObj - The `Gui` object on which to add the {@link TreeViewEx}.
     *
     * @param {Object} [Options] - An object with zero or more options as property : value pairs.
     *
     * See {@link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw CreateWindowExW}
     * for information about the CreateWindowExW options. Each CreateWindowExW parameter is associated
     * with a property on the `Options` object.
     *
     * @param {Integer} [Options.AddExStyle] - ExStyle flags to add onto the default.
     * The default is `TVS_EX_DOUBLEBUFFER | WS_EX_COMPOSITED`. Use `Options.AddExStyle` instead
     * of `Options.ExStyle` when your intent is to use additional flags on top of the defaults. The
     * default ExStyle flags are applicable for general use cases.
     *
     * @param {Integer} [Options.AddStyle] - Style flags to add onto the default.
     * The default is `TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_SHOWSELALWAYS | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_BORDER`.
     * Use `Options.AddStyle` instead of `Options.Style` when your intent is to use additional flags
     * on top of the defaults. The default Style flags are applicable for general use cases.
     *
     * @param {Integer} [Options.BkColor] - A COLORREF value to set as the background color.
     * Your code can use {@link TreeViewEx_RGB} to convert r, g, b values to COLORREF.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setbkcolor}.
     *
     * @param {Integer} [Options.ExStyle = TVS_EX_DOUBLEBUFFER | WS_EX_COMPOSITED] - The value to
     * pass to the `dwExStyle` parameter of CreateWindowExW.
     *
     * @param {Object} [Options.Font] - An options object to pass to {@link TreeViewEx_LogFont},
     * setting the font characteristics of the TreeViewEx control. The system may not honor all
     * properties exposed by {@link TreeViewEx_LogFont}; if setting a property value does not invoke
     * any difference in the TreeViewEx control's appearance, that property is likely not available
     * for use for tree-view control text. See {@link TreeViewEx_LogFont.Prototype.__New} for
     * the list of options.
     *
     * @param {Integer} [Options.Height] - The value to pass to the `nHeight` parameter of CreateWindowExW.
     * Also see `Options.Rows`.
     *
     * @param {Integer} [Options.ImageListNormal] - The handle to an image list to use with selected,
     * nonselected, and overlay images for the items of the TreeViewEx control. See my class
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/GDI/ImageList.ahk ImageList}
     * to create an image list from a list of file paths.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setimagelist}.
     *
     * @param {Integer} [Options.ImageListState] - The handle to an image list to use with application-
     * defined item states. A state image is displayed to the left of an item's selected or nonselected
     * image. See my class
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/GDI/ImageList.ahk ImageList}
     * to create an image list from a list of file paths.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setimagelist}.
     *
     * @param {Integer} [Options.Indent] - The width, in pixels, of indentation for the TreeViewEx control.
     * If this value is less than the system-defined minimum width, the new width is set to the system-
     * defined minimum.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setindent}.
     *
     * @param {Integer} [Options.InsertMarkColor] - A COLORREF value to set as the color used to
     * draw the insertion mark for the tree view. Your code can use {@link TreeViewEx_RGB} to convert
     * r, g, b values to COLORREF.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setinsertmarkcolor}.
     *
     * @param {Integer} [Options.Instance = 0] - The value to pass to the `hInstance` parameter of CreateWindowExW.
     * Generally this should be left the default ( 0 ).
     *
     * @param {Integer} [Options.ItemHeight] - New height of every item in the tree view, in pixels.
     * Heights less than 1 will be set to 1. If this argument is not even and the tree-view control
     * does not have the TVS_NONEVENHEIGHT style, this value will be rounded down to the nearest even
     * value.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setitemheight}.
     *
     * @param {Integer} [Options.LineColor] - A COLORREF value to set as the line color. Your code
     * can use {@link TreeViewEx_RGB} to convert r, g, b values to COLORREF.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setlinecolor}.
     *
     * @param {Integer} [Options.Menu = 0] - The value to pass to the `hMenu` parameter of CreateWindowExW.
     * In the context of a tree-view control, `hMenu` is a child-window identifier. Generally this
     * should be left the default ( 0 ).
     *
     * @param {String} [Options.Name] - A name to associate with the TreeViewEx control. The
     * value is set to property {@link TreeViewEx#Name}.
     *
     * @param {Integer} [Options.Param = 0] - The value to pass to the `lpParam` parameter of CreateWindowExW.
     * Generally this should be left the default ( 0 ).
     *
     * @param {Integer} [Options.Rows = 0] - Use `Options.Rows` as an alternative to `Options.Height`.
     * Similar to the `Gui.Control` option "r<n>", `Options.Rows` allows your code to set the height
     * of the TreeViewEx as a number of rows that can be displayed in the control's client area
     * concurrently.
     *
     * @param {Integer} [Options.ScrollTime] - Sets the maximum scroll time, in milliseconds, for
     * the TreeViewEx control. The maximum scroll time is the longest amount of time that a scroll
     * operation can take. Scrolling will be adjusted so that the scroll will take place within the
     * maximum scroll time. A scroll operation may take less time than the maximum.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setscrolltime}.
     *
     * @param {Boolean} [Options.SkipOptions = false] - If true, the `Options` object does not get passed
     * to {@link TreeViewEx.Options.Call}. Set this to true only if the object has already been passed
     * to {@link TreeViewEx.Options.Call}, and so it does not need to be processed again.
     *
     * @param {Integer} [Options.Style = TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_SHOWSELALWAYS | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_BORDER] -
     * The value to pass to the `dwStyle` parameter of CreateWindowExW.
     *
     * @param {Integer} [Options.TextColor] - A COLORREF value that contains the new text color.
     * Your code can use {@link TreeViewEx_RGB} to convert r, g, b values to COLORREF.
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-settextcolor}.
     *
     * @param {Integer} [Options.Width = 100] - The value to pass to the `nWidth` parameter of
     * CreateWindowExW.
     *
     * @param {Integer|String} [Options.WindowName = 0] -
     * - If an integer, the address to a null-terminated string that is passed to the `lpWindowName`
     *   parameter of CreateWindowExW.
     * - If a string, the string to pass to the `lpWindowName` parameter of CreateWindowExW.
     *
     * @param {Integer} [Options.X] - Set `Options.X` with an integer to specify the x-coordinate
     * at which to place the TreeViewEx control. The coordinate is relative to the top-left corner
     * of the gui's client area. If an empty string, `GuiObj.MarginX` is used.
     *
     * @param {Integer} [Options.Y] - Set `Options.Y` with an integer to specify the Y-coordinate
     * at which to place the TreeViewEY control. The coordinate is relative to the top-left corner
     * of the gui's client area. If an empty string, `GuiObj.MarginY` is used.
     *
     */
    __New(GuiObj, Options?) {
        options := TreeViewEx.Options(Options ?? unset)
        this.HwndGui := GuiObj.Hwnd
        rc := WinRect(GuiObj.Hwnd, 1)
        if IsNumber(options.WindowName) {
            windowName := options.WindowName
        } else {
            windowName := Buffer(StrPut(options.WindowName, TVEX_DEFAULT_ENCODING))
            StrPut(options.WindowName, windowName, TVEX_DEFAULT_ENCODING)
        }
        style := options.AddStyle ? options.Style | options.AddStyle : options.Style
        this.Hwnd := DllCall(
            g_user32_CreateWindowExW
          , 'uint', options.AddExStyle ? options.ExStyle | options.AddExStyle : options.ExStyle ; dwExStyle
          , 'ptr', TreeViewEx.ClassName                                                         ; lpClassName
          , 'ptr', windowName                                                                   ; lpWindowName
          , 'uint', style                                                                       ; dwStyle
          , 'int', rc.L + (IsNumber(options.X) ? options.X : GuiObj.MarginX)                    ; X
          , 'int', rc.T + (IsNumber(options.Y) ? options.Y : GuiObj.MarginY)                    ; Y
          , 'int', options.Width                                                                ; nWidth
          , 'int', IsNumber(options.Height) ? options.Height : 1                                ; nHeight
          , 'ptr', this.HwndGui                                                                 ; hWndParent
          , 'ptr', options.Menu                                                                 ; hMenu
          , 'ptr', options.Instance                                                             ; hInstance
          , 'ptr', options.Param                                                                ; lpParam
        )
        TreeViewEx.Add(this)

        this.Name := options.Name

        if options.BkColor {
            this.SetBkColor(options.BkColor)
        }
        if options.Font {
            this.DefineProp('Font', { Value: TreeViewEx_LogFont(this.Hwnd, options.Font) })
        }
        if options.ImageListNormal {
            this.SetImageList(TVSIL_NORMAL, options.ImageListNormal)
        }
        if options.ImageListState {
            this.SetImageList(TVSIL_STATE, options.ImageListState)
        }
        if options.Indent {
            this.SetIndent(options.Indent)
        }
        if options.InsertMarkColor {
            this.SetInsertMarkColor(options.InsertMarkColor)
        }
        if options.ItemHeight {
            this.SetItemHeight(options.ItemHeight)
        }
        if options.LineColor {
            this.SetLineColor(options.LineColor)
        }
        if options.ScrollTime {
            this.SetScrollTime(options.ScrollTime)
        }
        if options.TextColor {
            this.SetTextColor(options.TextColor)
        }

        if options.Rows || !IsNumber(options.Height) {
            this.GetPos(&x, &y, &w, &h)
            WinMove(x, y, w, (options.Rows || 1) * this.GetItemHeight() + (style & WS_BORDER ? 2 : 0), this.Hwnd)
        }
    }
    /**
     * Creates a node object, sets `Struct.lParam := ObjPtrAddRef(node)`, then adds the node to the
     * tree-view.
     *
     * There are two reasons for setting `lParam` with the ptr of the node object:
     * - To prevent the node object from being deleted because this version of the method does
     *   not add it to a collection.
     * - To enable the the use of the notification callback functions that end in "_Ptr".
     *   These functions are likely the most efficient.
     *
     * Managing the collection directly using {@link TreeViewEx.Prototype.AddNode_C} might be
     * more useful in cases when your code needs to regularly access specific node objects outside
     * of the context of a WM_NOTIFY handler. If your code only accesses the nodes from within
     * the context of the WM_NOTIFY handlers, using this method will be more efficient.
     *
     * If you use this, your code must set a TVN_DELETEITEMW handler that includes calling
     * `ObjRelease(struct.lParam)` to allow the node object to be deleted. The demo file
     * {@link Demo "test\demo-NotificationHandlers.ahk"} has an example of this.
     *
     * @param {TvInsertStruct} Struct - An instance of {@link TvInsertStruct} that is sent with
     * TVM_INSERTITEMW.
     *
     * @param {...*} [Params] - Any parameters that must be passed to the node constructor.
     */
    AddNode(Struct, Params*) {
        if !IsObject(Struct) {
            Struct := this.Templates.Get(Struct)
        }
        global g_TreeViewEx_Node := this.NodeConstructor.Call(Params*)
        node := g_TreeViewEx_Node
        Struct.lParam := ObjPtrAddRef(node)
        if node.handle := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
            g_TreeViewEx_Node := ''
            return node
        } else {
            throw Error('Sending ``TVM_INSERTITEMW`` failed.')
        }
    }
    /**
     * Creates a node object, then adds the node to the tree-view, then adds the node to the
     * collection {@link TreeViewEx#Collection}.
     *
     * @param {TvInsertStruct} Struct - An instance of {@link TvInsertStruct} that is sent with
     * TVM_INSERTITEMW.
     *
     * @param {Boolean} [SetParam = false] - If true, ets the member `lParam` with `ObjPtrAddRef(node)`.
     *
     * The purpose of setting `lParam` with the ptr of the node object is to enable the the use of
     * the notification callback functions that end in "_Ptr". These functions are likely the most
     * efficient. When `SetParam` is used, it adds one reference to the reference table for the node
     * object, meaning the node object will not be deleted automatically even if it goes out of scope.
     *
     * If you use `SetParam`, your code must set a TVN_DELETEITEMW handler that includes calling
     * `ObjRelease(struct.lParam)` to allow the node object to be deleted. The demo file
     * {@link Demo "test\demo-NotificationHandlers.ahk"} has an example of this.
     *
     * @param {...*} [Params] - Any parameters that must be passed to the node constructor.
     */
    AddNode_C(Struct, SetParam := false, Params*) {
        if !IsObject(Struct) {
            Struct := this.Templates.Get(Struct)
        }
        global g_TreeViewEx_Node := this.NodeConstructor.Call(Params*)
        node := g_TreeViewEx_Node
        if SetParam {
            Struct.lParam := ObjPtrAddRef(node)
        }
        if handle := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
            node.Handle := handle
            if !this.Collection.InsertIfAbsent(node) {
                throw Error('Handle already exists in the collection.', , handle)
            }
            g_TreeViewEx_Node := ''
            return node
        } else {
            throw Error('Sending ``TVM_INSERTITEMW`` failed.')
        }
    }
    /**
     * @param {Object} Obj - An object with a nested structure representing nodes to be added
     * to the tree view control. The object must have a property that will be used as the node's
     * label, and may have a property that is an array of strings or objects. The strings will be
     * added as nodes with the string Obj.%LabelProp%ue as the label, and the objects are expected to follow this
     * same stucture and will be added as nodes accordingly. The object will be processed recursively.
     *
     * @param {String} [Options] - A Obj.%LabelProp%ue to pass to the `Options` parameter of
     * {@link https://www.autohotkey.com/docs/v2/lib/TreeView.htm#Add `Gui.TreeView.Prototype.Add`}.
     *
     * @param {String} [LabelProp = "Name"] - The name of the property that will be used to define
     * the node's label.
     *
     * @param {String} [ChildrenProp = "Children"] - The name of the property that may have an array
     * of strings/objects.
     *
     * @param {Integer} [MaxDepth = 0] - If a positive integer, the maximum depth limiting the function's
     * recursion. If zero or a negative integer, no limit will be imposed. The initial depth is 1.
     *
     * @param {Integer} [InitialParentId = 0] - The initial Handle under which to start adding items.
     * If 0, the first item is added as a root node.
     */
    AddObj(Obj, InitialParentId := 0, LabelProp := 'Name', ChildrenProp := 'Children', MaxDepth := 0) {
        struct := TvInsertStruct()
        struct.mask := TVIF_TEXT
        this.AddObjListFromTemplate([ Obj ], struct, InitialParentId, LabelProp, ChildrenProp, MaxDepth)
    }
    /**
     * @param {Object[]|String[]} List - A list of objects or strings. The strings are added as items
     * where the string Obj.%LabelProp%ue is the item text. The objects have a nested structure representing
     * nodes to be added to the tree view control. The object must have a property that will be used
     * as the node's label, and may have a property that is an array of strings or objects. The strings
     * will be added as nodes with the string Obj.%LabelProp%ue as the label, and the objects are expected to
     * follow this same stucture and will be added as nodes accordingly. The object will be processed
     * recursively.
     *
     * @param {String} [Options] - A Obj.%LabelProp%ue to pass to the `Options` parameter of
     * {@link https://www.autohotkey.com/docs/v2/lib/TreeView.htm#Add `Gui.TreeView.Prototype.Add`}.
     *
     * @param {String} [LabelProp = "Name"] - The name of the property that will be used to define
     * the node's label.
     *
     * @param {String} [ChildrenProp = "Children"] - The name of the property that may have an array
     * of strings/objects.
     *
     * @param {Integer} [MaxDepth = 0] - If a positive integer, the maximum depth limiting the function's
     * recursion. If zero or a negative integer, no limit will be imposed. The initial depth is 1.
     *
     * @param {Integer} [InitialParentId = 0] - The initial Handle under which to start adding items.
     * If 0, the first item is added as a root node.
     */
    AddObjList(List, InitialParentId := 0, LabelProp := 'Name', ChildrenProp := 'Children', MaxDepth := 0) {
        struct := TvInsertStruct()
        struct.mask := TVIF_TEXT
        this.AddObjListFromTemplate(List, struct, InitialParentId, LabelProp, ChildrenProp, MaxDepth)
    }
    /**
     * Performs the same action as {@link TreeViewEx.Prototype.AddObjList}, but instead of specifying
     * options, you specify a template structure that is sent with
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-insertitem TVM_INSERTITEM}
     * messages.
     *
     * @param {Object[]|String[]} List - A list of objects or strings. The strings are added as items
     * where the string value is the item text. The objects have a nested structure representing
     * nodes to be added to the tree view control. The object must have a property that will be used
     * as the node's label, and may have a property that is an array of strings or objects. The strings
     * will be added as nodes with the string value as the label, and the objects are expected to
     * follow this same stucture and will be added as nodes accordingly. The object will be processed
     * recursively.
     *
     * @param {String|TvInsertStruct} Struct - If a string, the name of a template {@link TvInsertStruct}
     * stored by {@link TreeViewEx.Prototype.AddTemplate}. The {@link TvInsertStruct} object is used
     * as the foundation for each
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-insertitem TVM_INSERTITEM}
     * message sent to the tree-view control. The structure is cloned, then the values of
     * {@link TvInsertStruct#hParent} and {@link TvInsertStruct#pszText} are modified according
     * to the object structure defined by `List` and `InitialParentId`.
     *
     * @param {String} [LabelProp = "Name"] - The name of the property that will be used to define
     * the node's label.
     *
     * @param {String} [ChildrenProp = "Children"] - The name of the property that may have an array
     * of strings/objects.
     *
     * @param {Integer} [MaxDepth = 0] - If a positive integer, the maximum depth limiting the function's
     * recursion. If zero or a negative integer, no limit will be imposed. The initial depth is 1.
     *
     * @param {Integer} [InitialParentId = 0] - The initial Handle under which to start adding items.
     * If 0, the first item is added as a root node.
     */
    AddObjListFromTemplate(List, Struct, InitialParentId := 0, LabelProp := 'Name', ChildrenProp := 'Children', MaxDepth := 0) {
        if IsObject(Struct) {
            Struct := Struct.Clone()
        } else {
            Struct := this.Templates.Get(Struct).Clone()
        }
        Struct.hParent := InitialParentId
        stack := ['']
        this.SetRedraw(0)
        if MaxDepth > 0 {
            for val in List {
                if IsObject(val) {
                    Struct.pszText := val.%LabelProp%
                    if HasProp(val, ChildrenProp) && val.%ChildrenProp% is Array && stack.Length <= MaxDepth {
                        if id := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                            stack.Push(id)
                            _ProcessMaxDepth(val.%ChildrenProp%)
                            stack.Pop()
                            Struct.hParent := InitialParentId
                        } else {
                            _Throw()
                        }
                    } else if !SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                        _Throw()
                    }
                } else {
                    Struct.pszText := val
                    if !SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                        _Throw()
                    }
                }
            }
        } else {
            for val in List {
                if IsObject(val) {
                    Struct.pszText := val.%LabelProp%
                    if HasProp(val, ChildrenProp) && val.%ChildrenProp% is Array {
                        if id := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                            stack.Push(id)
                            _Process(val.%ChildrenProp%)
                            stack.Pop()
                            Struct.hParent := InitialParentId
                        } else {
                            _Throw()
                        }
                    } else if !SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                        _Throw()
                    }
                } else {
                    Struct.pszText := val
                    if !SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                        _Throw()
                    }
                }
            }
        }
        this.SetRedraw(1)

        return

        _Process(List) {
            Struct.hParent := stack[-1]
            for val in List {
                if IsObject(val) {
                    Struct.pszText := val.%LabelProp%
                    if id := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                        if HasProp(val, ChildrenProp) && val.%ChildrenProp% is Array {
                            stack.Push(id)
                            _Process(val.%ChildrenProp%)
                            stack.Pop()
                            Struct.hParent := stack[-1]
                        }
                    } else {
                        _Throw()
                    }
                } else {
                    Struct.pszText := val
                    if !SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                        _Throw()
                    }
                }
            }
        }
        _ProcessMaxDepth(List) {
            Struct.hParent := stack[-1]
            for val in List {
                if IsObject(val) {
                    Struct.pszText := val.%LabelProp%
                    if id := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                        if HasProp(val, ChildrenProp) && val.%ChildrenProp% is Array && stack.Length < MaxDepth {
                            stack.Push(id)
                            _ProcessMaxDepth(val.%ChildrenProp%)
                            stack.Pop()
                            Struct.hParent := stack[-1]
                        }
                    } else {
                        _Throw()
                    }
                } else {
                    Struct.pszText := val
                    if !SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
                        _Throw()
                    }
                }
            }
        }
        _Throw() {
            throw Error('TVM_INSERTITEMW failed.')
        }
    }
    /**
     * Adds one or more items to the "Templates" map. The purpose of storing templates is to improve
     * performance by reusing structures with pre-set members for common tasks.
     *
     * @param {...*} Items - Key-value pairs where the value is an instance of
     * {@link TvInsertStruct}, {@link TvHitTestInfo}, {@link TvItemEx}, {@link TvItem}, or
     * {@link TvSortCb}.
     */
    AddTemplate(Items*) {
        this.Templates.Set(Items*)
    }
    Collapse(Handle) => SendMessage(TVM_EXPAND, TVE_COLLAPSE, Handle, this.Hwnd)
    /**
     * - Sends TVN_ITEMEXPANDINGW with TVE_COLLAPSE. If the return value is zero or an empty string:
     *   - Sends TVM_EXPAND with TVE_COLLAPSE.
     *   - Sends TVN_ITEMEXPANDEDW with TVE_COLLAPSE.
     *
     * @param {Integer} Handle - The tree-view item handle.
     * @param {VarRef} [OutExpandedResult] - A variable that receives the return value from
     * `SendMessage` with TVN_ITEMEXPANDEDW.
     * @returns {Integer} - If `SendMessage` with TVN_ITEMEXPANDINGW returns a nonzero number, returns
     * that value. Else, returns 0.
     */
    CollapseNotify(Handle, &OutExpandedResult?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        if result := this.SendItemExpanding(Handle, TVE_COLLAPSE, &Struct, UseCache) {
            return result
        }
        SendMessage(TVM_EXPAND, TVE_COLLAPSE, Handle, this.Hwnd)
        OutExpandedResult := this.SendItemExpanded(Struct)
        return 0
    }
    CollapseRecursive(Handle := 0, Reset := false) {
        toCollapse := []
        toCollapse.Capacity := this.GetCount()
        if Handle {
            _Recurse(Handle)
        } else {
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, 0, this.Hwnd) {
                _Recurse(child)
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    _Recurse(child)
                }
            }
        }
        action := Reset ? TVE_COLLAPSERESET : TVE_COLLAPSE
        loop toCollapse.Length {
            SendMessage(TVM_EXPAND, action, toCollapse[-A_Index], this.Hwnd)
        }

        return

        _Recurse(Handle) {
            local child, _child
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                toCollapse.Push(Handle)
                _Recurse(child)
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    _Recurse(child)
                }
            }
        }
    }
    CollapseRecursiveNotify(Handle := 0, Reset := false, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        toCollapse := []
        toCollapse.Capacity := this.GetCount()
        if Handle {
            _Recurse(Handle)
        } else {
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, 0, this.Hwnd) {
                _Recurse(child)
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    _Recurse(child)
                }
            }
        }
        action := Reset ? TVE_COLLAPSERESET : TVE_COLLAPSE
        loop toCollapse.Length {
            if !this.SendItemExpanding(toCollapse[-A_Index], action, &Struct, UseCache) {
                SendMessage(TVM_EXPAND, action, toCollapse[-A_Index], this.Hwnd)
                this.SendItemExpanded(Struct)
            }
        }

        return

        _Recurse(Handle) {
            local child, _child
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                toCollapse.Push(Handle)
                _Recurse(child)
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    _Recurse(child)
                }
            }
        }
    }
    CollapseReset(Handle) => SendMessage(TVM_EXPAND, TVE_COLLAPSERESET, Handle, this.Hwnd)
    /**
     * - Sends TVN_ITEMEXPANDINGW with TVE_COLLAPSE. If the return value is zero or an empty string:
     *   - Sends TVM_EXPAND with TVE_COLLAPSE.
     *   - Sends TVN_ITEMEXPANDEDW with TVE_COLLAPSE.
     *
     * @param {Integer} Handle - The tree-view item handle.
     * @param {VarRef} [OutExpandedResult] - A variable that receives the return value from
     * `SendMessage` with TVN_ITEMEXPANDEDW.
     * @returns {Integer} - If `SendMessage` with TVN_ITEMEXPANDINGW returns a nonzero number, returns
     * that value. Else, returns 0.
     */
    CollapseResetNotify(Handle, &OutExpandedResult?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        if result := this.SendItemExpanding(Handle, TVE_COLLAPSERESET, &Struct, UseCache) {
            return result
        }
        SendMessage(TVM_EXPAND, TVE_COLLAPSERESET, Handle, this.Hwnd)
        OutExpandedResult := this.SendItemExpanded(Struct)
        return 0
    }
    CopyText(Handle) {
        A_Clipboard := this.GetText(Handle)
    }
    CreateDragImage(Handle) => SendMessage(TVM_CREATEDRAGIMAGE, 0, Handle, this.Hwnd)
    CreateParentSubclass(SetOnExit := true) {
        this.ParentSubclass := TreeViewEx_Subclass(TreeViewEx_ParentSubclassProc, this.HwndGui, this.Hwnd)
        this.Subclass := TreeViewEx_WindowSubclass(TreeViewEx_ControlSubclassProc, this.Hwnd)
        if SetOnExit {
            this.CallbackOnExit := TreeViewEx_CallbackOnExit.Bind(this.Hwnd)
            OnExit(this.CallbackOnExit, -1)
        }
    }
    DeleteAll() => SendMessage(TVM_DELETEITEM, 0, 0, this.Hwnd)
    DeleteAll_C() {
        this.DeleteAll()
        this.Collection.Length := 0
    }
    DeleteChildren(Handle) {
        while child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
            SendMessage(TVM_DELETEITEM, 0, child, this.Hwnd)
        }
    }
    /**
     * Delete all callbacks associated with a command code.
     */
    DeleteCommandCode(CommandCode) {
        this.ParentSubclass.CommandDelete(this.HwndGui, this, CommandCode)
    }
    DeleteItem(Handle) => SendMessage(TVM_DELETEITEM, 0, Handle, this.Hwnd)
    /**
     * Delete all callbacks associated with a message code.
     */
    DeleteMessageCode(MessageCode) {
        this.ParentSubclass.MessageDelete(this.HwndGui, this, MessageCode)
    }
    DeleteNode_C(Handle) {
        this.Collection.Remove(Handle, &node)
        SendMessage(TVM_DELETEITEM, 0, Handle, this.Hwnd)
        return node
    }
    /**
     * Delete all callbacks associated with a notify code.
     */
    DeleteNotifyCode(NotifyCode) {
        this.ParentSubclass.NotifyDelete(this.HwndGui, this, NotifyCode)
    }
    Destroy() => DllCall(g_user32_DestroyWindow, 'ptr', this.Hwnd, 'int')
    Dispose() {
        if this.GetCount() {
            this.SetRedraw(0)
            this.DeleteAll()
        }
        if this.ParentSubclass && this.ParentSubclass.WindowSubclass.IsInstalled {
            this.ParentSubclass.WindowSubclass.Uninstall()
        }
        if this.Subclass && this.Subclass.IsInstalled {
            this.Subclass.Uninstall()
        }
        TreeViewEx.Delete(this.Hwnd)
        if this.CallbackOnExit {
            OnExit(this.CallbackOnExit, 0)
            this.DeleteProp('CallbackOnExit')
        }
        if this.ContextMenu {
            this.DeleteProp('ContextMenu')
        }
        if WinExist(this.Hwnd) {
            this.Destroy()
        }
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-editlabel}.
     * @param {Integer} [Handle] - The id of the item to edit. If unset, the currently selected
     * item is edited.
     * @returns {Integer} - The handle to the edit control that is created for editing the label, or
     * 0 if unsuccessful.
     */
    EditLabel(Handle?) {
        if !IsSet(Handle) {
            Handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
        }
        if !Handle {
            return 0
        }
        SendMessage(TVM_EDITLABELW, 0, Handle, this.Hwnd)
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-endeditlabelnow}.
     * @param {Boolean} [CancelChanges = false] - Variable that indicates whether the editing is
     * canceled without being saved to the label. If this parameter is TRUE, the system cancels
     * editing without saving the changes. Otherwise, the system saves the changes to the label.
     * @returns {Integer} - Returns nonzero if the system scrolled the items in the tree-view control
     * and no items were expanded. Otherwise, the message returns zero..
     */
    EndEditLabel(CancelChanges := false) => SendMessage(TVM_ENDEDITLABELNOW, CancelChanges, 0, this.Hwnd)
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-ensurevisible}.
     * @param {Integer} [Handle] - The id of the item. If unset, the first root node is used.
     * @returns {Integer} - Returns nonzero if the system scrolled the items in the tree-view control
     * and no items were expanded. Otherwise, the message returns zero.
     */
    EnsureVisible(Handle?) => SendMessage(TVM_ENSUREVISIBLE, 0, Handle ?? this.GetChild(), this.Hwnd)
    EnumChildren(Handle := 0) {
        child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd)
        return _Enum

        _Enum(&Handle?) {
            if child {
                Handle := child
                child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, Handle, this.Hwnd)
                return 1
            } else {
                return 0
            }
        }
    }
    /**
     * @param {Integer} [Handle = 0] - The handle of the item for which its children will be enumerated.
     * @param {Integer} [MaxDepth = TVEX_MAX_RECURSION] - The maximum depth to expand.
     */
    EnumChildrenRecursive(Handle := 0, MaxDepth := TVEX_MAX_RECURSION) {
        enum := { Child: SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd), Stack: [], Parent: Handle }
        if MaxDepth > 0 {
            enum.DefineProp('Call', { Call: _EnumMaxDepth })
        } else {
            enum.DefineProp('Call', { Call: _Enum })
        }

        return enum

        _Enum(Self, &Handle?, &Parent?) {
            if Self.Child {
                Parent := Self.Parent
                Handle := Self.Child
                if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                    Self.Stack.Push({ Parent: Self.Parent, Child: Handle })
                    Self.Parent := Handle
                    Self.Child := child
                } else if child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, Handle, this.Hwnd) {
                    Self.Child := child
                } else if Self.Stack.Length {
                    flag := false
                    while Self.Stack.Length {
                        obj := Self.Stack.Pop()
                        if child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, obj.Child, this.Hwnd) {
                            Self.Parent := obj.Parent
                            Self.Child := child
                            flag := true
                            break
                        }
                    }
                    if !flag {
                        Self.Child := 0
                    }
                } else {
                    Self.Child := 0
                }
                return 1
            } else {
                return 0
            }
        }

        _EnumMaxDepth(Self, &Handle?, &Parent?) {
            if Self.Child {
                Parent := Self.Parent
                Handle := Self.Child
                if Self.Stack.Length < MaxDepth && (child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd)) {
                    Self.Stack.Push({ Parent: Self.Parent, Child: Handle })
                    Self.Parent := Handle
                    Self.Child := child
                } else if child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, Handle, this.Hwnd) {
                    Self.Child := child
                } else if Self.Stack.Length {
                    flag := false
                    while Self.Stack.Length {
                        obj := Self.Stack.Pop()
                        if child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, obj.Child, this.Hwnd) {
                            Self.Parent := obj.Parent
                            Self.Child := child
                            flag := true
                            break
                        }
                    }
                    if !flag {
                        Self.Child := 0
                    }
                } else {
                    Self.Child := 0
                }
                return 1
            } else {
                return 0
            }
        }
    }
    Expand(Handle) => SendMessage(TVM_EXPAND, TVE_EXPAND, Handle, this.Hwnd)
    /**
     * - Sends TVN_ITEMEXPANDINGW with TVE_EXPAND. If the return value is zero or an empty string:
     *   - Sends TVM_EXPAND with TVE_EXPAND.
     *   - Sends TVN_ITEMEXPANDEDW with TVE_EXPAND.
     *
     * @param {Integer} Handle - The tree-view item handle.
     * @param {VarRef} [OutExpandedResult] - A variable that receives the return value from
     * `SendMessage` with TVN_ITEMEXPANDEDW.
     * @returns {Integer} - If `SendMessage` with TVN_ITEMEXPANDINGW returns a nonzero number, returns
     * that value. Else, returns 0.
     */
    ExpandNotify(Handle, &OutExpandedResult?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        if result := this.SendItemExpanding(Handle, TVE_EXPAND, &Struct, UseCache) {
            return result
        }
        SendMessage(TVM_EXPAND, TVE_EXPAND, Handle, this.Hwnd)
        OutExpandedResult := this.SendItemExpanded(Struct)
        return 0
    }
    ExpandPartial(Handle) => SendMessage(TVM_EXPAND, TVE_EXPANDPARTIAL | TVE_EXPAND, Handle, this.Hwnd)
    /**
     * - Sends TVN_ITEMEXPANDINGW with TVE_EXPANDPARTIAL. If the return value is zero or an empty
     *   string:
     *   - Sends TVM_EXPAND with TVE_EXPANDPARTIAL.
     *   - Sends TVN_ITEMEXPANDEDW with TVE_EXPANDPARTIAL.
     *
     * @param {Integer} Handle - The tree-view item handle.
     * @param {VarRef} [OutExpandedResult] - A variable that receives the return value from
     * `SendMessage` with TVN_ITEMEXPANDEDW.
     * @returns {Integer} - If `SendMessage` with TVN_ITEMEXPANDINGW returns a nonzero number, returns
     * that value. Else, returns 0.
     */
    ExpandPartialNotify(Handle, &OutExpandedResult?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        if result := this.SendItemExpanding(Handle, TVE_EXPANDPARTIAL | TVE_EXPAND, &Struct, UseCache) {
            return result
        }
        SendMessage(TVM_EXPAND, TVE_EXPANDPARTIAL | TVE_EXPAND, Handle, this.Hwnd)
        OutExpandedResult := this.SendItemExpanded(Struct)
        return 0
    }
    /**
     * @param {Integer} [Handle = 0] - The node to expand. If 0, all nodes are expanded.
     * @param {Integer} [MaxDepth = TVEX_MAX_RECURSION] - The maximum depth to expand.
     */
    ExpandRecursive(Handle := 0, MaxDepth := TVEX_MAX_RECURSION, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        if Handle {
            if MaxDepth > 0 {
                depth := 0
                _RecurseMaxDepth(Handle)
            } else {
                _Recurse(Handle)
            }
        } else {
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, 0, this.Hwnd) {
                if MaxDepth > 0 {
                    depth := 0
                    _RecurseMaxDepth(child)
                    while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                        _RecurseMaxDepth(child)
                    }
                } else {
                    _Recurse(child)
                    while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                        _Recurse(child)
                    }
                }
            }
        }

        return

        _Recurse(Handle) {
            local child
            if this.HasChildren(Handle, UseCache) {
                SendMessage(TVM_EXPAND, TVE_EXPAND, Handle, this.Hwnd)
            }
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                _Recurse(child)
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    _Recurse(child)
                }
            }
        }
        _RecurseMaxDepth(Handle) {
            local child
            depth++
            if this.HasChildren(Handle, UseCache) {
                SendMessage(TVM_EXPAND, TVE_EXPAND, Handle, this.Hwnd)
            }
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                if depth < MaxDepth {
                    _RecurseMaxDepth(child)
                }
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    if depth < MaxDepth {
                        _RecurseMaxDepth(child)
                    }
                }
            }
            depth--
        }
        _Throw() {
            throw Error('Sending message ``TVM_GETITEMW`` failed.')
        }
    }
    /**
     * - Sends TVN_ITEMEXPANDINGW with TVE_EXPAND. If the return value is zero or an empty string:
     *   - Sends TVM_EXPAND with TVE_EXPAND.
     *   - Sends TVN_ITEMEXPANDEDW with TVE_EXPAND.
     *
     * @param {Integer} [Handle = 0] - The node to expand. If 0, all nodes are expanded.
     * @param {Integer} [MaxDepth = TVEX_MAX_RECURSION] - The maximum depth to expand.
     */
    ExpandRecursiveNotify(Handle := 0, MaxDepth := TVEX_MAX_RECURSION, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        if Handle {
            if MaxDepth > 0 {
                depth := 0
                _RecurseMaxDepth(Handle)
            } else {
                _Recurse(Handle)
            }
        } else {
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, 0, this.Hwnd) {
                if MaxDepth > 0 {
                    depth := 0
                    _RecurseMaxDepth(child)
                    while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                        _RecurseMaxDepth(child)
                    }
                } else {
                    _Recurse(child)
                    while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                        _Recurse(child)
                    }
                }
            }
        }

        return

        _Recurse(Handle) {
            local child
            if this.HasChildren(Handle, UseCache) {
                if !this.SendItemExpanding(Handle, TVE_EXPAND, &Struct, UseCache) {
                    SendMessage(TVM_EXPAND, TVE_EXPAND, Handle, this.Hwnd)
                    this.SendItemExpanded(Struct)
                }
            }
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                _Recurse(child)
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    _Recurse(child)
                }
            }
        }
        _RecurseMaxDepth(Handle) {
            local child
            depth++
            if this.HasChildren(Handle, UseCache) {
                if !this.SendItemExpanding(Handle, TVE_EXPAND, &Struct, UseCache) {
                    SendMessage(TVM_EXPAND, TVE_EXPAND, Handle, this.Hwnd)
                    this.SendItemExpanded(Struct)
                }
            }
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                if depth < MaxDepth {
                    _RecurseMaxDepth(child)
                }
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    if depth < MaxDepth {
                        _RecurseMaxDepth(child)
                    }
                }
            }
            depth--
        }
        _Throw() {
            throw Error('Sending message ``TVM_GETITEMW`` failed.')
        }
    }
    /**
     * - Sends TVN_ITEMEXPANDINGW with TVE_EXPAND. If the return value is zero or an empty string:
     *   - Sends TVM_EXPAND with TVE_EXPAND.
     *   - Sends TVN_ITEMEXPANDEDW with TVE_EXPAND.
     *
     * @param {*} Callback - A `Func` or callable object that is called to determine if a node should
     * be expanded. The callback does not get called for `Handle`.
     * - Parameters:
     *   1. {Integer} The tree-view item handle.
     *   2. {Integer} The handle to the parent item of #1.
     *   3. {Integer} The depth at which the tree-view item associated with parameter 1 is located.
     *      Children of `Handle` are depth 1.
     *   4. {TreeViewEx} The {@link TreeViewEx} object.
     * - The function should return one of the following:
     *   - 0 (or an empty string) : Expand the node and iterate the node's children.
     *   - 1 : Expand the node but do not iterate the node's children, move on to the next sibling node.
     *   - 2 : Expand the node and end the function call. {@link TreeViewEx.Prototype.ExpandRecursiveNotifySelective}
     *     returns `2` to the caller.
     *   - 3 : Do not expand the node and move on to the next sibling node.
     *   - Any other number : Do not expand the node and end the function call.
     *    {@link TreeViewEx.Prototype.ExpandRecursiveNotifySelective} returns the number to the caller.
     *
     * @param {Integer} [Handle = 0] - The node to expand. If 0, all nodes are expanded.
     *
     * @returns {Integer} - One of the following:
     * - 0 : If `Callback` never returned `2` or `4`.
     * - 2 : If `Callback` returned `2`.
     * - 4 : If `Callback` returned `4`.
     */
    ExpandRecursiveNotifySelective(Callback, Handle := 0, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        flag_unwind := false
        if Handle {
            depth := 0
            _Recurse(Handle)
        } else {
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, 0, this.Hwnd) {
                depth := 1
                result := Callback(child, Handle, depth, this)
                switch result, 0 {
                    case 0, '': _Recurse(child)
                    case 1:
                        if this.HasChildren(child, UseCache) {
                            if !this.SendItemExpanding(child, TVE_EXPAND, &Struct, UseCache) {
                                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                                this.SendItemExpanded(Struct)
                            }
                        }
                    case 2:
                        if this.HasChildren(child, UseCache) {
                            if !this.SendItemExpanding(child, TVE_EXPAND, &Struct, UseCache) {
                                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                                this.SendItemExpanded(Struct)
                            }
                        }
                        return 2
                    case 3: ; do nothing
                    default: return result
                }
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    result := Callback(child, Handle, depth, this)
                    switch result, 0 {
                        case 0, '': _Recurse(child)
                        case 1:
                            if this.HasChildren(child, UseCache) {
                                if !this.SendItemExpanding(child, TVE_EXPAND, &Struct, UseCache) {
                                    SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                                    this.SendItemExpanded(Struct)
                                }
                            }
                        case 2:
                            if this.HasChildren(child, UseCache) {
                                if !this.SendItemExpanding(child, TVE_EXPAND, &Struct, UseCache) {
                                    SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                                    this.SendItemExpanded(Struct)
                                }
                            }
                            return 2
                        case 3: ; do nothing
                        default: return result
                    }
                }
            }
        }

        return flag_unwind

        _Recurse(Handle) {
            local child
            depth++
            if this.HasChildren(Handle, UseCache) {
                if !this.SendItemExpanding(Handle, TVE_EXPAND, &Struct, UseCache) {
                    SendMessage(TVM_EXPAND, TVE_EXPAND, Handle, this.Hwnd)
                    this.SendItemExpanded(Struct)
                }
            }
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                result := Callback(child, Handle, depth, this)
                switch result, 0 {
                    case 0, '': _Recurse(child)
                    case 1:
                        if this.HasChildren(child, UseCache) {
                            if !this.SendItemExpanding(child, TVE_EXPAND, &Struct, UseCache) {
                                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                                this.SendItemExpanded(Struct)
                            }
                        }
                    case 2:
                        if this.HasChildren(child, UseCache) {
                            if !this.SendItemExpanding(child, TVE_EXPAND, &Struct, UseCache) {
                                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                                this.SendItemExpanded(Struct)
                            }
                        }
                        flag_unwind := 2
                    case 3: ; do nothing
                    default: flag_unwind := result
                }
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    if flag_unwind {
                        return
                    }
                    result := Callback(child, Handle, depth, this)
                    switch result, 0 {
                        case 0, '': _Recurse(child)
                        case 1:
                            if this.HasChildren(child, UseCache) {
                                if !this.SendItemExpanding(child, TVE_EXPAND, &Struct, UseCache) {
                                    SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                                    this.SendItemExpanded(Struct)
                                }
                            }
                        case 2:
                            if this.HasChildren(child, UseCache) {
                                if !this.SendItemExpanding(child, TVE_EXPAND, &Struct, UseCache) {
                                    SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                                    this.SendItemExpanded(Struct)
                                }
                            }
                            flag_unwind := 2
                        case 3: ; do nothing
                        default: flag_unwind := result
                    }
                }
            }
            depth--
        }
        _Throw() {
            throw Error('Sending message ``TVM_GETITEMW`` failed.')
        }
    }
    /**
     * @param {*} Callback - A `Func` or callable object that is called to determine if a node should
     * be expanded. The callback does not get called for `Handle`.
     * - Parameters:
     *   1. {Integer} The tree-view item handle.
     *   2. {Integer} The handle to the parent item of #1.
     *   3. {Integer} The depth at which the tree-view item associated with parameter 1 is located.
     *      Children of `Handle` are depth 1.
     *   4. {TreeViewEx} The {@link TreeViewEx} object.
     * - The function should return one of the following:
     *   - 0 (or an empty string) : Expand the node and iterate the node's children.
     *   - 1 : Expand the node but do not iterate the node's children, move on to the next sibling node.
     *   - 2 : Expand the node and end the function call. {@link TreeViewEx.Prototype.ExpandRecursiveNotifySelective}
     *     returns `2` to the caller.
     *   - 3 : Do not expand the node and move on to the next sibling node.
     *   - Any other number : Do not expand the node and end the function call.
     *    {@link TreeViewEx.Prototype.ExpandRecursiveNotifySelective} returns the number to the caller.
     *
     * @param {Integer} [Handle = 0] - The node to expand. If 0, all nodes are expanded.
     *
     * @returns {Integer} - One of the following:
     * - 0 : If `Callback` never returned `2` or `4`.
     * - 2 : If `Callback` returned `2`.
     * - 4 : If `Callback` returned `4`.
     */
    ExpandRecursiveSelective(Callback, Handle := 0, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        flag_unwind := false
        if Handle {
            depth := 0
            _Recurse(Handle)
        } else {
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, 0, this.Hwnd) {
                depth := 1
                result := Callback(child, Handle, depth, this)
                switch result, 0 {
                    case 0, '': _Recurse(child)
                    case 1:
                        if this.HasChildren(child, UseCache) {
                            SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                        }
                    case 2:
                        if this.HasChildren(child, UseCache) {
                            SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                        }
                        return 2
                    case 3: ; do nothing
                    default: return result
                }
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    result := Callback(child, Handle, depth, this)
                    switch result, 0 {
                        case 0, '': _Recurse(child)
                        case 1:
                            if this.HasChildren(child, UseCache) {
                                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                            }
                        case 2:
                            if this.HasChildren(child, UseCache) {
                                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                            }
                            return 2
                        case 3: ; do nothing
                        default: return result
                    }
                }
            }
        }

        return flag_unwind

        _Recurse(Handle) {
            local child
            depth++
            if this.HasChildren(Handle, UseCache) {
                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
            }
            if child := SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd) {
                result := Callback(child, Handle, depth, this)
                switch result, 0 {
                    case 0, '': _Recurse(child)
                    case 1:
                        if this.HasChildren(child, UseCache) {
                            SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                        }
                    case 2:
                        if this.HasChildren(child, UseCache) {
                            SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                        }
                        flag_unwind := 2
                    case 3: ; do nothing
                    default: flag_unwind := result
                }
                while child := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, child, this.Hwnd) {
                    if flag_unwind {
                        return
                    }
                    result := Callback(child, Handle, depth, this)
                    switch result, 0 {
                        case 0, '': _Recurse(child)
                        case 1:
                            if this.HasChildren(child, UseCache) {
                                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                            }
                        case 2:
                            if this.HasChildren(child, UseCache) {
                                SendMessage(TVM_EXPAND, TVE_EXPAND, child, this.Hwnd)
                            }
                            flag_unwind := 2
                        case 3: ; do nothing
                        default: flag_unwind := result
                    }
                }
            }
            depth--
        }
        _Throw() {
            throw Error('Sending message ``TVM_GETITEMW`` failed.')
        }
    }
    /**
     * Calculates the optimal position to move one rectangle adjacent to another while
     * ensuring that the `Subject` rectangle stays within the monitor's work area. The properties
     * { L, T, R, B } of `Subject` are updated with the new values.
     *
     * @see {@link RectMoveAdjacent} for parameter information.
     */
    GetAdjacentRect(RectObj, Handle?, ContainerRect?, Dimension := 'X', Prefer := '', Padding := 0, InsufficientSpaceAction := 0) {
        if !IsSet(Handle) {
            Handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
        }
        if !Handle {
            return 0
        }
        RectMoveAdjacent(RectObj, this.GetItemRect(Handle), ContainerRect ?? unset, Dimension, Prefer, Padding, InsufficientSpaceAction)
        return RectObj
    }
    GetBkColor() => SendMessage(TVM_GETBKCOLOR, 0, 0, this.Hwnd)
    GetChild(Handle := 0) => SendMessage(TVM_GETNEXTITEM, TVGN_CHILD, Handle, this.Hwnd)
    GetCount() => SendMessage(TVM_GETCOUNT, 0, 0, this.Hwnd)
    GetEditControl() => SendMessage(TVM_GETEDITCONTROL, 0, 0, this.Hwnd)
    GetExtendedStyle() => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd)
    /**
     * Creates a {@link TreeViewEx_LogFont} object and sets it to property "Font". Use the font object
     * to adjust the control's font attributes. See {@link TreeViewEx_LogFont} for details.
     *
     * @returns {TreeViewEx_LogFont}
     */
    GetFont() {
        if this.HasOwnProp('__Class') {
            return ''
        }
        if !this.HasOwnProp('Font') {
            this.DefineProp('Font', { Value: TreeViewEx_LogFont(this.Hwnd) })
        }
        this.Font.Call()
        return this.Font
    }
    GetImageList(ImageListType) => SendMessage(TVM_GETIMAGELIST, ImageListType, 0, this.Hwnd)
    GetIndent() => SendMessage(TVM_GETINDENT, 0, 0, this.Hwnd)
    GetInsertMarkColor() => SendMessage(TVM_GETINSERTMARKCOLOR, 0, 0, this.Hwnd)
    /**
     * Tree-views maintain an “incremental search string” when the user types while the control has
     * focus. Example: if you have items Apple, Banana, Cherry and the user types “c”, then “h”, the
     * buffer contains "ch" until it times out.
     */
    GetISearchString() {
        if n := SendMessage(TVM_GETISEARCHSTRINGW, 0, 0, this.Hwnd) {
            buf := Buffer(n * 2 + 2)
            SendMessage(TVM_GETISEARCHSTRINGW, 0, buf.Ptr, this.Hwnd)
            return StrGet(buf, TVEX_DEFAULT_ENCODING)
        }
    }
    GetItem(Struct) => SendMessage(TVM_GETITEMW, 0, Struct.Ptr, this.Hwnd)
    GetItemHeight() => SendMessage(TVM_GETITEMHEIGHT, 0, 0, this.Hwnd)
    GetItemRect(Handle?) {
        rc := Rect()
        if !IsSet(Handle) {
            Handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
            if !Handle {
                throw Error('No item is selected')
            }
        }
        NumPut('ptr', Handle, rc, 0)
        if SendMessage(TVM_GETITEMRECT, 1, rc.ptr, this.Hwnd) {
            return rc
        }
    }
    GetItemState(Handle, Mask) => SendMessage(TVM_GETITEMSTATE, Handle, Mask, this.Hwnd)
    GetLineColor() => SendMessage(TVM_GETLINECOLOR, 0, 0, this.Hwnd)
    GetLineRect(Handle) {
        rc := Rect()
        NumPut('ptr', Handle, rc, 0)
        if SendMessage(TVM_GETITEMRECT, 0, rc.ptr, this.Hwnd) {
            return rc
        }
    }
    GetNext(Handle) => SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, Handle, this.Hwnd)
    /**
     * Creates a new node object passing `Handle` to the constructor. Adds the node to the collection
     * (if the collection has been created).
     */
    GetNode(Handle) {
        node := this.NodeConstructor.Call(Handle)
        if IsObject(this.Collection) {
            this.Collection.Set(Handle, node)
        }
        return node
    }
    /**
     * Retrieves a node object from the collection.
     */
    GetNode_C(Handle) {
        return this.Collection.GetValue(Handle)
    }
    /**
     * Retrieves a node object by calling `ObjPtrAddRef(TVITEM.lParam)`. This is only viable if
     * your code sets the `lParam` member with the node objects' ptr addresses.
     */
    GetNode_Ptr(Handle) {
        struct := TvItem()
        struct.mask := TVIF_PARAM | TVIF_HANDLE
        struct.hItem := Handle
        SendMessage(TVM_GETITEMW, 0, struct.Ptr, this.Hwnd)
        return ObjFromPtrAddRef(struct.lParam)
    }
    GetParam(Handle, UseCache := true) {
        if UseCache {
            if this.Templates.Has('_param') {
                item := this.Templates.Get('_param')
            } else {
                item := TvItem()
                item.mask := TVIF_PARAM
                this.Templates.Set('_param', item)
            }
        } else {
            item := TvItem()
            item.mask := TVIF_PARAM
        }
        item.hItem := Handle
        if !SendMessage(TVM_GETITEMW, 0, item.Ptr, this.Hwnd) {
            throw OSError()
        }
        return item.lParam
    }
    GetParent(Handle?) {
        if !IsSet(Handle) {
            Handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
        }
        if !Handle {
            return 0
        }
        return SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, Handle, this.Hwnd)
    }
    GetPos(&X?, &Y?, &W?, &H?) {
        rc := WinRect(this.Hwnd, 0)
        rc.ToClient(this.HwndGui, true)
        X := rc.L
        y := rc.T
        W := rc.W
        H := rc.H
        return rc
    }
    /**
     * @returns {WinRect} - A buffer object representing the control's display rect relative to
     * the parent window. See {@link WinRect}.
     */
    GetRect() => WinRect(this.Hwnd).ToClient(this.HwndGui, true)
    GetRoot(Handle?) {
        if !IsSet(Handle) {
            Handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
        }
        if !Handle {
            return 0
        }
        return SendMessage(TVM_GETNEXTITEM, TVGN_ROOT, Handle, this.Hwnd)
    }
    GetScrollTime() => SendMessage(TVM_GETSCROLLTIME, 0, 0, this.Hwnd)
    GetSelected() => SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
    GetTemplate(Name) {
        return this.Templates.Get(Name)
    }
    /**
     * Returns a template {@link TvDispInfoEx} object with the general properties already set. This
     * does the following:
     * - Sets the state mask with TVIS_STATEIMAGEMASK | TVIS_EXPANDED | TVIS_EXPANDEDONCE | TVIS_SELECTED
     *   | TVIS_CUT | TVIS_DROPHILITED | TVIS_BOLD
     * - If `FillText` is true
     *   - Sets the mask with TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT.
     *   - Sets cchTextMax with `TVEX_DEFAULT_TEXT_MAX / 2` (TVEX_DEFAULT_TEXT_MAX = 256 by default, so 128).
     *   - Sets pszText with a buffer of size `TVEX_DEFAULT_TEXT_MAX`.
     * - If `FillText` is false
     *   - Sets the mask with TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE.
     * - Sets the hwndFrom member with {@link TreeViewEx#Hwnd}.
     * - Sets the idFrom member with {@link TreeViewEx.Prototype.CtrlId}.
     * - Sends TVM_GETITEMW.
     *
     * The caller then should:
     * - Set the code property.
     * - Send the notification.
     *
     * @param {Integer} Handle - The tree-view item handle.
     *
     * @param {Boolean} [FillText = false] - If true, includes TVIF_TEXT and sets cchTextMax and
     * pszText.
     *
     * @param {Boolean} [UseCache = true] - If true:
     * - If this has been called with the same `FillText` value in the past and if
     *   that object still exists in {@link TreeViewEx#Templates}, the cached object is retrieved
     *   and used instead of creating a new object.
     * - If the relevant object does not exist in {@link TreeViewEx#Templates}, then a new object
     *   is created and cached.
     * - The key used depends on the values of `FillText`.
     *
     * If false, a new object is always created and is not cached.
     *
     * @returns {TvDispInfoEx}
     */
    GetTemplateDispInfo(Handle, FillText := false, UseCache := true) {
        local nmtv
        if UseCache {
            if FillText {
                if this.Templates.Has('_dispinfo_text') {
                    nmtv := this.Templates.Get('_dispinfo_text')
                } else {
                    _GetText()
                    this.Templates.Set('_dispinfo_text', nmtv)
                }
            } else {
                if this.Templates.Has('_dispinfo_notext') {
                    nmtv := this.Templates.Get('_dispinfo_notext')
                } else {
                    _GetNoText()
                    this.Templates.Set('_dispinfo_notext', nmtv)
                }
            }
        } else if FillText {
            _GetText()
        } else {
            _GetNoText()
        }
        nmtv.idFrom := this.CtrlId
        nmtv.hItem := Handle
        if !SendMessage(TVM_GETITEMW, 0, nmtv.Ptr + nmtv.offset_mask, this.Hwnd) {
            throw OSError()
        }
        return nmtv

        _GetNoText() {
            nmtv := TvDispInfoEx()
            nmtv.hwndFrom := this.Hwnd
            nmtv.mask := TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE
            nmtv.stateMask := TVIS_STATEIMAGEMASK | TVIS_EXPANDED | TVIS_EXPANDEDONCE
                | TVIS_SELECTED | TVIS_CUT | TVIS_DROPHILITED | TVIS_BOLD
        }
        _GetText() {
            _GetNoText()
            nmtv.mask := nmtv.mask | TVIF_TEXT
            nmtv.SetTextBuffer()
        }
    }
    /**
     * Returns a template {@link TvGetInfoTip} object with the general properties already set. This
     * does the following:
     * - Sets the hwndFrom member with {@link TreeViewEx#Hwnd}.
     * - Sets the idFrom member with {@link TreeViewEx.Prototype.CtrlId}.
     * - Sets the code member with TVN_GETINFOTIPW.
     * - Sets hItem with `Handle`.
     * - Sends TVM_GETITEMW (with a separate structure) to get the lParam associated with `Handle`
     *   and sets lParam.
     *
     * The caller then should:
     * - Call {@link TvGetInfoTip.Prototype.SetTextBuffer} passing the buffer size.
     * - Send the notification.
     *
     * @param {Integer} Handle - The tree-view item handle.
     *
     * @param {Boolean} [UseCache = true] - If true:
     * - If this has been called in the past and if that object still exists in
     *   {@link TreeViewEx#Templates}, the cached object is retrieved and used instead of creating a
     *   new object.
     * - If the relevant object does not exist in {@link TreeViewEx#Templates}, then a new object
     *   is created and cached.
     *
     * If false, a new object is always created and is not cached.
     *
     * @returns {TvGetInfoTip}
     */
    GetTemplateInfoTip(Handle, UseCache := true) {
        local nmtv
        if UseCache {
            if this.Templates.Has('_infotip') {
                nmtv := this.Templates.Get('_infotip')
            } else {
                _Get()
                this.Templates.Set('_infotip', nmtv)
            }
        } else {
            _Get()
        }
        nmtv.hItem := Handle
        nmtv.lParam := this.GetParam(Handle, UseCache)
        nmtv.idFrom := this.CtrlId
        return nmtv

        _Get() {
            nmtv := TvGetInfoTip()
            nmtv.hwndFrom := this.Hwnd
            nmtv.code := TVN_GETINFOTIPW
        }
    }
    /**
     * Returns a template {@link TvItemChange} object with the general properties already set. This
     * does the following:
     * - Sets the hwndFrom member with {@link TreeViewEx#Hwnd}.
     * - Sets the idFrom member with {@link TreeViewEx.Prototype.CtrlId}.
     * - Sets hItem with `Handle`.
     * - Sends TVM_GETITEMW (with a separate structure) to get the lParam associated with `Handle`
     *   and sets lParam.
     * - Sets uChanged with TVIF_STATE.
     *
     * The caller then should:
     * - Set code, uStateNew and uStateOld.
     * - Send the notification.
     *
     * @param {Integer} Handle - The tree-view item handle.
     *
     * @param {Boolean} [UseCache = true] - If true:
     * - If this has been called in the past and if that object still exists in
     *   {@link TreeViewEx#Templates}, the cached object is retrieved and used instead of creating a
     *   new object.
     * - If the relevant object does not exist in {@link TreeViewEx#Templates}, then a new object
     *   is created and cached.
     *
     * If false, a new object is always created and is not cached.
     *
     * @returns {TvItemChange}
     */
    GetTemplateItemChange(Handle, UseCache := true) {
        local nmtv
        if UseCache {
            if this.Templates.Has('_itemchange') {
                nmtv := this.Templates.Get('_itemchange')
            } else {
                _Get()
                this.Templates.Set('_itemchange', nmtv)
            }
        } else {
            _Get()
        }
        nmtv.hItem := Handle
        nmtv.lParam := this.GetParam(Handle, UseCache)
        nmtv.idFrom := this.CtrlId
        return nmtv

        _Get() {
            nmtv := TvItemChange()
            nmtv.hwndFrom := this.Hwnd
            nmtv.uChanged := TVIF_STATE
        }
    }
    /**
     * Returns a template {@link TvKeyDown} object with the general properties already set. This
     * does the following:
     * - Sets the hwndFrom member with {@link TreeViewEx#Hwnd}.
     * - Sets the idFrom member with {@link TreeViewEx.Prototype.CtrlId}.
     * - Sets the code member with TVN_KEYDOWN.
     * - Sets the flags member with 0.
     *
     * The caller then should:
     * - Set wVKey.
     * - Send the notification.
     *
     * @param {Boolean} [UseCache = true] - If true:
     * - If this has been called in the past and if that object still exists in
     *   {@link TreeViewEx#Templates}, the cached object is retrieved and used instead of creating a
     *   new object.
     * - If the relevant object does not exist in {@link TreeViewEx#Templates}, then a new object
     *   is created and cached.
     *
     * If false, a new object is always created and is not cached.
     *
     * @returns {TvKeyDown}
     */
    GetTemplateKeyDown(UseCache := true) {
        local nmtv
        if UseCache {
            if this.Templates.Has('_keydown') {
                nmtv := this.Templates.Get('_keydown')
            } else {
                _Get()
                this.Templates.Set('_keydown', nmtv)
            }
        } else {
            _Get()
        }
        nmtv.idFrom := this.CtrlId
        return nmtv

        _Get() {
            nmtv := TvKeyDown()
            nmtv.hwndFrom := this.Hwnd
            nmtv.code := TVN_KEYDOWN
            nmtv.flags := 0
        }
    }
    /**
     * Returns a template {@link NmTreeView} object with the general properties already set. This
     * does the following:
     * - Sets the state mask with TVIS_STATEIMAGEMASK | TVIS_EXPANDED | TVIS_EXPANDEDONCE | TVIS_SELECTED
     *   | TVIS_CUT | TVIS_DROPHILITED | TVIS_BOLD
     * - If `FillText` is true
     *   - Sets the mask with TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT.
     *   - Sets cchTextMax with `TVEX_DEFAULT_TEXT_MAX / 2` (TVEX_DEFAULT_TEXT_MAX = 256 by default, so 128).
     *   - Sets pszText with a buffer of size `TVEX_DEFAULT_TEXT_MAX`.
     * - If `FillText` is false
     *   - Sets the mask with TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE.
     * - Sets the hwndFrom member with {@link TreeViewEx#Hwnd}.
     * - Sets the idFrom member with {@link TreeViewEx.Prototype.CtrlId}.
     * - If `FillNew` is true
     *   - Sets hItem_new with `Handle`.
     *   - Sends TVM_GETITEMW specifying the offset to fill the new members.
     * - If `FillNew` is false
     *   - Sets hItem_old with `Handle`.
     *   - Sends TVM_GETITEMW specifying the offset to fill the old members.
     *
     * The caller then should:
     * - Set the other properties (as needed) like code, action, ptDrag.
     * - Send the notification.
     *
     * @param {Integer} Handle - The tree-view item handle.
     *
     * @param {Boolean} [FillNew = true] - If true, sends TVM_GETITEMW to fill the itemNew member of
     * the NMTREEVIEWW structure (setting the properties suffixed with "_new"). If false, sends
     * TVM_GETITEMW to fill the itemOld member of the structure (setting the properties suffixed with
     * "_old").
     *
     * @param {Boolean} [FillText = false] - If true, includes TVIF_TEXT and sets cchTextMax and
     * pszText.
     *
     * @param {Boolean} [UseCache = true] - If true:
     * - If this has been called with the same values of `FillNew` and `FillText` in the past and if
     *   that object still exists in {@link TreeViewEx#Templates}, the cached object is retrieved
     *   and used instead of creating a new object.
     * - If the relevant object does not exist in {@link TreeViewEx#Templates}, then a new object
     *   is created and cached.
     * - The key used depends on the values of `Fillnew` and `FillText`.
     *
     * If false, a new object is always created and is not cached.
     *
     * @returns {NmTreeView}
     */
    GetTemplateNmtv(Handle, FillNew := true, FillText := false, UseCache := true) {
        local nmtv
        if FillNew {
            suffix := '_new'
        } else {
            suffix := '_old'
        }
        if UseCache {
            if FillText {
                if this.Templates.Has('_nmtv' suffix '_text') {
                    nmtv := this.Templates.Get('_nmtv' suffix '_text')
                } else {
                    _GetText()
                    this.Templates.Set('_nmtv' suffix '_text', nmtv)
                }
            } else {
                if this.Templates.Has('_nmtv' suffix '_notext') {
                    nmtv := this.Templates.Get('_nmtv' suffix '_notext')
                } else {
                    _GetNoText()
                    this.Templates.Set('_nmtv' suffix '_notext', nmtv)
                }
            }
        } else if FillText {
            _GetText()
        } else {
            _GetNoText()
        }
        nmtv.idFrom := this.CtrlId
        nmtv.hItem%suffix% := Handle
        if !SendMessage(TVM_GETITEMW, 0, nmtv.Ptr + nmtv.offset_mask%suffix%, this.Hwnd) {
            throw OSError()
        }
        return nmtv

        _GetNoText() {
            nmtv := NmTreeView()
            nmtv.hwndFrom := this.Hwnd
            nmtv.mask%suffix% := TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE
            nmtv.stateMask%suffix% := TVIS_STATEIMAGEMASK | TVIS_EXPANDED | TVIS_EXPANDEDONCE
                | TVIS_SELECTED | TVIS_CUT | TVIS_DROPHILITED | TVIS_BOLD
        }
        _GetText() {
            _GetNoText()
            nmtv.mask%suffix% := nmtv.mask%suffix% | TVIF_TEXT
            nmtv.SetTextBuffer(suffix)
        }
    }
    GetText(Handle) {
        struct := TvItem()
        struct.mask := TVIF_TEXT | TVIF_HANDLE
        struct.hItem := Handle
        struct.SetTextBuffer()
        if SendMessage(TVM_GETITEMW, 0, struct.Ptr, this.Hwnd) {
            return struct.pszText
        }
        throw Error('Failed to get the item`'s text.')
    }
    GetTextColor() => SendMessage(TVM_GETTEXTCOLOR, 0, 0, this.Hwnd)
    GetTooltips() => SendMessage(TVM_GETTOOLTIPS, 0, 0, this.Hwnd)
    GetVisibleCount() => SendMessage(TVM_GETVISIBLECOUNT, 0, 0, this.Hwnd)
    HasChildren(Handle, UseCache := true) {
        if UseCache {
            if this.Templates.Has('_children') {
                item := this.Templates.Get('_children')
            } else {
                item := TvItem()
                item.mask := TVIF_CHILDREN
                this.Templates.Set('_children', item)
            }
        } else {
            item := TvItem()
            item.mask := TVIF_CHILDREN
        }
        item.hItem := Handle
        if !SendMessage(TVM_GETITEMW, 0, item.Ptr, this.Hwnd) {
            throw OSError()
        }
        return item.cChildren
    }
    Hide() {
        this.Enabled := this.Visible := 0
    }
    /**
     * If one or both of `X` and `Y` are unset, the mouse's position is used.
     * @param {Integer} [X] - The X-coordinate relative to the TreeView control (client coordinate).
     * @param {Integer} [Y] - The Y-coordinate relative to the TreeView control (client coordinate).
     * @returns {TvHitTestInfo}
     */
    HitTest(X?, Y?) {
        if IsSet(X) && IsSet(Y) {
            hitTestInfo := TvHitTestInfo()
            hitTestInfo.X := X
            hitTestInfo.Y := Y
        } else {
            pt := Point.FromCursor()
            pt.ToClient(this.Hwnd, true)
            hitTestInfo := TvHitTestInfo(pt)
        }
        SendMessage(TVM_HITTEST, 0, hitTestInfo.Ptr, this.Hwnd)
        return hitTestInfo
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-insertitem}
     * @param {TvInsertStruct} Struct - {@link TvInsertStruct}
     */
    Insert(Struct) => SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd)
    /**
     * Returns 1 if `HandleDescentant` is a descendant of `HandlePotentialAncestor`.
     *
     * @param {Integer} [HandleDescendant] - A tree-view item handle. If unset, the handle to the
     * currently selected item is used. If unset and no item is selected, the function returns 0.
     *
     * @param {Integer} [HandlePotentialAncestor] - A tree-view item handle. If unset, the handle to
     * the currently selected item is used. If unset and no item is selected, the function returns 0.
     *
     * @returns {Integer} -
     * - Returns 0 if `HandleDescendant` is unset and no item is selected.
     * - Returns 0 if `HandlePotentialAncestor` is unset and no item is selected.
     * - Returns 0 if `HandleDescendant = HandlePotentialAncestor`.
     * - Returns 1 if `HandleDescendant` is a descendant of `HandlePotentialAncestor`.
     */
    IsAncestor(HandleDescendant?, HandlePotentialAncestor?) {
        if !IsSet(HandleDescendant) {
            HandleDescendant := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
            if !HandleDescendant {
                return 0
            }
        }
        if !IsSet(HandlePotentialAncestor) {
            HandlePotentialAncestor := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
            if !HandlePotentialAncestor {
                return 0
            }
        }
        if HandleDescendant = HandlePotentialAncestor {
            return 0
        }
        h := HandleDescendant
        while h := SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, h, this.Hwnd) {
            if h = HandlePotentialAncestor {
                return 1
            }
        }
        return 0
    }
    IsExpanded(Handle?) {
        if !IsSet(Handle) {
            Handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
        }
        return SendMessage(TVM_GETITEMSTATE, Handle, TVIS_EXPANDED, this.Hwnd) & TVIS_EXPANDED
    }
    IsRoot(Handle) => !SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, Handle, this.Hwnd)
    MapAccIdToHTreeItem(AccId) => SendMessage(TVM_MAPACCIDTOHTREEITEM, AccId, 0, this.Hwnd)
    MapHTreeItemToAccId(Handle) => SendMessage(TVM_MAPHTREEITEMTOACCID, Handle, 0, this.Hwnd)
    OnCommand(CommandCode, Callback, AddRemove := 1) {
        if !this.HasOwnProp('ParentSubclass') {
            this.CreateParentSubclass()
        }
        if AddRemove {
            this.ParentSubclass.CommandAdd(CommandCode, Callback, AddRemove)
        } else {
            this.ParentSubclass.CommandDelete(CommandCode, Callback)
        }
    }
    OnMessage(MessageCode, Callback, AddRemove := 1) {
        if !this.HasOwnProp('ParentSubclass') {
            this.CreateParentSubclass()
        }
        if AddRemove {
            this.ParentSubclass.MessageAdd(MessageCode, Callback, AddRemove)
        } else {
            this.ParentSubclass.MessageDelete(MessageCode, Callback)
        }
    }
    OnNotify(NotifyCode, Callback, AddRemove := 1) {
        if !this.HasOwnProp('ParentSubclass') {
            this.CreateParentSubclass()
        }
        if AddRemove {
            this.ParentSubclass.NotifyAdd(NotifyCode, Callback, AddRemove)
        } else {
            this.ParentSubclass.NotifyDelete(NotifyCode, Callback)
        }
    }
    /**
     * See {@link https://learn.microsoft.com/en-us/windows/win32/api/Winuser/nf-winuser-redrawwindow}.
     * @param {Integer} [flags = RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN] -
     * Zero or a combination of the flags lsited in the
     * {@link https://learn.microsoft.com/en-us/windows/win32/api/Winuser/nf-winuser-redrawwindow documentation}.
     */
    Redraw(flags := RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN) {
        Sleep(-1)
        return DllCall(
            g_user32_RedrawWindow
          , 'ptr', this.Hwnd
          , 'ptr', 0
          , 'ptr', 0
          , 'uint', flags
        )
    }
    RemoveParentSubclass() {
        this.ParentSubclass.Dispose()
        this.DeleteProp('ParentSubclass')
    }
    ScrollToBottom() {
        this.EnsureVisible(SendMessage(TVM_GETNEXTITEM, TVGN_LASTVISIBLE, 0, this.Hwnd))
    }
    ScrollToTop() {
        this.EnsureVisible(SendMessage(TVM_GETNEXTITEM, TVGN_ROOT, 0, this.Hwnd))
    }
    Select(Handle) => SendMessage(TVM_SELECTITEM, TVGN_CARET, Handle, this.Hwnd)
    SendBeginDrag(Handle, ptDrag?, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateNmtv(Handle, true, false, UseCache)
        OutStruct.code := TVN_BEGINDRAGW
        if !IsSet(ptDrag) {
            ptDrag := Point.FromCursor()
        }
        OutStruct.x := ptDrag.X
        OutStruct.y := ptDrag.Y
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    SendBeginLabelEdit(Handle, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateDispInfo(Handle, true, UseCache)
        OutStruct.code := TVN_BEGINLABELEDITW
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    SendBeginRDrag(Handle, ptDrag?, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateNmtv(Handle, true, false, UseCache)
        OutStruct.code := TVN_BEGINRDRAGW
        if !IsSet(ptDrag) {
            ptDrag := Point.FromCursor()
        }
        OutStruct.x := ptDrag.X
        OutStruct.y := ptDrag.Y
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    SendDeleteItem(Handle, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateNmtv(Handle, false, false, UseCache)
        OutStruct.code := TVN_DELETEITEMW
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvn-endlabeledit}
     *
     * @param {TvDispInfoEx} Struct - The {@link TvDispInfoEx} object with the modified
     * NMTVDISPINFO structure. The item member of this structure is a TVITEM structure whose hItem,
     * lParam, and pszText members contain valid information about the item that was edited. If label
     * editing was canceled, the pszText member of the TVITEM structure is NULL; otherwise, pszText
     * is the address of the edited text.
     *
     * @param {Boolean} [FillMembers = false] - If true, the caller is only responsible for providing
     * a {@link TvDispInfoEx} object with the pszText property and hItem property set; this function
     * will fill the other members of the structure that are expected to be filled when sending the
     * notification. If false, the caller has filled all expected members (except code which this
     * this function always sets).
     *
     * @returns {Integer} - The value returned by `SendMessage`.
     */
    SendEndLabelEdit(Struct, FillMembers := false) {
        if FillMembers {
            Struct.hwndFrom := this.Hwnd
            Struct.idFrom := this.CtrlId
            Struct.mask := TVIF_HANDLE | TVIF_PARAM
            if !SendMessage(TVM_GETITEMW, 0, Struct.Ptr + Struct.offset_mask, this.Hwnd) {
                throw OSError()
            }
            Struct.mask := Struct.mask | TVIF_TEXT
        }
        Struct.code := TVN_ENDLABELEDITW
        return SendMessage(WM_NOTIFY, Struct.idFrom, Struct.Ptr, , this.HwndGui)
    }
    SendGetDispInfo(Handle, Mask, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateDispInfo(Handle, false, UseCache)
        OutStruct.mask := Mask
        OutStruct.code := TVN_GETDISPINFOW
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    SendGetInfoTip(Handle, TextMax := TVEX_DEFAULT_TEXT_MAX, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateInfoTip(Handle, UseCache)
        OutStruct.SetTextBuffer(TextMax)
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvn-itemchanged}
     *
     * @param {TvItemChange} Struct - The {@link TvItemChange} object, typically the same object
     * that was sent with TVN_ITEMCHANGINGW.
     *
     * @param {Boolean} [FillMembers = false] - If true, the caller is only responsible for providing
     * a {@link TvItemChange} object with the hItem, uStateNew, and uStateOld properties set; this
     * function will fill the other members of the structure that are expected to be filled when
     * sending the notification. If false, the caller has filled all expected members (except code
     * which this this function always sets).
     *
     * @returns {Integer} - The value returned by `SendMessage`.
     */
    SendItemChanged(Struct, FillMembers := false, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        if FillMembers {
            Struct.lParam := this.GetParam(Struct.hItem, UseCache)
            Struct.idFrom := this.CtrlId
            Struct.hwndFrom := this.Hwnd
            Struct.uChanged := TVIF_STATE
        }
        Struct.code := TVN_ITEMCHANGEDW
        return SendMessage(WM_NOTIFY, Struct.idFrom, Struct.Ptr, , this.HwndGui)
    }
    SendItemChanging(Handle, StateNew, StateOld, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateItemChange(Handle, UseCache)
        OutStruct.uStateNew := StateNew
        OutStruct.uStateOld := StateOld
        OutStruct.code := TVN_ITEMCHANGINGW
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvn-itemexpanded}
     *
     * @param {NmTreeView} Struct - The {@link NmTreeView} object, typically the same object
     * that was sent with TVN_ITEMEXPANDINGW.
     *
     * @param {Boolean} [FillMembers = false] - If true, the caller is only responsible for providing
     * a {@link NmTreeView} object with the hItem and action properties set; this
     * function will fill the other members of the structure that are expected to be filled when
     * sending the notification. If false, the caller has filled all expected members (except code
     * which this this function always sets).
     *
     * @returns {Integer} - The value returned by `SendMessage`.
     */
    SendItemExpanded(Struct, FillMembers := false) {
        if FillMembers {
            Struct.idFrom := this.CtrlId
            Struct.hwndFrom := this.Hwnd
            Struct.mask_new := TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE
            Struct.stateMask_new := TVIS_STATEIMAGEMASK | TVIS_EXPANDED | TVIS_EXPANDEDONCE
                | TVIS_SELECTED | TVIS_CUT | TVIS_DROPHILITED | TVIS_BOLD
            if !SendMessage(TVM_GETITEMW, 0, Struct.Ptr + Struct.offset_mask_new, this.Hwnd) {
                throw OSError()
            }
        }
        Struct.code := TVN_ITEMEXPANDEDW
        return SendMessage(WM_NOTIFY, Struct.idFrom, Struct.Ptr, , this.HwndGui)
    }
    SendItemExpanding(Handle, Action, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateNmtv(Handle, true, false, UseCache)
        OutStruct.code := TVN_ITEMEXPANDINGW
        OutStruct.action := Action
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    SendKeyDown(Handle, VKey, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateKeyDown(UseCache)
        OutStruct.wVKey := VKey
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    SendSetDispInfo(Handle, Mask, &OutStruct?, UseCache := TVEX_SENDNOTIFY_USECACHE) {
        OutStruct := this.GetTemplateDispInfo(Handle, false, UseCache)
        OutStruct.mask := Mask
        OutStruct.code := TVN_SETDISPINFOW
        return SendMessage(WM_NOTIFY, OutStruct.idFrom, OutStruct.Ptr, , this.HwndGui)
    }
    SetAutoScrollInfo(PixelsPerSecond, RedrawInterval) => SendMessage(TVM_SETAUTOSCROLLINFO, PixelsPerSecond, RedrawInterval, this.Hwnd)
    SetBkColor(Color) => SendMessage(TVM_SETBKCOLOR, 0, Color, this.Hwnd)
    SetContextMenu(MenuExObj) {
        if IsSet(MenuEx) && MenuExObj is MenuEx {
            if this.ContextMenuActive {
                this.ParentSubclass.MessageDelete(WM_CONTEXTMENU)
            }
            this.OnMessage(WM_CONTEXTMENU, TreeViewEx_HandlerContextMenu)
            this.ContextMenu := MenuExObj
        } else {
            throw TypeError('``MenuExObj`` must inherit from ``MenuEx``.')
        }
    }
    /**
     *
     */
    SetExtendedStyle(Value, Styles) => SendMessage(TVM_SETEXTENDEDSTYLE, Value, Styles, this.Hwnd)
    /**
     * Sets the height of the TreeViewEx control as a number of rows that can be displayed in the
     * control's client area concurrently.
     * @param {Integer} Rows - The number of rows.
     * @returns {Integer} - The new height.
     */
    SetHeight(Rows) {
        height := Rows * this.GetItemHeight() + (this.Border ? 2 : 0)
        WinMove(, , , height)
        return height
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-setimagelist}
     *
     * @param {Integer} ImageListType - One of the following:
     * - TVSIL_NORMAL
     * - TVSIL_STATE
     * @param {Integer} Handle - The handle to the image list.
     */
    SetImageList(ImageListType, Handle) => SendMessage(TVM_SETIMAGELIST, ImageListType, Handle, this.Hwnd)
    SetIndent(Value) => SendMessage(TVM_SETINDENT, Value, 0, this.Hwnd)
    SetInsertMark(Handle, AfterItem := false) => SendMessage(TVM_SETINSERTMARK, AfterItem, Handle, this.Hwnd)
    SetInsertMarkColor(Color) => SendMessage(TVM_SETINSERTMARKCOLOR, 0, Color, this.Hwnd)
    SetItem(Struct) => SendMessage(TVM_SETITEMW, 0, Struct.Ptr, this.Hwnd)
    SetItemHeight(Height) => SendMessage(TVM_SETITEMHEIGHT, Height, 0, this.Hwnd)
    /**
     * Example setting two states, both true states.
     * @example
     * ; Assume `tvex` references an existing TreeViewEx object and `handle` is a tree-view item handle.
     * ; Set as expanded and selected.
     * ; This would not expand the node, it only sets the state value.
     * tvex.SetItemState(tv, TVIS_EXPANDED | TVIS_SELECTED, TVIS_EXPANDED | TVIS_SELECTED, handle)
     * @
     *
     * Example setting two states, one true one false states.
     * @example
     * ; Assume `tvex` references an existing TreeViewEx object and `handle` is a tree-view item handle.
     * ; Set as expanded and not selected.
     * ; This would not expand or deselect the node, it only sets the state value.
     * tvex.SetItemState(tv, TVIS_EXPANDED | TVIS_SELECTED, TVIS_EXPANDED, hItem)
     * @
     *
     * Example setting two states, both false states.
     * @example
     * ; Assume `tvex` references an existing TreeViewEx object and `handle` is a tree-view item handle.
     * ; Set as not expanded and not selected.
     * ; This would not collapse or deselect the node, it only sets the state value.
     * tvex.SetItemState(tv, TVIS_EXPANDED | TVIS_SELECTED, , hItem)
     * @
     */
    SetItemState(StateMask, ValueMask := 0, Handle?) {
        if !IsSet(Handle) {
            Handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
        }
        if !Handle {
            return 0
        }
        struct := TvItem()
        struct.mask := TVIF_STATE
        struct.hItem := Handle
        struct.stateMask := StateMask
        struct.state := ValueMask
        return SendMessage(TVM_SETITEMW, 0, struct.Ptr, this.Hwnd)
    }
    SetLabel(Text, Handle?) {
        if !IsSet(Handle) {
            Handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0, this.Hwnd)
            if !Handle {
                throw Error('No item is currently selected.')
            }
        }
        item := TvItem()
        item.mask := TVIF_TEXT
        item.hItem := Handle
        item.pszText := Text
        return SendMessage(TVM_SETITEMW, 0, item.Ptr, this.Hwnd)
    }
    SetLineColor(Color) => SendMessage(TVM_SETLINECOLOR, 0, Color, this.Hwnd)
    SetNodeConstructor(NodeClass) {
        this.NodeConstructor := TreeViewEx_NodeConstructor()
        this.NodeConstructor.Prototype := {
            HwndCtrl: this.Hwnd
          , __Class: NodeClass.Prototype.__Class
        }
        ObjSetBase(this.NodeConstructor.Prototype, NodeClass.Prototype)
        this.Collection := TreeViewExCollection_Node()
    }
    /**
     * @param {Boolean} Value - If true, allows changes in the window to be redrawn, and also calls
     * {@link TreeViewEx.Prototype.Redraw}. If false, does not allow changes in the window to be redrawn.
     *
     * This is analagous to the
     * {@link https://www.autohotkey.com/docs/v2/lib/Gui.htm#Add_Parameters "+/-Redraw" Gui.Control option}.
     */
    SetRedraw(Value) {
        SendMessage(WM_SETREDRAW, Value, 0, this.Hwnd)
        if Value {
            this.Redraw()
        }
    }
    SetScrollTime(TimeMs) => SendMessage(TVM_SETSCROLLTIME, TimeMs, 0, this.Hwnd)
    /**
     * @param {Boolean} Value - When nonzero, does the following:
     * - Sets {@link TreeViewEx#Enabled} and {@link TreeViewEx#Visible} to `1`.
     * - Calls `TreeViewExObj.ParentSubclass.WindowSubclass.Install` to activate the SUBCLASSPROC.
     *
     * When zero or an empty string, does the following:
     * - Sets {@link TreeViewEx#Enabled} and {@link TreeViewEx#Visible} to `0`.
     * - Calls `TreeViewExObj.ParentSubclass.WindowSubclass.Uninstall` to deactivate the SUBCLASSPROC.
     */
    SetStatus(Value) {
        if Value {
            this.Enabled := this.Visible := 1
            this.ParentSubclass.WindowSubclass.Install()
        } else {
            this.Enabled := this.Visible := 0
            this.ParentSubclass.WindowSubclass.Uninstall()
        }
    }
    SetTextColor(Color) => SendMessage(TVM_SETTEXTCOLOR, 0, Color, this.Hwnd)
    SetTooltips(Handle) => SendMessage(TVM_SETTOOLTIPS, Handle, 0, this.Hwnd)
    SetTvexTabId(Id) {
        this.TvexTabId := Id
    }
    Show() {
        this.Enabled := this.Visible := 1
    }
    ShowInfoTip(Handle) => SendMessage(TVM_SHOWINFOTIP, 0, Handle, this.Hwnd)
    SortChildren(Handle, Recursive := true) => SendMessage(TVM_SORTCHILDREN, Recursive, Handle, this.Hwnd)
    /**
     * See {@link https://learn.microsoft.com/en-us/windows/win32/api/commctrl/ns-commctrl-tvsortcb}
     * for details about the callback.
     *
     * See {@link https://learn.microsoft.com/en-us/windows/win32/controls/tvm-sortchildrencb} for
     * details about the message.
     */
    SortChildrenCb(hParent, Callback, lParam := 0) {
        cb := CallbackCreate(Callback)
        _tvSortCb := TvSortCb()
        _tvSortCb.hParent := hParent
        _tvSortCb.lpfnCompare := cb
        _tvSortCb.lParam := lParam
        try {
            result := SendMessage(TVM_SORTCHILDREN, 0, _tvSortCb.Ptr, this.Hwnd)
        } catch Error as err {
            CallbackFree(cb)
            throw err
        }
        CallbackFree(cb)
        return result
    }
    Toggle(Handle) => SendMessage(TVM_EXPAND, TVE_TOGGLE, Handle, this.Hwnd)


    AutoHScroll {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_AUTOHSCROLL
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_AUTOHSCROLL, TVS_EX_AUTOHSCROLL, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_AUTOHSCROLL, this.Hwnd)
            }
        }
    }
    Border {
        Get => WinGetStyle(this.Hwnd) & WS_BORDER
        Set {
            if Value {
                WinSetStyle('+' WS_BORDER, this.Hwnd)
            } else {
                WinSetStyle('-' WS_BORDER, this.Hwnd)
            }
        }
    }
    Checkboxes {
        Get => WinGetStyle(this.Hwnd) & TVS_CHECKBOXES
        Set {
            if Value {
                WinSetStyle('+' TVS_CHECKBOXES, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_CHECKBOXES, this.Hwnd)
            }
        }
    }
    ContextMenuActive => this.ContextMenu && this.HasOwnProp('ParentSubclass') && this.ParentSubclass.MessageGet(WM_CONTEXTMENU)
    CtrlId {
        Get => DllCall(g_user32_GetDlgCtrlID, 'ptr', this.Hwnd, 'ptr')
        Set => DllCall(g_user32_SetWindowLongPtrW, 'ptr', this.Hwnd, 'int', GWLP_ID, 'ptr', Value, 'int')
    }
    DimmedCheckboxes {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_DIMMEDCHECKBOXES
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_DIMMEDCHECKBOXES, TVS_EX_DIMMEDCHECKBOXES, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_DIMMEDCHECKBOXES, this.Hwnd)
            }
        }
    }
    DisableDragDrop {
        Get => WinGetStyle(this.Hwnd) & TVS_DISABLEDRAGDROP
        Set {
            if Value {
                WinSetStyle('+' TVS_DISABLEDRAGDROP, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_DISABLEDRAGDROP, this.Hwnd)
            }
        }
    }
    DoubleBuffer {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_DOUBLEBUFFER
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_DOUBLEBUFFER, TVS_EX_DOUBLEBUFFER, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_DOUBLEBUFFER, this.Hwnd)
            }
        }
    }
    DrawImageAsync {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_DRAWIMAGEASYNC
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_DRAWIMAGEASYNC, TVS_EX_DRAWIMAGEASYNC, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_DRAWIMAGEASYNC, this.Hwnd)
            }
        }
    }
    EditLabels {
        Get => WinGetStyle(this.Hwnd) & TVS_EDITLABELS
        Set {
            if Value {
                WinSetStyle('+' TVS_EDITLABELS, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_EDITLABELS, this.Hwnd)
            }
        }
    }
    Enabled {
        Get => DllCall(g_user32_IsWindowEnabled, 'ptr', this.Hwnd, 'int')
        Set => DllCall(g_user32_EnableWindow, 'ptr', this.Hwnd, 'int', Value ? 1 : 0, 'int')
    }
    ExclusionCheckboxes {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_EXCLUSIONCHECKBOXES
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_EXCLUSIONCHECKBOXES, TVS_EX_EXCLUSIONCHECKBOXES, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_EXCLUSIONCHECKBOXES, this.Hwnd)
            }
        }
    }
    FadeInOutExpandos {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_FADEINOUTEXPANDOS
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_FADEINOUTEXPANDOS, TVS_EX_FADEINOUTEXPANDOS, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_FADEINOUTEXPANDOS, this.Hwnd)
            }
        }
    }
    Font {
        Get => this.GetFont()
        Set {
            this.DefineProp('Font', { Value: Value })
        }
    }
    FullRowselect {
        Get => WinGetStyle(this.Hwnd) & TVS_FULLROWSELECT
        Set {
            if Value {
                WinSetStyle('+' TVS_FULLROWSELECT, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_FULLROWSELECT, this.Hwnd)
            }
        }
    }
    Gui => GuiFromHwnd(this.HwndGui)
    HasButtons {
        Get => WinGetStyle(this.Hwnd) & TVS_HASBUTTONS
        Set {
            if Value {
                WinSetStyle('+' TVS_HASBUTTONS, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_HASBUTTONS, this.Hwnd)
            }
        }
    }
    HasLines {
        Get => WinGetStyle(this.Hwnd) & TVS_HASLINES
        Set {
            if Value {
                WinSetStyle('+' TVS_HASLINES, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_HASLINES, this.Hwnd)
            }
        }
    }
    Infotip {
        Get => WinGetStyle(this.Hwnd) & TVS_INFOTIP
        Set {
            if Value {
                WinSetStyle('+' TVS_INFOTIP, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_INFOTIP, this.Hwnd)
            }
        }
    }
    LinesAtRoot {
        Get => WinGetStyle(this.Hwnd) & TVS_LINESATROOT
        Set {
            if Value {
                WinSetStyle('+' TVS_LINESATROOT, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_LINESATROOT, this.Hwnd)
            }
        }
    }
    MultiSelect {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_MULTISELECT
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_MULTISELECT, TVS_EX_MULTISELECT, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_MULTISELECT, this.Hwnd)
            }
        }
    }
    NoHScroll {
        Get => WinGetStyle(this.Hwnd) & TVS_NOHSCROLL
        Set {
            if Value {
                WinSetStyle('+' TVS_NOHSCROLL, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_NOHSCROLL, this.Hwnd)
            }
        }
    }
    NoIndentState {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_NOINDENTSTATE
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_NOINDENTSTATE, TVS_EX_NOINDENTSTATE, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_NOINDENTSTATE, this.Hwnd)
            }
        }
    }
    NonEvenHeight {
        Get => WinGetStyle(this.Hwnd) & TVS_NONEVENHEIGHT
        Set {
            if Value {
                WinSetStyle('+' TVS_NONEVENHEIGHT, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_NONEVENHEIGHT, this.Hwnd)
            }
        }
    }
    NoScroll {
        Get => WinGetStyle(this.Hwnd) & TVS_NOSCROLL
        Set {
            if Value {
                WinSetStyle('+' TVS_NOSCROLL, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_NOSCROLL, this.Hwnd)
            }
        }
    }
    NoSingleCollapse {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_NOSINGLECOLLAPSE
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_NOSINGLECOLLAPSE, TVS_EX_NOSINGLECOLLAPSE, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_NOSINGLECOLLAPSE, this.Hwnd)
            }
        }
    }
    NoTooltips {
        Get => WinGetStyle(this.Hwnd) & TVS_NOTOOLTIPS
        Set {
            if Value {
                WinSetStyle('+' TVS_NOTOOLTIPS, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_NOTOOLTIPS, this.Hwnd)
            }
        }
    }
    PartialCheckboxes {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_PARTIALCHECKBOXES
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_PARTIALCHECKBOXES, TVS_EX_PARTIALCHECKBOXES, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_PARTIALCHECKBOXES, this.Hwnd)
            }
        }
    }
    RichTooltip {
        Get => SendMessage(TVM_GETEXTENDEDSTYLE, 0, 0, this.Hwnd) & TVS_EX_RICHTOOLTIP
        Set {
            if Value {
                SendMessage(TVM_SETEXTENDEDSTYLE, TVS_EX_RICHTOOLTIP, TVS_EX_RICHTOOLTIP, this.Hwnd)
            } else {
                SendMessage(TVM_SETEXTENDEDSTYLE, 0, TVS_EX_RICHTOOLTIP, this.Hwnd)
            }
        }
    }
    RtlReading {
        Get => WinGetStyle(this.Hwnd) & TVS_RTLREADING
        Set {
            if Value {
                WinSetStyle('+' TVS_RTLREADING, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_RTLREADING, this.Hwnd)
            }
        }
    }
    ShowSelAlways {
        Get => WinGetStyle(this.Hwnd) & TVS_SHOWSELALWAYS
        Set {
            if Value {
                WinSetStyle('+' TVS_SHOWSELALWAYS, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_SHOWSELALWAYS, this.Hwnd)
            }
        }
    }
    SingleExpand {
        Get => WinGetStyle(this.Hwnd) & TVS_SINGLEEXPAND
        Set {
            if Value {
                WinSetStyle('+' TVS_SINGLEEXPAND, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_SINGLEEXPAND, this.Hwnd)
            }
        }
    }
    Templates {
        Get {
            this.DefineProp('Templates', { Value: TreeViewExCollection_Template(false) })
            return this.Templates
        }
        Set {
            this.DefineProp('Templates', { Value: Value })
            return this.Templates
        }
    }
    TrackSelect {
        Get => WinGetStyle(this.Hwnd) & TVS_TRACKSELECT
        Set {
            if Value {
                WinSetStyle('+' TVS_TRACKSELECT, this.Hwnd)
            } else {
                WinSetStyle('-' TVS_TRACKSELECT, this.Hwnd)
            }
        }
    }
    TvexTab => IsSet(TreeViewEx_Tab) && this.TvexTabId ? TreeViewEx_Tab.Get(this.TvexTabId) : ''
    Visible {
        Get => DllCall(g_user32_IsWindowVisible, 'ptr', this.Hwnd, 'int')
        Set => DllCall(g_user32_ShowWindow, 'ptr', this.Hwnd, 'int', Value ? 4 : 0, 'int')
    }

    class Options {
        static __New() {
            this.DeleteProp('__New')
            TreeViewEx_SetConstants()
            this.Default := {
                AddExStyle: ''
              , AddStyle: ''
              , BkColor: ''
              , ExStyle: TVS_EX_DOUBLEBUFFER | WS_EX_COMPOSITED
              , Font: ''
              , Height: ''
              , ImageListNormal: ''
              , ImageListState: ''
              , Indent: ''
              , InsertMarkColor: ''
              , Instance: 0
              , ItemHeight: ''
              , LineColor: ''
              , Menu: 0
              , Name: ''
              , Param: 0
              , Rows: ''
              , ScrollTime: ''
              , SkipOptions: false
              , Style: TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_SHOWSELALWAYS | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_BORDER
              , TextColor: ''
              , Width: 100
              , WindowName: 0
              , X: ''
              , Y: ''
            }
        }
        static Call(Options?) {
            if IsSet(Options) {
                o := {}
                d := this.Default
                for prop in d.OwnProps() {
                    o.%prop% := HasProp(Options, prop) ? Options.%prop% : d.%prop%
                }
                return o
            } else {
                return this.Default.Clone()
            }
        }
    }
}

class TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        if !IsSet(TVS_HASBUTTONS) {
            TreeViewEx_SetConstants()
        }
    }
    static FromPtr(Ptr) {
        struct := { Buffer: { Ptr: Ptr, Size: this.Prototype.cbSizeInstance } }
        ObjSetBase(struct, this.Prototype)
        return struct
    }
    static __GetStructureProps() {
        proto := this.Prototype
        structureProps := proto.StructureProps := []
        for prop in proto.OwnProps() {
            if proto.GetOwnPropDesc(prop).HasOwnProp('Set') {
                structureProps.Push(prop)
            }
        }
    }
    __New(Members?) {
        this.Buffer := Buffer(this.cbSizeInstance, 0)
        if IsSet(Members) {
            b := this.Base
            while b {
                if b.HasOwnProp('StructureProps') {
                    for prop in b.StructureProps {
                        if HasProp(Members, prop) {
                            this.%prop% := Members.%prop%
                        }
                    }
                    break
                }
                b := b.Base
            }
        }
    }
    /**
     * @description - Copies the bytes from this object's buffer to another buffer.
     *
     * @param {*} [Buf] - If set, one of the following kinds of objects:
     * - An instance of a class that inherits from {@link TreeViewExStructBase}.
     * - A `Buffer` object.
     * - An object with properties { Ptr, Size }.
     *
     * The size of the buffer must be at least `this.cbSizeInstance + Offset`.
     *
     * If unset, a buffer of adequate size will be created.
     *
     * @param {Integer} [Offset = 0] - The byte offset at which to copy the data. For example, if
     * `Offset == 8`, then the data will be copied to `Buf.Ptr + 8`. The first 8 bytes of the
     * new/target buffer will be unchanged.
     *
     * @param {Boolean} [MakeInstance = true] - If true, and if `Buf` is unset or is not already
     * an instance of the class, then an instance of the class will be created.
     *
     * @returns {*} - Depending on the value of `MakeInstance`, the `Buffer` object or the instance object.
     *
     * @throws {Error} - "The input buffer's size is insufficient."
     */
    Clone(Buf?, Offset := 0, MakeInstance := true) {
        if Offset < 0 {
            throw ValueError('``Offset`` must be a positive integer.', -1, Offset)
        }
        if IsSet(Buf) {
            if not Buf is Buffer && Type(Buf) != this.__Class {
                throw TypeError('Invalid input parameter ``Buf``.', -1)
            }
        } else {
            Buf := Buffer(this.Size + Offset)
        }
        if Buf.Size < this.Size + Offset {
            throw Error('The input buffer`'s size is insufficient.', -1, Buf.Size)
        }
        DllCall(
            g_msvcrt_memmove
          , 'ptr', Buf.Ptr + Offset
          , 'ptr', this.Ptr
          , 'int', this.Size
          , 'ptr'
        )
        if MakeInstance && Type(Buf) != this.__Class {
            b := this
            loop {
                if b := b.Base {
                    if Type(b) = 'Prototype' {
                        break
                    }
                } else {
                    throw Error('Unable to identify the prototype object.')
                }
            }
            if Offset {
                Obj := { Buffer: { __Buffer: Buf, Ptr: Buf.Ptr + Offset, Size: this.Size } }
            } else {
                Obj := { Buffer: Buf }
            }
            ObjSetBase(Obj, b)
            return Obj
        } else {
            return Buf
        }
    }
    Ptr => this.Buffer.Ptr
    Size => this.Buffer.Size
}

class TvAsyncDraw extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type                     Symbol            Offset               Padding
        A_PtrSize + ; HWND                   hwndFrom          0
        A_PtrSize + ; UINT_PTR               idFrom            0 + A_PtrSize * 1
        A_PtrSize + ; UINT                   code              0 + A_PtrSize * 2    +4 on x64 only
        A_PtrSize + ; IMAGELISTDRAWPARAMS    *pimldp           0 + A_PtrSize * 3
        A_PtrSize + ; HRESULT                hr                0 + A_PtrSize * 4    +4 on x64 only
        A_PtrSize + ; HTREEITEM              hItem             0 + A_PtrSize * 5
        A_PtrSize + ; LPARAM                 lParam            0 + A_PtrSize * 6
        4 +         ; DWORD                  dwRetFlags        0 + A_PtrSize * 7
        4           ; int                    iRetImageIndex    4 + A_PtrSize * 7
        proto.offset_hwndFrom        := 0
        proto.offset_idFrom          := 0 + A_PtrSize * 1
        proto.offset_code            := 0 + A_PtrSize * 2
        proto.offset_pimldp         := 0 + A_PtrSize * 3
        proto.offset_hr              := 0 + A_PtrSize * 4
        proto.offset_hItem           := 0 + A_PtrSize * 5
        proto.offset_lParam          := 0 + A_PtrSize * 6
        proto.offset_dwRetFlags      := 0 + A_PtrSize * 7
        proto.offset_iRetImageIndex  := 4 + A_PtrSize * 7
    }
    hwndFrom {
        Get => NumGet(this.Buffer, this.offset_hwndFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwndFrom)
        }
    }
    idFrom {
        Get => NumGet(this.Buffer, this.offset_idFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_idFrom)
        }
    }
    code {
        Get => NumGet(this.Buffer, this.offset_code, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_code)
        }
    }
    code_int {
        Get => NumGet(this.Buffer, this.offset_code, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_code)
        }
    }
    pimldp {
        Get {
            if !this.HasOwnProp('__pimldp') {
                this.__pimldp := TvImageListDrawParams.FromPtr(NumGet(this.Buffer, this.offset_pimldp, 'ptr'))
            }
            return this.__pimldp
        }
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_pimldp)
            if Value {
                this.__pimldp := TvImageListDrawParams.FromPtr(Value)
            }
        }
    }
    hr {
        Get => NumGet(this.Buffer, this.offset_hr, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_hr)
        }
    }
    hItem {
        Get => NumGet(this.Buffer, this.offset_hItem, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hItem)
        }
    }
    lParam {
        Get => NumGet(this.Buffer, this.offset_lParam, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lParam)
        }
    }
    dwRetFlags {
        Get => NumGet(this.Buffer, this.offset_dwRetFlags, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwRetFlags)
        }
    }
    iRetImageIndex {
        Get => NumGet(this.Buffer, this.offset_iRetImageIndex, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iRetImageIndex)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TvDispInfoEx extends TvItemEx {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol            Offset                Padding
        A_PtrSize + ; HWND         hwndFrom          0
        A_PtrSize + ; UINT_PTR     idFrom            0 + A_PtrSize * 1
        A_PtrSize + ; UINT         code              0 + A_PtrSize * 2     +4 on x64 only
        A_PtrSize + ; UINT         mask              0 + A_PtrSize * 3     +4 on x64 only
        A_PtrSize + ; HTREEITEM    hItem             0 + A_PtrSize * 4
        4 +         ; UINT         state             0 + A_PtrSize * 5
        4 +         ; UINT         stateMask         4 + A_PtrSize * 5
        A_PtrSize + ; LPWSTR       pszText           8 + A_PtrSize * 5
        4 +         ; int          cchTextMax        8 + A_PtrSize * 6
        4 +         ; int          iImage            12 + A_PtrSize * 6
        4 +         ; int          iSelectedImage    16 + A_PtrSize * 6
        4 +         ; int          cChildren         20 + A_PtrSize * 6
        A_PtrSize + ; LPARAM       lParam            24 + A_PtrSize * 6
        4 +         ; int          iIntegral         24 + A_PtrSize * 7
        4 +         ; UINT         uStateEx          28 + A_PtrSize * 7
        A_PtrSize + ; HWND         hwnd              32 + A_PtrSize * 7
        4 +         ; int          iExpandedImage    32 + A_PtrSize * 8
        4           ; int          iReserved         36 + A_PtrSize * 8
        proto.offset_hwndFrom        := 0
        proto.offset_idFrom          := 0 + A_PtrSize * 1
        proto.offset_code            := 0 + A_PtrSize * 2
        proto.offset_mask            := 0 + A_PtrSize * 3
        proto.offset_hItem           := 0 + A_PtrSize * 4
        proto.offset_state           := 0 + A_PtrSize * 5
        proto.offset_stateMask       := 4 + A_PtrSize * 5
        proto.offset_pszText         := 8 + A_PtrSize * 5
        proto.offset_cchTextMax      := 8 + A_PtrSize * 6
        proto.offset_iImage          := 12 + A_PtrSize * 6
        proto.offset_iSelectedImage  := 16 + A_PtrSize * 6
        proto.offset_cChildren       := 20 + A_PtrSize * 6
        proto.offset_lParam          := 24 + A_PtrSize * 6
        proto.offset_iIntegral       := 24 + A_PtrSize * 7
        proto.offset_uStateEx        := 28 + A_PtrSize * 7
        proto.offset_hwnd            := 32 + A_PtrSize * 7
        proto.offset_iExpandedImage  := 32 + A_PtrSize * 8
        proto.offset_iReserved       := 36 + A_PtrSize * 8
    }
    hwndFrom {
        Get => NumGet(this.Buffer, this.offset_hwndFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwndFrom)
        }
    }
    idFrom {
        Get => NumGet(this.Buffer, this.offset_idFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_idFrom)
        }
    }
    code {
        Get => NumGet(this.Buffer, this.offset_code, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_code)
        }
    }
    code_int {
        Get => NumGet(this.Buffer, this.offset_code, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_code)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TvGetInfoTip extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol        Offset               Padding
        A_PtrSize + ; HWND         hwndFrom      0
        A_PtrSize + ; UINT_PTR     idFrom        0 + A_PtrSize * 1
        A_PtrSize + ; UINT         code          0 + A_PtrSize * 2    +4 on x64 only
        A_PtrSize + ; LPWSTR       pszText       0 + A_PtrSize * 3
        A_PtrSize + ; int          cchTextMax    0 + A_PtrSize * 4    +4 on x64 only
        A_PtrSize + ; HTREEITEM    hItem         0 + A_PtrSize * 5
        A_PtrSize   ; LPARAM       lParam        0 + A_PtrSize * 6
        proto.offset_hwndFrom    := 0
        proto.offset_idFrom      := 0 + A_PtrSize * 1
        proto.offset_code        := 0 + A_PtrSize * 2
        proto.offset_pszText     := 0 + A_PtrSize * 3
        proto.offset_cchTextMax  := 0 + A_PtrSize * 4
        proto.offset_hItem       := 0 + A_PtrSize * 5
        proto.offset_lParam      := 0 + A_PtrSize * 6

        proto.__pszText := ''
    }
    SetTextBuffer(Bytes := TVEX_DEFAULT_TEXT_MAX) {
        this.__pszText := Buffer(Bytes)
        this.cchTextMax := Floor(Bytes / 2)
        NumPut('ptr', this.__pszText.Ptr, this.Buffer, this.offset_pszText)
    }

    hwndFrom {
        Get => NumGet(this.Buffer, this.offset_hwndFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwndFrom)
        }
    }
    idFrom {
        Get => NumGet(this.Buffer, this.offset_idFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_idFrom)
        }
    }
    code {
        Get => NumGet(this.Buffer, this.offset_code, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_code)
        }
    }
    code_int {
        Get => NumGet(this.Buffer, this.offset_code, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_code)
        }
    }
    pszText {
        Get {
            Value := NumGet(this.Buffer, this.offset_pszText, 'ptr')
            if Value > 0 {
                return StrGet(Value, TVEX_DEFAULT_ENCODING)
            } else {
                return Value
            }
        }
        Set {
            if ptr := NumGet(this.Buffer, this.offset_pszText, 'ptr') {
                if this.__pszText {
                    bytes := StrPut(Value, TVEX_DEFAULT_ENCODING)
                    if bytes > this.__pszText.Size {
                        this.__pszText.Size := bytes
                        ptr := this.__pszText.Ptr
                        NumPut('ptr', ptr, this.Buffer, this.offset_pszText)
                    }
                }
            } else {
                this.__pszText := Buffer(StrPut(Value, TVEX_DEFAULT_ENCODING))
                ptr := this.__pszText.Ptr
                NumPut('ptr', ptr, this.Buffer, this.offset_pszText)
            }
            if chars := this.cchTextMax {
                StrPut(SubStr(Value, 1, chars - 1), ptr, TVEX_DEFAULT_ENCODING)
            } else {
                StrPut(Value, ptr, TVEX_DEFAULT_ENCODING)
            }
        }
    }
    cchTextMax {
        Get => NumGet(this.Buffer, this.offset_cchTextMax, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cchTextMax)
        }
    }
    hItem {
        Get => NumGet(this.Buffer, this.offset_hItem, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hItem)
        }
    }
    lParam {
        Get => NumGet(this.Buffer, this.offset_lParam, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lParam)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * {@link https://learn.microsoft.com/en-us/windows/win32/api/Commctrl/ns-commctrl-tvhittestinfo}.
 */
class TvHitTestInfo extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol   Offset               Padding
        4 +         ; INT          X        0
        4 +         ; INT          Y        4
        A_PtrSize + ; UINT         flags    8                    +4 on x64 only
        A_PtrSize   ; HTREEITEM    hItem    8 + A_PtrSize * 1
        proto.offset_X := 0
        proto.offset_Y := 4
        proto.offset_flags := 8
        proto.offset_hItem := 8 + A_PtrSize * 1
        proto.FlagSymbols := Map()
        proto.FlagSymbols.CaseSense := false
        proto.FlagSymbols.Default := ''
        proto.FlagSymbols.Set(
            TVHT_ABOVE, 'Above'
          , TVHT_BELOW, 'Below'
          , TVHT_NOWHERE, 'Nowhere'
          , TVHT_ONITEM, 'OnItem'
          , TVHT_ONITEMBUTTON, 'OnItemButton'
          , TVHT_ONITEMICON, 'OnItemIcon'
          , TVHT_ONITEMINDENT, 'OnItemIndent'
          , TVHT_ONITEMLABEL, 'OnItemLabel'
          , TVHT_ONITEMRIGHT, 'OnItemRight'
          , TVHT_ONITEMSTATEICON, 'OnItemStateIcon'
          , TVHT_TOLEFT, 'ToLeft'
          , TVHT_TORIGHT, 'ToRight'
        )
        proto.flags_OnItemGeneral := TVHT_ONITEM | TVHT_ONITEMBUTTON | TVHT_ONITEMICON | TVHT_ONITEMLABEL | TVHT_ONITEMSTATEICON
    }
    GetFlags() {
        list := []
        for flag in this.FlagSymbols {
            if this.flags & flag {
                list.Push(flag)
            }
        }
        return list.Length ? list : ''
    }
    GetSymbols(delimiter := '`n') {
        s := ''
        for flag, symbol in this.FlagSymbols {
            if this.flags & flag {
                s .= symbol delimiter
            }
        }
        return SubStr(s, 1, -StrLen(delimiter))
    }
    X {
        Get => NumGet(this.Buffer, this.offset_X, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_X)
        }
    }
    Y {
        Get => NumGet(this.Buffer, this.offset_Y, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_Y)
        }
    }
    flags {
        Get => NumGet(this.Buffer, this.offset_flags, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_flags)
        }
    }
    hItem {
        Get => NumGet(this.Buffer, this.offset_hItem, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hItem)
        }
    }
    Above => this.flags & TVHT_ABOVE
    Below => this.flags & TVHT_BELOW
    Nowhere => this.flags & TVHT_NOWHERE
    OnItem => this.flags & TVHT_ONITEM
    OnItemButton => this.flags & TVHT_ONITEMBUTTON
    OnItemGeneral => this.flags & this.flags_OnItemGeneral
    OnItemIcon => this.flags & TVHT_ONITEMICON
    OnItemIndent => this.flags & TVHT_ONITEMINDENT
    OnItemLabel => this.flags & TVHT_ONITEMLABEL
    OnItemRight => this.flags & TVHT_ONITEMRIGHT
    OnItemStateIcon => this.flags & TVHT_ONITEMSTATEICON
    Symbols => this.GetSymbols()
    ToLeft => this.flags & TVHT_TOLEFT
    ToRight => this.flags & TVHT_TORIGHT
}

class TvImageListDrawParams extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type            Symbol      Offset                Padding
        A_PtrSize + ; DWORD         cbSize      0                     +4 on x64 only
        A_PtrSize + ; HIMAGELIST    himl        0 + A_PtrSize * 1
        A_PtrSize + ; int           i           0 + A_PtrSize * 2     +4 on x64 only
        A_PtrSize + ; HDC           hdcDst      0 + A_PtrSize * 3
        4 +         ; int           x           0 + A_PtrSize * 4
        4 +         ; int           y           4 + A_PtrSize * 4
        4 +         ; int           cx          8 + A_PtrSize * 4
        4 +         ; int           cy          12 + A_PtrSize * 4
        4 +         ; int           xBitmap     16 + A_PtrSize * 4
        4 +         ; int           yBitmap     20 + A_PtrSize * 4
        4 +         ; COLORREF      rgbBk       24 + A_PtrSize * 4
        4 +         ; COLORREF      rgbFg       28 + A_PtrSize * 4
        4 +         ; UINT          fStyle      32 + A_PtrSize * 4
        4 +         ; DWORD         dwRop       36 + A_PtrSize * 4
        4 +         ; DWORD         fState      40 + A_PtrSize * 4
        4 +         ; DWORD         Frame       44 + A_PtrSize * 4
        A_PtrSize   ; COLORREF      crEffect    48 + A_PtrSize * 4    +4 on x64 only
        proto.offset_cbSize    := 0
        proto.offset_himl      := 0 + A_PtrSize * 1
        proto.offset_i         := 0 + A_PtrSize * 2
        proto.offset_hdcDst    := 0 + A_PtrSize * 3
        proto.offset_x         := 0 + A_PtrSize * 4
        proto.offset_y         := 4 + A_PtrSize * 4
        proto.offset_cx        := 8 + A_PtrSize * 4
        proto.offset_cy        := 12 + A_PtrSize * 4
        proto.offset_xBitmap   := 16 + A_PtrSize * 4
        proto.offset_yBitmap   := 20 + A_PtrSize * 4
        proto.offset_rgbBk     := 24 + A_PtrSize * 4
        proto.offset_rgbFg     := 28 + A_PtrSize * 4
        proto.offset_fStyle    := 32 + A_PtrSize * 4
        proto.offset_dwRop     := 36 + A_PtrSize * 4
        proto.offset_fState    := 40 + A_PtrSize * 4
        proto.offset_Frame     := 44 + A_PtrSize * 4
        proto.offset_crEffect  := 48 + A_PtrSize * 4
    }
    cbSize {
        Get => NumGet(this.Buffer, this.offset_cbSize, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_cbSize)
        }
    }
    himl {
        Get => NumGet(this.Buffer, this.offset_himl, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_himl)
        }
    }
    i {
        Get => NumGet(this.Buffer, this.offset_i, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_i)
        }
    }
    hdcDst {
        Get => NumGet(this.Buffer, this.offset_hdcDst, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hdcDst)
        }
    }
    x {
        Get => NumGet(this.Buffer, this.offset_x, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_x)
        }
    }
    y {
        Get => NumGet(this.Buffer, this.offset_y, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_y)
        }
    }
    cx {
        Get => NumGet(this.Buffer, this.offset_cx, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cx)
        }
    }
    cy {
        Get => NumGet(this.Buffer, this.offset_cy, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cy)
        }
    }
    xBitmap {
        Get => NumGet(this.Buffer, this.offset_xBitmap, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_xBitmap)
        }
    }
    yBitmap {
        Get => NumGet(this.Buffer, this.offset_yBitmap, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_yBitmap)
        }
    }
    rgbBk {
        Get => NumGet(this.Buffer, this.offset_rgbBk, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_rgbBk)
        }
    }
    rgbFg {
        Get => NumGet(this.Buffer, this.offset_rgbFg, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_rgbFg)
        }
    }
    fStyle {
        Get => NumGet(this.Buffer, this.offset_fStyle, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_fStyle)
        }
    }
    dwRop {
        Get => NumGet(this.Buffer, this.offset_dwRop, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_dwRop)
        }
    }
    fState {
        Get => NumGet(this.Buffer, this.offset_fState, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_fState)
        }
    }
    Frame {
        Get => NumGet(this.Buffer, this.offset_Frame, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_Frame)
        }
    }
    crEffect {
        Get => NumGet(this.Buffer, this.offset_crEffect, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_crEffect)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TvInsertStruct extends TvItem {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol            Offset                Padding
        A_PtrSize + ; HTREEITEM    hParent           0
        A_PtrSize + ; HTREEITEM    hInsertAfter      0 + A_PtrSize * 1
        A_PtrSize + ; UINT         mask              0 + A_PtrSize * 2     +4 on x64 only
        A_PtrSize + ; HTREEITEM    hItem             0 + A_PtrSize * 3
        4 +         ; UINT         state             0 + A_PtrSize * 4
        4 +         ; UINT         stateMask         4 + A_PtrSize * 4
        A_PtrSize + ; LPWSTR       pszText           8 + A_PtrSize * 4
        4 +         ; int          cchTextMax        8 + A_PtrSize * 5
        4 +         ; int          iImage            12 + A_PtrSize * 5
        4 +         ; int          iSelectedImage    16 + A_PtrSize * 5
        4 +         ; int          cChildren         20 + A_PtrSize * 5
        A_PtrSize   ; LPARAM       lParam            24 + A_PtrSize * 5
        proto.offset_hParent         := 0
        proto.offset_hInsertAfter    := 0 + A_PtrSize * 1
        proto.offset_mask            := 0 + A_PtrSize * 2
        proto.offset_hItem           := 0 + A_PtrSize * 3
        proto.offset_state           := 0 + A_PtrSize * 4
        proto.offset_stateMask       := 4 + A_PtrSize * 4
        proto.offset_pszText         := 8 + A_PtrSize * 4
        proto.offset_cchTextMax      := 8 + A_PtrSize * 5
        proto.offset_iImage          := 12 + A_PtrSize * 5
        proto.offset_iSelectedImage  := 16 + A_PtrSize * 5
        proto.offset_cChildren       := 20 + A_PtrSize * 5
        proto.offset_lParam          := 24 + A_PtrSize * 5
    }
    hParent {
        Get => NumGet(this.Buffer, this.offset_hParent, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hParent)
        }
    }
    hInsertAfter {
        Get => NumGet(this.Buffer, this.offset_hInsertAfter, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hInsertAfter)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TvItem extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol            Offset                Padding
        A_PtrSize + ; UINT         mask              0                     +4 on x64 only
        A_PtrSize + ; HTREEITEM    hItem             0 + A_PtrSize * 1
        4 +         ; UINT         state             0 + A_PtrSize * 2
        4 +         ; UINT         stateMask         4 + A_PtrSize * 2
        A_PtrSize + ; LPWSTR       pszText           8 + A_PtrSize * 2
        4 +         ; int          cchTextMax        8 + A_PtrSize * 3
        4 +         ; int          iImage            12 + A_PtrSize * 3
        4 +         ; int          iSelectedImage    16 + A_PtrSize * 3
        4 +         ; int          cChildren         20 + A_PtrSize * 3
        A_PtrSize   ; LPARAM       lParam            24 + A_PtrSize * 3
        proto.offset_mask            := 0
        proto.offset_hItem           := 0 + A_PtrSize * 1
        proto.offset_state           := 0 + A_PtrSize * 2
        proto.offset_stateMask       := 4 + A_PtrSize * 2
        proto.offset_pszText         := 8 + A_PtrSize * 2
        proto.offset_cchTextMax      := 8 + A_PtrSize * 3
        proto.offset_iImage          := 12 + A_PtrSize * 3
        proto.offset_iSelectedImage  := 16 + A_PtrSize * 3
        proto.offset_cChildren       := 20 + A_PtrSize * 3
        proto.offset_lParam          := 24 + A_PtrSize * 3
        proto.__pszText := ''
    }
    GetStateImageIndex() {
        return (this.state & TVIS_STATEIMAGEMASK) >> 12
    }
    SetBold(Value := true) {
        this.mask := this.mask | TVIF_STATE
        if Value {
            this.state := this.state | TVIS_BOLD
        }
        this.stateMask := this.stateMask | TVIS_BOLD
    }
    SetChecked(Value := true) {
        this.SetStateImage(Value ? 2 : 1)
    }
    SetExpand(Value := true) {
        this.mask := this.mask | TVIF_STATE
        if Value {
            this.state := this.state | TVIS_EXPANDED
        }
        this.stateMask := this.stateMask | TVIS_EXPANDED
    }
    SetTextBuffer(Bytes := TVEX_DEFAULT_TEXT_MAX * 2) {
        this.__pszText := Buffer(Bytes)
        this.cchTextMax := Floor(Bytes / 2)
        NumPut('ptr', this.__pszText.Ptr, this.Buffer, this.offset_pszText)
    }
    SetSelected(Value := true) {
        this.mask := this.mask | TVIF_STATE
        if Value {
            this.state := this.state | TVIS_SELECTED
        }
        this.stateMask := this.stateMask | TVIS_SELECTED
    }
    SetStateImage(Index) {
        if Index < 0 || Index > 15 {
            throw ValueError('Invalid index.', -1, Index)
        }
        this.mask := this.mask | TVIF_STATE
        this.stateMask := this.stateMask | TVIS_STATEIMAGEMASK
        this.state := (this.state & ~TVIS_STATEIMAGEMASK) | (index << 12)
    }
    mask {
        Get => NumGet(this.Buffer, this.offset_mask, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_mask)
        }
    }
    hItem {
        Get => NumGet(this.Buffer, this.offset_hItem, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hItem)
        }
    }
    state {
        Get => NumGet(this.Buffer, this.offset_state, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_state)
        }
    }
    stateMask {
        Get => NumGet(this.Buffer, this.offset_stateMask, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_stateMask)
        }
    }
    pszText {
        Get {
            Value := NumGet(this.Buffer, this.offset_pszText, 'ptr')
            if Value > 0 {
                return StrGet(Value, TVEX_DEFAULT_ENCODING)
            } else {
                return Value
            }
        }
        Set {
            if Value == LPSTR_TEXTCALLBACKW {
                NumPut('ptr', Value, this.Buffer, this.offset_pszText)
            } else {
                if ptr := NumGet(this.Buffer, this.offset_pszText, 'ptr') {
                    if this.__pszText {
                        bytes := StrPut(Value, TVEX_DEFAULT_ENCODING)
                        if bytes > this.__pszText.Size {
                            this.__pszText.Size := bytes
                            ptr := this.__pszText.Ptr
                            NumPut('ptr', ptr, this.Buffer, this.offset_pszText)
                        }
                    }
                } else {
                    this.__pszText := Buffer(StrPut(Value, TVEX_DEFAULT_ENCODING))
                    ptr := this.__pszText.Ptr
                    NumPut('ptr', ptr, this.Buffer, this.offset_pszText)
                }
                if chars := this.cchTextMax {
                    StrPut(SubStr(Value, 1, chars - 1), ptr, TVEX_DEFAULT_ENCODING)
                } else {
                    StrPut(Value, ptr, TVEX_DEFAULT_ENCODING)
                }
            }
        }
    }
    cchTextMax {
        Get => NumGet(this.Buffer, this.offset_cchTextMax, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cchTextMax)
        }
    }
    iImage {
        Get => NumGet(this.Buffer, this.offset_iImage, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iImage)
        }
    }
    iSelectedImage {
        Get => NumGet(this.Buffer, this.offset_iSelectedImage, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iSelectedImage)
        }
    }
    cChildren {
        Get => NumGet(this.Buffer, this.offset_cChildren, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_cChildren)
        }
    }
    lParam {
        Get => NumGet(this.Buffer, this.offset_lParam, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lParam)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TvItemChange extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol       Offset               Padding
        A_PtrSize + ; HWND         hwndFrom     0
        A_PtrSize + ; UINT_PTR     idFrom       0 + A_PtrSize * 1
        A_PtrSize + ; UINT         code         0 + A_PtrSize * 2    +4 on x64 only
        A_PtrSize + ; UINT         uChanged     0 + A_PtrSize * 3    +4 on x64 only
        A_PtrSize + ; HTREEITEM    hItem        0 + A_PtrSize * 4
        4 +         ; UINT         uStateNew    0 + A_PtrSize * 5
        4 +         ; UINT         uStateOld    4 + A_PtrSize * 5
        A_PtrSize   ; LPARAM       lParam       8 + A_PtrSize * 5
        proto.offset_hwndFrom   := 0
        proto.offset_idFrom     := 0 + A_PtrSize * 1
        proto.offset_code       := 0 + A_PtrSize * 2
        proto.offset_uChanged   := 0 + A_PtrSize * 3
        proto.offset_hItem      := 0 + A_PtrSize * 4
        proto.offset_uStateNew  := 0 + A_PtrSize * 5
        proto.offset_uStateOld  := 4 + A_PtrSize * 5
        proto.offset_lParam     := 8 + A_PtrSize * 5
    }
    hwndFrom {
        Get => NumGet(this.Buffer, this.offset_hwndFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwndFrom)
        }
    }
    idFrom {
        Get => NumGet(this.Buffer, this.offset_idFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_idFrom)
        }
    }
    code {
        Get => NumGet(this.Buffer, this.offset_code, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_code)
        }
    }
    code_int {
        Get => NumGet(this.Buffer, this.offset_code, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_code)
        }
    }
    uChanged {
        Get => NumGet(this.Buffer, this.offset_uChanged, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_uChanged)
        }
    }
    hItem {
        Get => NumGet(this.Buffer, this.offset_hItem, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hItem)
        }
    }
    uStateNew {
        Get => NumGet(this.Buffer, this.offset_uStateNew, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_uStateNew)
        }
    }
    uStateOld {
        Get => NumGet(this.Buffer, this.offset_uStateOld, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_uStateOld)
        }
    }
    lParam {
        Get => NumGet(this.Buffer, this.offset_lParam, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lParam)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TvItemEx extends TvItem {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type           Symbol            Offset                Padding
        A_PtrSize + ; UINT         mask              0                     +4 on x64 only
        A_PtrSize + ; HTREEITEM    hItem             0 + A_PtrSize * 1
        4 +         ; UINT         state             0 + A_PtrSize * 2
        4 +         ; UINT         stateMask         4 + A_PtrSize * 2
        A_PtrSize + ; LPWSTR       pszText           8 + A_PtrSize * 2
        4 +         ; int          cchTextMax        8 + A_PtrSize * 3
        4 +         ; int          iImage            12 + A_PtrSize * 3
        4 +         ; int          iSelectedImage    16 + A_PtrSize * 3
        4 +         ; int          cChildren         20 + A_PtrSize * 3
        A_PtrSize + ; LPARAM       lParam            24 + A_PtrSize * 3
        4 +         ; int          iIntegral         24 + A_PtrSize * 4
        4 +         ; UINT         uStateEx          28 + A_PtrSize * 4
        A_PtrSize + ; HWND         hwnd              32 + A_PtrSize * 4
        4 +         ; int          iExpandedImage    32 + A_PtrSize * 5
        4           ; int          iReserved         36 + A_PtrSize * 5
        proto.offset_mask            := 0
        proto.offset_hItem           := 0 + A_PtrSize * 1
        proto.offset_state           := 0 + A_PtrSize * 2
        proto.offset_stateMask       := 4 + A_PtrSize * 2
        proto.offset_pszText         := 8 + A_PtrSize * 2
        proto.offset_cchTextMax      := 8 + A_PtrSize * 3
        proto.offset_iImage          := 12 + A_PtrSize * 3
        proto.offset_iSelectedImage  := 16 + A_PtrSize * 3
        proto.offset_cChildren       := 20 + A_PtrSize * 3
        proto.offset_lParam          := 24 + A_PtrSize * 3
        proto.offset_iIntegral       := 24 + A_PtrSize * 4
        proto.offset_uStateEx        := 28 + A_PtrSize * 4
        proto.offset_hwnd            := 32 + A_PtrSize * 4
        proto.offset_iExpandedImage  := 32 + A_PtrSize * 5
        proto.offset_iReserved       := 36 + A_PtrSize * 5
    }
    __New(Members?) {
        this.Buffer := Buffer(this.cbSizeInstance, 0)
        this.iIntegral := 1
        if IsSet(Members) {
            b := this.Base
            while b {
                if b.HasOwnProp('StructureProps') {
                    for prop in b.StructureProps {
                        if HasProp(Members, prop) {
                            this.%prop% := Members.%prop%
                        }
                    }
                }
                b := b.Base
            }
        }
    }
    iIntegral {
        Get => NumGet(this.Buffer, this.offset_iIntegral, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iIntegral)
        }
    }
    uStateEx {
        Get => NumGet(this.Buffer, this.offset_uStateEx, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_uStateEx)
        }
    }
    hwnd {
        Get => NumGet(this.Buffer, this.offset_hwnd, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwnd)
        }
    }
    iExpandedImage {
        Get => NumGet(this.Buffer, this.offset_iExpandedImage, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iExpandedImage)
        }
    }
    iReserved {
        Get => NumGet(this.Buffer, this.offset_iReserved, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_iReserved)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TvKeyDown extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type          Symbol      Offset               Padding
        A_PtrSize + ; HWND        hwndFrom    0
        A_PtrSize + ; UINT_PTR    idFrom      0 + A_PtrSize * 1
        A_PtrSize + ; UINT        code        0 + A_PtrSize * 2    +4 on x64 only
        2 + 2 +     ; WORD        wVKey       0 + A_PtrSize * 3    + 2
        4           ; UINT        flags       4 + A_PtrSize * 3
        proto.offset_hwndFrom  := 0
        proto.offset_idFrom    := 0 + A_PtrSize * 1
        proto.offset_code      := 0 + A_PtrSize * 2
        proto.offset_wVKey     := 0 + A_PtrSize * 3
        proto.offset_flags     := 4 + A_PtrSize * 3
    }
    hwndFrom {
        Get => NumGet(this.Buffer, this.offset_hwndFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwndFrom)
        }
    }
    idFrom {
        Get => NumGet(this.Buffer, this.offset_idFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_idFrom)
        }
    }
    code {
        Get => NumGet(this.Buffer, this.offset_code, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_code)
        }
    }
    code_int {
        Get => NumGet(this.Buffer, this.offset_code, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_code)
        }
    }
    wVKey {
        Get => NumGet(this.Buffer, this.offset_wVKey, 'ushort')
        Set {
            NumPut('ushort', Value, this.Buffer, this.offset_wVKey)
        }
    }
    flags {
        Get => NumGet(this.Buffer, this.offset_flags, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_flags)
        }
    }
}


class TvNmHdr extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type          Symbol      Offset               Padding
        A_PtrSize + ; HWND        hwndFrom    0
        A_PtrSize + ; UINT_PTR    idFrom      0 + A_PtrSize * 1
        A_PtrSize   ; UINT        code        0 + A_PtrSize * 2    +4 on x64 only
        proto.offset_hwndFrom  := 0
        proto.offset_idFrom    := 0 + A_PtrSize * 1
        proto.offset_code      := 0 + A_PtrSize * 2

        proto.Collection := Map()
        proto.Collection.Default := 0
        proto.Collection.Set(
            TVN_ASYNCDRAW, TvAsyncDraw
          , TVN_BEGINDRAGW, NmTreeView
          , TVN_BEGINLABELEDITW, TvDispInfoEx
          , TVN_BEGINRDRAGW, NmTreeView
          , TVN_DELETEITEMW, NmTreeView
          , TVN_ENDLABELEDITW, TvDispInfoEx
          , TVN_GETDISPINFOW, TvDispInfoEx
          , TVN_GETINFOTIPW, TvGetInfoTip
          , TVN_ITEMCHANGEDW, TvItemChange
          , TVN_ITEMCHANGINGW, TvItemChange
          , TVN_ITEMEXPANDEDW, NmTreeView
          , TVN_ITEMEXPANDINGW, NmTreeView
          , TVN_KEYDOWN, TvKeyDown
          , TVN_SELCHANGEDW, NmTreeView
          , TVN_SELCHANGINGW, NmTreeView
          , TVN_SETDISPINFOW, TvDispInfoEx
          , TVN_SINGLEEXPAND, NmTreeView
          , NM_CUSTOMDRAW, NmTvCustomDraw
        )
    }
    Cast() {
        if cls := this.Collection.Get(this.code_int) {
            return cls.FromPtr(this.ptr)
        } else {
            return this
        }
    }
    hwndFrom {
        Get => NumGet(this.Buffer, this.offset_hwndFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hwndFrom)
        }
    }
    idFrom {
        Get => NumGet(this.Buffer, this.offset_idFrom, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_idFrom)
        }
    }
    code {
        Get => NumGet(this.Buffer, this.offset_code, 'uint')
        Set {
            NumPut('uint', Value, this.Buffer, this.offset_code)
        }
    }
    code_int {
        Get => NumGet(this.Buffer, this.offset_code, 'int')
        Set {
            NumPut('int', Value, this.Buffer, this.offset_code)
        }
    }
}

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx
    Author: Nich-Cebolla
    License: MIT
*/

class TvSortCb extends TreeViewExStructBase {
    static __New() {
        this.DeleteProp('__New')
        this.__GetStructureProps()
        proto := this.Prototype
        proto.cbSizeInstance :=
        ; Size      Type              Symbol         Offset               Padding
        A_PtrSize + ; HTREEITEM       hParent        0
        A_PtrSize + ; PFNTVCOMPARE    lpfnCompare    0 + A_PtrSize * 1
        A_PtrSize   ; LPARAM          lParam         0 + A_PtrSize * 2
        proto.offset_hParent      := 0
        proto.offset_lpfnCompare  := 0 + A_PtrSize * 1
        proto.offset_lParam       := 0 + A_PtrSize * 2
    }
    hParent {
        Get => NumGet(this.Buffer, this.offset_hParent, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_hParent)
        }
    }
    lpfnCompare {
        Get => NumGet(this.Buffer, this.offset_lpfnCompare, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lpfnCompare)
        }
    }
    lParam {
        Get => NumGet(this.Buffer, this.offset_lParam, 'ptr')
        Set {
            NumPut('ptr', Value, this.Buffer, this.offset_lParam)
        }
    }
}

; https://github.com/Nich-Cebolla/AutoHotkey-MenuEx

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-MenuEx
    Author: Nich-Cebolla
    License: MIT
*/

/**
 * `MenuEx` is a composotion of AHK's native `Menu` class. The purpose of `MenuEx` is to provide a
 * standardized system for creating, modifying, and using a menu. For each item added to the menu,
 * an associated {@link MenuExItem} is created and added to the collection. The `MenuExItem` instances
 * can be accessed by name from the `MenuEx` instance, and the `MenuExItem` instance's properties can
 * be modified to change the characteristics of the menu item.
 *
 * ## Context Menu
 *
 * Though `MenuEx` is useful for any menu, I designed it with a focus on functionality related to
 * context menus. When creating a context menu with `MenuEx`, the `MenuEx` instance will have a
 * method "Call" which activates the context menu. To use, simply pass the `MenuEx` object to the
 * event handler for the gui or control.
 *
 * @example
 *  g := Gui()
 *  MenuExObj := MenuEx(Menu())
 *  g.OnEvent('ContextMenu', MenuExObj) ; pass `MenuExObj` to event handler
 * @
 *
 * Or
 *
 * @example
 *  g := Gui()
 *  g.Add('TreeView', 'w100 r10 vTv')
 *  MenuExObj := MenuEx(Menu())
 *  g['Tv'].OnEvent('ContextMenu', MenuExObj) ; pass `MenuExObj` to event handler
 * @
 *
 * ## Extending MenuEx
 *
 * `MenuEx` was designed with object inheritance in mind. One benefit of using `MenuEx` over
 * using `Menu` directly is it makes it easy to share menu items between menus and between scripts.
 *
 * Inheriting from `MenuEx` involves 1-4 steps. See the example in file
 * "test\demo-TreeView-context-menu.ahk" for a working example of each of these steps.
 *
 * 1. (Required) Define default items.
 *
 * To define default items, your class should define a static method "__New" that adds a property
 * "DefaultItems" to the prototype. "DefaultItems" is an array of objects, each object with required
 * properties { Name, Value } and optional properties { Options, Tooltip }.
 * - Name: The name of the menu item. This is used across the `MenuEx` class and related classes. It
 *   is the name that is used to get a reference to the `MenuExItem` instance associated with the
 *   menu item, e.g. `MenuExObj.Get("ItemName")`. It is also the text that is displayed in the menu
 *   for that item.
 * - Value: "Value" can be defined with three types of values.
 *   - A `Menu` object, if the menu item is a submenu.
 *   - A `Func` or callable object that will be called when the user selects the item.
 *   - A string representing the name of a class instance method defined by your custom class which
 *     inherits from `MenuEx` (see the "test\demo-TreeView-context-menu.ahk" for an example).
 * - Options: Any options as described in {@link https://www.autohotkey.com/docs/v2/lib/Menu.htm#Add}.
 * - Tooltip: A value as described by {@link MenuExItem.Prototype.SetTooltipHandler}
 *
 * 2. (Optional) Define "Initialize".
 *
 * "Initialize" is called once for every new instance of {@link MenuEx} / every new instance of a
 * class that inherits from {@link MenuEx} (unless the inheritor overrides "__New"). This allows your
 * code to include any initialization tasks without needing to redefine the "__New" method.
 *
 * {@link MenuEx.Prototype.__New} handles adding the default items (as described above) to the menu,
 * so your code only needs to define an "Initialize" method if there are some other initialization
 * tasks required for instances of your menu class to work.
 *
 *   - Parameters:
 *     1. {MenuEx.Options} The options object after it has been processed by
 *       {@link MenuEx.Options.Prototype.__New}.
 *   - The return value is ignored.
 *
 * 3. (Optional) Define instance methods.
 *
 * Though not strictly necessary, your class that inherits from {@link MenuEx} can define the menu
 * functions as instance methods, as seen in the demo test\demo-TreeView-context-menu.ahk. This allows
 * you to define the "Value" property of the menu item objects with the string name of the method.
 *
 * 4. (Optional) Define an item availability handler.
 *
 * It is often appropriate to adjust the availability of one or more menu items depending on the
 * context in which a context menu is activated. The item availability handler is only used when the
 * menu is a context menu (more specifically, the item availability handler is only used when
 * {@link MenuEx.Prototype.SetEventHandler} is called with a value of `1` or `2`).
 *
 * Define the item availability handler as an instance method "HandlerItemAvailability".
 *
 */
class MenuEx {
    static __New() {
        this.DeleteProp('__New')
        MenuEx_SetConstants()
        proto := this.Prototype
        proto.__HandlerSelection := proto.__HandlerItemAvailability := proto.Token :=
        proto.__HandlerTooltip := ''
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/menurc/wm-changeuistate}
     *
     * @param {Integer} Handle - The handle of the window to receive the message. This would typically
     * be the parent window so all child windows can have the same UI state, but in the context of
     * an AHK menu `Hwnd` can also be the menu's handle, i.e. `MenuObj.Handle`.
     *
     * @param {Integer} Action - One of the following:
     * - UIS_CLAS - The UI state flags specified by the high-order word should be cleared.
     * - UIS_INITIALIZE - The UI state flags specified by the high-order word should be changed
     *   based on the last input event. For more information, see Remarks.
     * - UIS_SET - The UI state flags specified by the high-order word should be set.
     *
     * @param {Integer} State - One or more of the following. Combine with bitwise "or" ( | ),
     * e.g. `State := UISF_ACTIVE | UISF_HIDEACCEL`.
     * - UISF_ACTIVE - A control should be drawn in the style used for active controls.
     * - UISF_HIDEACCEL - Keyboard accelerators are hidden.
     * - UISF_HIDEFOCUS - Focus indicators are hidden.
     */
    static ChangeUiState(Handle, Action, State) {
        SendMessage(WM_CHANGEUISTATE, (State & 0xFFFF) << 16 | (Action & 0xFFFF), 0, , Handle)
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/menurc/wm-queryuistate}
     *
     * @param {Integer} Handle - The handle of the window to receive the message.
     *
     * @param {VarRef} [OutActive] - A variable that will receive either:
     * - 0 if the UISF_ACTIVE flag was not included in the return value.
     * - 1 if the UISF_ACTIVE flag was included in the return value.
     *
     * @param {VarRef} [OutAccel] - A variable that will receive either:
     * - 0 if the UISF_HIDEACCEL flag was not included in the return value. This would indicate
     *   that keyboard accelerators are visible.
     * - 1 if the UISF_HIDEACCEL flag was included in the return value. This would indicate that
     *   keyboard accelerators are hidden.
     *
     * @param {VarRef} [OutFocus] - A variable that will receive either:
     * - 0 if the UISF_HIDEFOCUS flag was not included in the return value.  This would indicate
     *   that focus indicators are visible.
     * - 1 if the UISF_HIDEFOCUS flag was included in the return value. This would indicate that
     *   focus indicators are hidden.
     */
    static QueryUiState(Handle, &OutActive?, &OutAccel?, &OutFocus?) {
        if value := SendMessage(WM_QUERYUISTATE, 0, 0, , Handle) {
            OutActive := value & UISF_ACTIVE
            OutAccel := value & UISF_HIDEACCEL
            OutFocus := value & UISF_HIDEFOCUS
        } else {
            OutActive := OutAccel := OutFocus := 0
        }
    }
    /**
     * {@link https://learn.microsoft.com/en-us/windows/win32/menurc/wm-updateuistate}
     *
     * @param {Integer} Handle - The handle of the window to receive the message. This would typically
     * be the parent window so all child windows can have the same UI state, but in the context of
     * an AHK menu `Hwnd` can also be the menu's handle, i.e. `MenuObj.Handle`.
     *
     * @param {Integer} Action - One of the following:
     * - UIS_CLAS - The UI state flags specified by the high-order word should be cleared.
     * - UIS_INITIALIZE - The UI state flags specified by the high-order word should be changed
     *   based on the last input event. For more information, see Remarks.
     * - UIS_SET - The UI state flags specified by the high-order word should be set.
     *
     * @param {Integer} State - One or more of the following. Combine with bitwise "or" ( | ),
     * e.g. `State := UISF_ACTIVE | UISF_HIDEACCEL`.
     * - UISF_ACTIVE - A control should be drawn in the style used for active controls.
     * - UISF_HIDEACCEL - Keyboard accelerators are hidden.
     * - UISF_HIDEFOCUS - Focus indicators are hidden.
     */
    static UpdateUiState(Handle, Action, State) {
        SendMessage(WM_UPDATEUISTATE, (State & 0xFFFF) << 16 | (Action & 0xFFFF), 0, , Handle)
    }
    /**
     * @param {Menu|MenuBar} [MenuObj] - The menu object. If unset, a new instance of `Menu` is created.
     *
     * @param {Object} [Options] - An object with zero or more options as property : value pairs.
     *
     * @param {Boolean} [Options.CaseSense = false] - If true, the collection is case-sensitive. This
     * means that accessing menu items from the collection by name is case-sensitive.
     *
     * @param {*} [Options.HandlerTooltip = ""] - See {@link MenuEx.Prototype.SetTooltipHandler~Callback}.
     *
     * @param {*} [Options.HandlerSelection = ""] - See {@link MenuEx.Prototype.SetSelectionHandler~Callback}.
     *
     * @param {Boolean} [Options.ShowTooltips = false] - If true, enables tooltip functionality.
     * `MenuEx`'s tooltip functionality allows you to define your menu and related options to
     * display a tooltip when the user selects a menu item. See {@link MenuExItem.Prototype.SetTooltipHandler}
     * for details and see file "test\demo-TreeView-context-menu.ahk" for a working example.
     *
     * @param {Integer} [Options.WhichMethod = 1] - `Options.WhichMethod` is passed directly to
     * method {@link MenuEx.Prototype.SetEventHandler}. See the description for details.
     *
     * @param {Object} [Options.TooltipDefaultOptions = ""] - The value passed to the second parameter
     * of {@link MenuEx.TooltipHandler} when creating the tooltip handler function object. If
     * `Options.HandlerTooltip` is set with a function, then `Options.TooltipDefaultOptions` is
     * ignored.
     *
     * @param {*} [Options.HandlerItemAvailability = ""] - See
     * {@link MenuEx.Prototype.SetItemAvailabilityHandler~Callback}.
     */
    __New(MenuObj?, Options?) {
        this.Menu := MenuObj ?? Menu()
        options := MenuEx.Options(Options ?? unset)
        this.SetSelectionHandler(options.HandlerSelection || unset)
        this.SetTooltipHandler(options.HandlerTooltip || unset, options.TooltipDefaultOptions || unset)
        this.SetEventHandler(options.WhichMethod)
        this.SetItemAvailabilityHandler(options.HandlerItemAvailability)
        this.ShowTooltips := options.ShowTooltips
        this.__Item := MenuExItemCollection()
        this.__Item.CaseSense := options.CaseSense
        this.Constructor := Class()
        this.Constructor.Base := MenuExItem
        this.Constructor.Prototype := {
            MenuEx: this
          , __Class: MenuExItem.Prototype.__Class
        }
        ObjSetBase(this.Constructor.Prototype, MenuExItem.Prototype)
        ObjRelease(ObjPtr(this))
        if HasProp(this, 'DefaultItems') {
            this.AddObjectList(this.DefaultItems)
        }
        if HasMethod(this, 'Initialize') {
            this.Initialize(options)
        }
    }
    /**
     * @param {String} Name - The name of the menu item. This is used across the {@link MenuEx} class
     * and related classes. It is the name that is used to get a reference to the {@link MenuExItem}
     * instance associated with the menu item, e.g. `MenuExObj.Get("ItemName")`. It is also the text
     * that is displayed in the menu for that item. It is also the value assigned to the "__Name"
     * property of the {@link MenuExItem} instance.
     *
     * @param {*} CallbackOrSubmenu - One of the following:
     * - A `Menu` object, if the menu item is a submenu.
     * - A `Func` or callable object that will be called when the user selects the item.
     * - A string representing the name of a class instance method defined by your custom class which
     *   inherits from `MenuEx` (see the "test\demo-TreeView-context-menu.ahk" for an example).
     *
     * The value of `CallbackOrSubmenu` is assigned to the "__Value" property of the {@link MenuExItem}
     * instance.
     *
     * @param {String} [Options] - The options as described in
     * {@link https://www.autohotkey.com/docs/v2/lib/Menu.htm#Add}.
     *
     * @param {*} [HandlerTooltip] - The tooltip handler options as described in
     * {@link MenuExItem.Prototype.SetTooltipHandler}.
     *
     * @returns {MenuExItem}
     */
    Add(Name, CallbackOrSubmenu, Options?, HandlerTooltip?) {
        this.Menu.Add(Name, this.__HandlerSelection, Options ?? unset)
        this.__Item.Set(Name, this.Constructor.Call(Name, CallbackOrSubmenu, Options ?? unset, HandlerTooltip ?? unset))
        return this.__Item.Get(Name)
    }
    /**
     * "AddList" should be used only if the menu which originally was associated with the items no
     * longer exists. To copy items from one menu to another, use "AddObjectList" instead.
     * @param {MenuExItem[]} Items - An array of {@link MenuExItem} objects. For each item in the
     * array, the base of the item is changed to {@link MenuEx#Constructor.Prototype} and the item
     * is added to the menu.
     */
    AddList(Items) {
        container := this.__Item
        proto := this.Constructor.Prototype
        m := this.Menu
        for item in items {
            ObjSetBase(item, proto)
            container.Set(item.__Name, item)
            m.Add(item.__Name, item.__Value, item.__Options || unset)
        }
    }
    /**
     * @param {Object} Obj - An object with parameters as property : value pairs.
     * - Name: The name of the menu item. This is the value passed to the first parameter "Name" of
     *   {@link MenuEx.Prototype.Add} and is the value that is set to property "__Name"
     *   of the {@link MenuExItem} instance.
     * - Value: The value of the menu item; this is the value passed to the second parameter
     *   "CallbackOrSubmenu" of {@link MenuEx.Prototype.Add} and is the value that is set to property
     *   "__Value" of the {@link MenuExItem} instance.
     * - Options: The options for the menu item. This is the value passed to the third parameter
     *   "Options" of {@link MenuEx.Prototype.Add} and is the value that is set to property
     *   "__Options" of the {@link MenuExItem} instance.
     * - Tooltip: The tooltip options for the menu item. This is the value passed to the fourth parameter
     *   "HandlerTooltip" of {@link MenuEx.Prototype.Add} and is the value that is set to property
     *   "__HandlerTooltip" of the {@link MenuExItem} instance.
     * @returns {MenuExItem}
     */
    AddObject(Obj) {
        return this.Add(
            Obj.Name
          , Obj.Value
          , HasProp(Obj, 'Options') ? (Obj.Options || unset) : unset
          , HasProp(Obj, 'Tooltip') ? (Obj.Tooltip || unset) : unset
        )
    }
    /**
     * @param {Object[]|MenuExItem[]} Objs - An array of objects as described by {@link MenuEx.Prototype.AddObject},
     * or an array of {@link MenuExItem} instance objects.
     */
    AddObjectList(Objs) {
        m := this.Menu
        items := this.__Item
        constructor := this.Constructor
        handlerSelection := this.__HandlerSelection
        for obj in Objs {
            m.Add(obj.Name, handlerSelection, HasProp(Obj, 'Options') ? (Obj.Options || '') : unset)
            items.Set(obj.Name, constructor(
                obj.Name
              , obj.Value
              , HasProp(Obj, 'Options') ? (Obj.Options || unset) : unset
              , HasProp(Obj, 'Tooltip') ? (Obj.Tooltip || unset) : unset
            ))
        }
    }
    Delete(Name) {
        this.Menu.Delete(Name)
        this.__Item.Delete(Name)
    }
    DeleteList(Names) {
        m := this.Menu
        items := this.__Item
        for name in Names {
            m.Delete(name)
            items.Delete(name)
        }
    }
    DeletePattern(NamePattern) {
        m := this.Menu
        items := this.__Item
        names := []
        for name in items {
            if RegExMatch(name, NamePattern) {
                names.Push(name)
            }
        }
        for name in names {
            m.Delete(name)
            items.Delete(name)
        }
    }
    Get(Name) => this.__Item.Get(Name)
    Has(Name) => this.__Item.Has(Name)
    /**
     * @param {String|Integer} InsertBefore - The name or position of the menu item before which to
     * insert the new menu item.
     *
     * @param {String} Name - The name of the menu item. This is used across the {@link MenuEx} class
     * and related classes. It is the name that is used to get a reference to the {@link MenuExItem}
     * instance associated with the menu item, e.g. `MenuExObj.Get("ItemName")`. It is also the text
     * that is displayed in the menu for that item.
     *
     * @param {*} CallbackOrSubmenu - One of the following:
     * - A `Menu` object, if the menu item is a submenu.
     * - A `Func` or callable object that will be called when the user selects the item.
     * - A string representing the name of a class instance method defined by your custom class which
     *   inherits from `MenuEx` (see the "test\demo-TreeView-context-menu.ahk" for an example).
     *
     * @param {String} [Options] - The options as described in
     * {@link https://www.autohotkey.com/docs/v2/lib/Menu.htm#Add}.
     *
     * @param {*} [HandlerTooltip] - The tooltip handler options as described in
     * {@link MenuExItem.Prototype.SetTooltipHandler}.
     *
     * @returns {MenuExItem}
     */
    Insert(InsertBefore, Name, CallbackOrSubmenu, Options?, HandlerTooltip?) {
        this.Menu.Insert(InsertBefore, Name, CallbackOrSubmenu, Options ?? unset)
        this.__Item.Set(Name, this.Constructor.Call(Name, CallbackOrSubmenu, Options ?? unset, HandlerTooltip ?? unset))
        return this.__Item.Get(Name)
    }
    /**
     * "OnSelect" is the default selection handler that is called when the user selects a menu item.
     * Your code will not call "OnSelect" directly.
     * @param {String} Name - The name of the menu item that was selected.
     * @param {Integer} ItemPos - The item position of the menu item that was selected.
     * @param {Menu} MenuObj - The menu object associated wit hthe menu item that was selected.
     */
    OnSelect(Name, ItemPos, MenuObj) {
        if item := this.__Item.Get(Name) {
            if token := this.Token {
                this.Token := ''
                if IsObject(item.__Value) {
                    result := item.__Value.Call(this, Name, ItemPos, MenuObj, token.Gui, token.Ctrl, token.Item)
                } else {
                    result := this.%item.__Value%(Name, ItemPos, MenuObj, token.Gui, token.Ctrl, token.Item)
                }
            } else {
                if IsObject(item.__Value) {
                    result := item.__Value.Call(this, Name, ItemPos, MenuObj)
                } else {
                    result := this.%item.__Value%(Name, ItemPos, MenuObj)
                }
            }
            if this.ShowTooltips {
                if IsObject(item.__HandlerTooltip) {
                    str := item.__HandlerTooltip.Call(this, result)
                    if !IsObject(str) && StrLen(str) {
                        this.__HandlerTooltip.Call(str)
                    }
                } else if item.__HandlerTooltip {
                    this.__HandlerTooltip.Call(item.__HandlerTooltip)
                } else if !IsObject(result) && StrLen(result) {
                    this.__HandlerTooltip.Call(result)
                }
            }
        } else {
            throw UnsetItemError('Item not found.', -1, Name)
        }
    }
    /**
     * See {@link https://www.autohotkey.com/docs/v2/lib/Menu.htm#SetColor}.
     */
    SetColor(ColorValue, ApplyToSubmenus := true) {
        this.Menu.SetColor(ColorValue, ApplyToSubmenus)
    }
    /**
     * @param {Integer} [Which = 0] - One of the following:
     * - 0: Use `0` when the menu is a `MenuBar` or a submenu. Generally, if the menu is not intended
     *   to be activated as a context menu, then `0` is appropriate.
     * - 1: Use `1` when the menu is activated as a context menu and the event handler is set to a
     *   control (not the gui).
     * - 2: Use `2` when the menu is activated as a context menu and the event handler is set to a
     *   gui window (not a control).
     */
    SetEventHandler(Which := 0) {
        if Which {
            this.DefineProp('Call', this.__GetOwner('__Call' Which))
        } else if this.HasOwnProp('Call') {
            this.DeleteProp('Call')
        }
    }
    /**
     * @param {*} [Callback] - A `Func` or callable object that is called prior to showing the menu,
     * intended to enable or disable menu items depending on the item that was underneath the cursor
     * when the use right-clicked, or the item that was selected when the user activated the
     * context menu. The item availability handler is only called if
     * {@link MenuEx.Prototype.SetEventHandler} was called with a value of `1` or `2`. If `Callback`
     * is unset, the value of property "__ItemAvailabilityHandle" is set with an empty string, which
     * causes the process to not call an item availability handler.
     */
    SetItemAvailabilityHandler(Callback?) {
        this.__HandlerItemAvailability := Callback ?? ''
    }
    /**
     * @param {*} [Callback] - A `Func` or callable object that is called when the user selects a
     * menu item. The `Callback` is unset, the selection handler is defined as the "OnSelect" method,
     * which should be suitable for most use cases.
     */
    SetSelectionHandler(Callback?) {
        if this.HasOwnProp('__HandlerSelection')
        && this.__HandlerSelection.HasOwnProp('Name')
        && this.__HandlerSelection.Name == this.OnSelect.Name ' (bound)' {
            if IsSet(Callback) {
                ObjPtrAddRef(this)
                this.__HandlerSelection := Callback
            } else {
                OutputDebug('The current selection handler is already set to ``' this.__HandlerSelection.Name '``.`n')
            }
        } else if IsSet(Callback) {
            this.__HandlerSelection := Callback
        } else {
            ; This creates a reference cycle.
            this.__HandlerSelection := ObjBindMethod(this, 'OnSelect')
            ObjRelease(ObjPtr(this))
            ; This is to identify that the object is the bound method (and thus requires handling
            ; the reference cycle).
            this.__HandlerSelection.DefineProp('Name', { Value: this.OnSelect.Name ' (bound)' })
        }
    }
    /**
     * @param {*} [Callback] - A `Func` or callable object that is called after the function associated
     * with a menu item returns. `Callback` is expected to display a tooltip informing the user of
     * the result of the action associated with the menu item the user selected. For details about
     * this process, see {@link MenuExItem.Prototype.SetTooltipHandler}. If `Callback` is unset,
     * the property "__HandlerTooltip" is set with an instance of
     * {@link MenuEx.TooltipHandler} which should be suitable for most use cases.
     * @param {Object} [DefaultOptions] - An object with property : value pairs representing the
     * options to pass to the {@link MenuEx.TooltipHandler} constructor.
     */
    SetTooltipHandler(Callback?, DefaultOptions?) {
        this.__HandlerTooltip := Callback ?? MenuEx.TooltipHandler(DefaultOptions ?? unset)
    }
    /**
     * See {@link https://www.autohotkey.com/docs/v2/lib/Menu.htm#Show}.
     */
    Show(X?, Y?) {
        this.Menu.Show(X ?? unset, Y ?? unset)
    }
    __Call1(Ctrl, Item, IsRightClick, X, Y) {
        this.Token := {
            Ctrl: Ctrl
          , Item: Item
          , Gui: Ctrl.Gui
        }
        if HasMethod(this, 'HandlerItemAvailability') {
            this.HandlerItemAvailability(Ctrl, IsRightClick, Item, X, Y)
        } else if IsObject(this.__HandlerItemAvailability) {
            this.__HandlerItemAvailability.Call(this, Ctrl, IsRightClick, Item, X, Y)
        }
        this.Menu.Show(X, Y)
    }
    __Call2(GuiObj, Ctrl, Item, IsRightClick, X, Y) {
        this.Token := {
            Ctrl: Ctrl
          , Gui: GuiObj
          , Item: Item
        }
        if HasMethod(this, 'HandlerItemAvailability') {
            this.HandlerItemAvailability(GuiObj, Ctrl, IsRightClick, Item, X, Y)
        } else if IsObject(this.__HandlerItemAvailability) {
            this.__HandlerItemAvailability.Call(this, GuiObj, Ctrl, IsRightClick, Item, X, Y)
        }
        CoordMode('Menu', 'Screen')
        this.Menu.Show(X, Y)
    }
    __Delete() {
        if this.HasOwnProp('Constructor')
        && this.Constructor.HasOwnProp('Prototype')
        && this.Constructor.Prototype.HasOwnProp('MenuEx') {
            ObjPtrAddRef(this)
            this.DeleteProp('Constructor')
        }
        if this.HasOwnProp('__HandlerSelection')
        && this.__HandlerSelection.HasOwnProp('Name')
        && this.__HandlerSelection.Name == this.OnSelect.Name ' (bound)' {
            ObjPtrAddRef(this)
            this.DeleteProp('__HandlerSelection')
        }
    }
    __Enum(VarCount) => this.__Item.__Enum(VarCount)
    __GetOwner(Prop, ReturnDesc := true) {
        b := this
        while b {
            if b.HasOwnProp(Prop) {
                break
            }
            b := b.Base
        }
        if !b {
            throw PropertyError('Property not found.', -1, Prop)
        }
        return ReturnDesc ? b.GetOwnPropDesc(Prop) : b
    }
    Capacity {
        Get => this.__Item.Capacity
        Set => this.__Item.Capacity := Value
    }
    CaseSense => this.__Item.CaseSense
    Count => this.__Item.Count
    IsMenuBar => this.Menu is MenuBar
    HandlerItemAvailability {
        Get => this.__HandlerItemAvailability
        Set => this.SetItemAvailabilityHandler(Value)
    }
    Handle => this.Menu.Handle
    HandlerSelection {
        Get => this.__HandlerSelection
        Set => this.SetSelectionHandler(Value)
    }
    HandlerTooltip {
        Get => this.__HandlerTooltip
        Set => this.SetTooltipHandler(Value)
    }

    class Options {
        static __New() {
            this.DeleteProp('__New')
            this.Prototype.Default := {
                CaseSense: false
              , HandlerItemAvailability: ''
              , HandlerSelection: ''
              , HandlerTooltip: ''
              , ShowTooltips: false
              , TooltipDefaultOptions: ''
              , WhichMethod: 1
            }
            this.Prototype.Options := ''
        }
        __New(Options?) {
            if IsSet(Options) {
                this.Options := Options
            }
        }
        __Get(Name, *) {
            if this.Options && HasProp(this.Options, Name) {
                return this.Options.%Name%
            } else {
                return this.Default.%Name%
            }
        }
    }

    class TooltipHandler {
        /**
         * By default, `MenuEx.TooltipHandler.Numbers` is an array with integers 1-20, and is used to track which
         * tooltip id numbers are available and which are in use. If tooltips are created from multiple
         * sources, then the list is invalid because it may not know about every existing tooltip. To
         * overcome this, `MenuEx.TooltipHandler.Numbers` can be set with an array that is shared by other objects,
         * sharing the pool of available id numbers.
         *
         * All instances of `MenuEx.TooltipHandler` will inherently draw from the same array, and so calling
         * `MenuEx.TooltipHandler.SetNumbersList` is unnecessary if the objects handling tooltip creation are all
         * `MenuEx.TooltipHandler` objects.
         */
        static SetNumbersList(List) {
            this.Numbers := List
        }
        static DefaultOptions := {
            Duration: 3000
          , X: 0
          , Y: 0
          , Mode: 'Mouse' ; Mouse / Absolute (M/A)
        }
        static Numbers := [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]

        /**
         * @param {Object} [DefaultOptions] - An object with zero or more options as property : value pairs.
         * These options are used when a corresponding option is not passed to {@link MenuEx.TooltipHandler.Prototype.Call}.
         * @param {Integer} [DefaultOptions.Duration = 2000] - The duration in milliseconds for which the
         * tooltip displayed. A value of 0 causes the tooltip to b e dislpayed indefinitely until
         * {@link MenuEx.TooltipHandler.Prototype.End} is called with the tooltip number. Negative and positive
         * values are treated the same.
         * @param {Integer} [DefaultOptions.X = 0] - If `DefaultOptions.Mode == "Mouse"` (or "M"), a number
         * of pixels to add to the X-coordinate. If `DefaultOptions.Mode == "Absolute"` (or "A"), the
         * X-coordinate relative to the screen.
         * @param {Integer} [DefaultOptions.Y = 0] - If `DefaultOptions.Mode == "Mouse"` (or "M"), a number
         * of pixels to add to the Y-coordinate. If `DefaultOptions.Mode == "Absolute"` (or "A"), the
         * Y-coordinate relative to the screen.
         * @param {String} [DefaultOptions.Mode = "Mouse"] - One of the following:
         * - "Mouse" or "M" - The tooltip is displayed near the mouse cursor.
         * - "Absolute" or "A" - The tooltip is displayed at the screen coordinates indicated by the
         * options.
         */
        __New(DefaultOptions?) {
            if IsSet(DefaultOptions) {
                o := this.DefaultOptions := {}
                d := MenuEx.TooltipHandler.DefaultOptions
                for p in d.OwnProps()  {
                    o.%p% := HasProp(DefaultOptions, p) ? DefaultOptions.%p% : d.%p%
                }
            } else {
                this.DefaultOptions := MenuEx.TooltipHandler.DefaultOptions.Clone()
            }
        }
        /**
         * @param {String} Str - The string to display.
         *
         * @param {Object} [Options] - An object with zero or more options as property : value pairs.
         * If a value is absent, the corresponding value from `TooltipHandlerObj.DefaultOptions` is used.
         * @param {Integer} [Options.Duration] - The duration in milliseconds for which the
         * tooltip displayed. A value of 0 causes the tooltip to b e dislpayed indefinitely until
         * {@link MenuEx.TooltipHandler.Prototype.End} is called with the tooltip number. Negative and positive
         * values are treated the same.
         * @param {Integer} [Options.X] - If `Options.Mode == "Mouse"` (or "M"), a number
         * of pixels to add to the X-coordinate. If `Options.Mode == "Absolute"` (or "A"), the
         * X-coordinate relative to the screen.
         * @param {Integer} [Options.Y] - If `Options.Mode == "Mouse"` (or "M"), a number
         * of piYels to add to the Y-coordinate. If `Options.Mode == "Absolute"` (or "A"), the
         * Y-coordinate relative to the screen.
         * @param {String} [Options.Mode] - One of the following:
         * - "Mouse" or "M" - The tooltip is displayed near the mouse cursor.
         * - "Absolute" or "A" - The tooltip is displayed at the screen coordinates indicated by the
         * options.
         *
         * @returns {Integer} - The tooltip number used for the tooltip. If the duration is 0, pass
         * the number to {@link MenuEx.TooltipHandler.Prototype.End} to end the tooltip. Otherwise, you do not need
         * to save the tooltip number, but the tooltip number can be used to target the tooltip when calling
         * `ToolTip`.
         */
        Call(Str, Options?) {
            if MenuEx.TooltipHandler.Numbers.Length {
                n := MenuEx.TooltipHandler.Numbers.Pop()
            } else {
                throw Error('The maximum number of concurrent tooltips has been reached.')
            }
            if IsSet(Options) {
                Get := _Get1
            } else {
                Get := _Get2
            }
            T := CoordMode('Tooltip', 'Screen')
            switch SubStr(Get('Mode'), 1, 1), 0 {
                case 'M':
                    M := CoordMode('Mouse', 'Screen')
                    MouseGetPos(&X, &Y)
                    ToolTip(Str, X + Get('X'), Y + Get('Y'), n)
                    SetTimer(ObjBindMethod(this, 'End', n), -Abs(Get('Duration')))
                    CoordMode('Mouse', M)
                case 'A':
                    ToolTip(Str, Get('X'), Get('Y'), n)
                    SetTimer(ObjBindMethod(this, 'End', n), -Abs(Get('Duration')))
            }
            CoordMode('Tooltip', T)

            return n

            _Get1(prop) {
                return HasProp(Options, prop) ? Options.%prop% : this.DefaultOptions.%prop%
            }
            _Get2(prop) {
                return this.DefaultOptions.%prop%
            }
        }
        End(n) {
            ToolTip(,,,n)
            MenuEx.TooltipHandler.Numbers.Push(n)
        }
        /**
         * @param {Object} [DefaultOptions] - An object with zero or more options as property : value pairs.
         * These options are used when a corresponding option is not passed to {@link MenuEx.TooltipHandler.Prototype.Call}.
         * The existing default options are overwritten with the new object.
         */
        SetDefaultOptions(DefaultOptions) {
            this.DefaultOptions := DefaultOptions
        }
    }
}

class MenuExItem {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.__Name := proto.__Value := proto.__Options := proto.__HandlerTooltip := ''
    }
    /**
     * @see {@link https://www.autohotkey.com/docs/v2/lib/Menu.htm#Add}.
     *
     * @param {String} Name - The text to display on the menu item. Although the AutoHotkey
     * documents indicate that, for `Menu.Prototype.Add`, the paramter `MenuItemName` can also be
     * the position of an existing item, that is not applicable here; only pass the name to this
     * parameter.
     *
     * @param {*} CallbackOrSubmenu - The function to call as a new thread when the menu item is
     * selected, or a reference to a Menu object to use as a submenu.
     *
     * Regarding functions:
     *
     * The function can be any callable object.
     *
     * If `CallbackOrSubmenu` is a function, then the function can accept the following parameters:
     * 1. {MenuEx} - The {@link MenuEx} instance.
     * 2. {String} - The name of the selected menu item.
     * 3. {Integer} - The position of the selected menu item (e.g. 1 is the first menu item, 2 is the second, etc.).
     * 4. {Menu} - The `Menu` object.
     *
     * Additionally, if the menu was activated as a context menu event (see
     * {@link https://www.autohotkey.com/docs/v2/lib/GuiOnEvent.htm#Ctrl-ContextMenu}
     * and {@link https://www.autohotkey.com/docs/v2/lib/GuiOnEvent.htm#ContextMenu}), the following
     * parameters are also available:
     * 5. {Gui} - The `Gui` object
     * 6. {Gui.Control|String} - The `Gui.Control` object if one is associated with the context menu,
     *    else an empty string.
     * 7. {Integer|String} - The "Item" parameter as described in the documentation linked above.
     *
     * The function can also be the name of a class method. For details about this, see the section
     * "Extending MenuEx" in the description above {@link MenuEx}.
     *
     * The function's return value may be used if {@link MenuEx#ShowTooltips} is nonzero. For details
     * about how the return value is used, see {@link MenuEx.Prototype.SetTooltipHandler}.
     *
     * @param {String} [MenuItemOptions = ""] - Any options as described in
     * {@link https://www.autohotkey.com/docs/v2/lib/Menu.htm#Add}.
     *
     * @param {*} [HandlerTooltip] - See {@link MenuExItem.Prototype.SetTooltipHandler} for details about
     * this parameter.
     */
    __New(Name, CallbackOrSubmenu, MenuItemOptions := '', HandlerTooltip?) {
        this.__Name := Name
        this.__Value := CallbackOrSubmenu
        this.__Options := MenuItemOptions
        if IsSet(HandlerTooltip) {
            this.__HandlerTooltip := HandlerTooltip
        }
    }
    /**
     * Adds a checkbox next to the menu item.
     */
    Check() {
        this.MenuEx.Menu.Check(this.__Name)
    }
    /**
     * Deletes the menu item.
     */
    Delete() {
        this.MenuEx.Menu.Delete(this.__Name)
        this.MenuEx.__Item.Delete(this.__Name)
    }
    /**
     * Disables the menu item, causing the text to appear more grey than the surrounding text and
     * making it so the user cannot interact with the menu item.
     */
    Disable() {
        this.MenuEx.Menu.Disable(this.__Name)
    }
    /**
     * Enables the menu item, undoing the effect of {@link MenuExItem.Prototype.Disable} if it was
     * previously called.
     */
    Enable() {
        this.MenuEx.Menu.Enable(this.__Name)
    }
    /**
     * See {@link https://www.autohotkey.com/docs/v2/lib/Menu.htm#SetIcon} for details.
     */
    SetIcon(FileName, IconNumber := 1, IconWidth?) {
        this.MenuEx.Menu.SetIcon(this.__Name, FileName, IconNumber, IconWidth ?? unset)
    }
    /**
     * When {@link MenuEx#ShowTooltips} is true, there are three approaches for controlling the tooltip
     * text that is displayed when the user selects a menu item. When the user selects a menu item,
     * the return value returned by the function associated with the menu item is stored in a variable,
     * and the property {@link MenuExItem#HandlerTooltip} is evaluated to determine if a tooltip will be displayed,
     * and if so, what the text will be.
     *
     * Note that, by default, the value of {@link MenuExItem#HandlerTooltip} is an empty string.
     *
     * If {@link MenuExItem#HandlerTooltip} is an object, it is assumed to be a function or callable object.
     * The function is called with parameters:
     * 1. The {@link MenuEx} instance.
     * 2. The return value from the menu item's function.
     *
     * The function should return the string that will be displayed by the tooltip. If the function
     * returns an object or an empty string, no tooltip is displayed.
     *
     * If {@link MenuExItem#HandlerTooltip} is a significant string value, the return value from the menu
     * item's function is ignored and {@link MenuExItem#HandlerTooltip} is displayed in the tooltip.
     *
     * If {@link MenuExItem#HandlerTooltip} is zero or an empty string, and if the return value from the menu
     * item's function is a number or non-empty string, the return value is displayed in the tooltip.
     * Note that if the return value is a numeric zero or a string containing only a zero, that is
     * displayed in the tooltip; only an empty string will cause a tooltip to not be displayed.
     *
     * @param {*} Value - A value to one of the effects described by the description.
     */
    SetTooltipHandler(Value) {
        /**
         * See {@link MenuExItem.Prototype.SetTooltipHandler} for details.
         * @memberof MenuExItem
         * @instance
         */
        this.__HandlerTooltip := Value
    }
    /**
     * Toggles the display of a checkmark next to the menu item.
     */
    ToggleCheck() {
        this.MenuEx.Menu.ToggleCheck(this.__Name)
    }
    /**
     * Toggles the availability of the menu item.
     */
    ToggleEnable() {
        this.MenuEx.Menu.ToggleEnable(this.__Name)
    }
    /**
     * Removes a checkmark next to the menu item if one is present.
     */
    Uncheck() {
        this.MenuEx.Menu.Uncheck(this.__Name)
    }
    HandlerTooltip {
        Get => this.__HandlerTooltip
        Set {
            this.__HandlerTooltip := Value
        }
    }
    Name {
        Get => this.__Name
        Set {
            this.MenuEx.Menu.Rename(this.__Name, Value)
            this.MenuEx.__Item.Delete(this.__Name)
            this.__Name := Value
            this.MenuEx.__Item.Set(Value, this)
        }
    }
    Options {
        Get => this.__Options
        Set {
            this.MenuEx.Menu.Add(this.__Name, , Value)
            this.__Options := Value
        }
    }
    Value {
        Get => this.__Value
        Set {
            this.__Value := Value
        }
    }
}

class MenuExItemCollection extends Map {
    static __New() {
        this.DeleteProp('__New')
        this.Prototype.Default := this.DefaultItem()
    }
    class DefaultItem {
        __Call(*) => ''
    }
}

/**
 * Sets the global constant variables.
 *
 * @param {Boolean} [force = false] - When false, if `TreeViewEx_SetConstants` has already been called
 * (more specifically, if `tvex_flag_constants_set` has been set), the function returns immediately.
 * If true, the function executes in its entirety.
 */
MenuEx_SetConstants(force := false) {
    global
    if IsSet(MenuEx_flag_constants_set) && !force {
        return
    }
    ; https://learn.microsoft.com/en-us/windows/win32/menurc/keyboard-accelerator-messages
    WM_CHANGEUISTATE                := 0x0127
    WM_INITMENU                     := 0x0116
    WM_QUERYUISTATE                 := 0x0129
    WM_UPDATEUISTATE                := 0x0128

    UIS_CLEAR := 2
    UIS_INITIALIZE := 3
    UIS_SET := 1

    UISF_ACTIVE := 0x4
    UISF_HIDEACCEL := 0x2
    UISF_HIDEFOCUS := 0x1

    MenuEx_flag_constants_set := 1
}

class TreeViewEx_ContextMenu extends MenuEx {
    static __New() {
        this.DeleteProp('__New')
        this.Prototype.DefaultItems := TreeViewExCollection_ContextMenuItem(
            /**
                Only the "Name" and "Value" are required. Other properties are "Options", which are the
                options described by https://www.autohotkey.com/docs/v2/lib/Menu.htm#Add, and "Tooltip",
                which controls the tooltip text that will be displayed. Details about "Tooltip" are
                available in the description of {@link MenuExItem.Prototype.SetTooltipHandler}.
                Since we have defined the functions as class instance methods, we can define "Value"
                with the name of the method.

                Used accelerators: A, B, C, D, E, F, I, O, P, Q, S, T, W, X, Z
            */
            { Name: 'Copy node ID (&D)', Value: 'SelectCopyNodeId' }
          , { Name: 'Copy label (&C)', Value: 'SelectCopyLabel' }
          , { Name: 'Collapse recursive (&S)', Value: 'SelectCollapseRecursive' }
          , { Name: 'Collapse all recursive (&A)', Value: 'SelectCollapseAllRecursive' }
          , { Name: 'Collapse parent (&P)', Value: 'SelectCollapseParent' }
          , { Name: 'Collapse parent recursive (&O)', Value: 'SelectCollapseParentRecursive' }
          , { Name: 'Collapse siblings (&G)', Value: 'SelectCollapseSiblings' }
          , { Name: 'Collapse siblings recursive (&F)', Value: 'SelectCollapseSiblingsRecursive' }
          , { Name: 'Expand recursive (&X)', Value: 'SelectExpandRecursive' }
          , { Name: 'Expand all recursive (&Z)', Value: 'SelectExpandAllRecursive' }
          , { Name: 'Expand partial (&I)', Value: 'SelectExpandPartial' }
          , { Name: 'Scroll to top (&T)', Value: 'SelectScrollToTop' }
          , { Name: 'Scroll to bottom (&B)', Value: 'SelectScrollToBottom' }
          , { Name: 'Select parent (&W)', Value: 'SelectSelectParent' }
          , { Name: 'Select previous sibling (&Q)', Value: 'SelectSelectPreviousSibling' }
          , { Name: 'Select next sibling (&E)', Value: 'SelectSelectNextSibling' }
        )
    }
    ; When the context menu is activated, if the MenuEx object (an instance of this class is
    ; a MenuEx object; it inherits from MenuEx) has a method "HandlerItemAvailability", that method
    ; is called before showing to context menu. The method is intended to enable and disable items
    ; as a function of what was underneath the mouse cursor when the context menu was activated,
    ; if anything.
    HandlerItemAvailability(Ctrl, IsRightClick, Item, X, Y) {
        items := this.__Item
        ; Since most of our methods act on the `Item` in some way, we only want to enable the menu items
        ; if `Item` has a significant value. The exceptions are "Collapse recursive (&S)" and "Expand recursive"
        ; which can still execute without `Item`.
        if Item {
            items.Get('Copy node ID (&D)').Enable()
            items.Get('Copy label (&C)').Enable()
            items.Get('Expand recursive (&X)').Enable()
            items.Get('Collapse recursive (&S)').Enable()
            items.Get('Expand partial (&I)').Enable()
            if SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, Item, Ctrl.Hwnd) {
                items.Get('Select parent (&W)').Enable()
                items.Get('Collapse parent (&P)').Enable()
                items.Get('Collapse parent recursive (&O)').Enable()
            } else {
                items.Get('Select parent (&W)').Disable()
                items.Get('Collapse parent (&P)').Disable()
                items.Get('Collapse parent recursive (&O)').Disable()
            }
            flag_siblings := false
            if SendMessage(TVM_GETNEXTITEM, TVGN_PREVIOUS, Item, Ctrl.Hwnd) {
                items.Get('Select previous sibling (&Q)').Enable()
                flag_siblings := true
            } else {
                items.Get('Select previous sibling (&Q)').Disable()
            }
            if SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, Item, Ctrl.Hwnd) {
                items.Get('Select next sibling (&E)').Enable()
                flag_siblings := true
            } else {
                items.Get('Select next sibling (&E)').Disable()
            }
            if flag_siblings {
                items.Get('Collapse siblings (&G)').Enable()
                items.Get('Collapse siblings recursive (&F)').Enable()
            } else {
                items.Get('Collapse siblings (&G)').Disable()
                items.Get('Collapse siblings recursive (&F)').Disable()
            }
        } else {
            items.Get('Copy node ID (&D)').Disable()
            items.Get('Copy label (&C)').Disable()
            items.Get('Collapse recursive (&S)').Disable()
            items.Get('Collapse parent (&P)').Disable()
            items.Get('Collapse parent recursive (&O)').Disable()
            items.Get('Collapse siblings (&G)').Disable()
            items.Get('Collapse siblings recursive (&F)').Disable()
            items.Get('Expand recursive (&X)').Disable()
            items.Get('Select parent (&W)').Disable()
            items.Get('Select previous sibling (&Q)').Disable()
            items.Get('Select next sibling (&E)').Disable()
            items.Get('Expand partial (&I)').Disable()
        }
    }
    SelectCollapseAllRecursive(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        Ctrl.CollapseRecursiveNotify()
        Ctrl.Redraw()
        return 'Collapsed all nodes'
    }
    SelectCollapseParent(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        if handle := SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, Item, Ctrl.Hwnd) {
            if Ctrl.CollapseNotify(handle, &result) || result {
                return 'Unable to collapse the parent node'
            }
            Ctrl.Select(handle)
            Ctrl.Redraw()
            return 'Collapsed node: ' Ctrl.GetText(handle)
        }
    }
    SelectCollapseParentRecursive(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        if handle := SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, Item, Ctrl.Hwnd) {
            Ctrl.CollapseRecursiveNotify(handle)
            Ctrl.Select(handle)
            Ctrl.Redraw()
            return 'Collapsed from node: ' Ctrl.GetText(handle)
        }
    }
    SelectCollapseRecursive(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        Ctrl.CollapseRecursiveNotify(Item)
        Ctrl.Redraw()
        return 'Collapsed from node: ' Ctrl.GetText(Item)
    }
    SelectCollapseSiblings(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        handle := Item
        while handle := SendMessage(TVM_GETNEXTITEM, TVGN_PREVIOUS, handle, Ctrl.Hwnd) {
            Ctrl.CollapseNotify(handle)
        }
        handle := Item
        while handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, handle, Ctrl.Hwnd) {
            Ctrl.CollapseNotify(handle)
        }
        Ctrl.Redraw()
        return 'Collapsed siblings'
    }
    SelectCollapseSiblingsRecursive(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        handle := Item
        while handle := SendMessage(TVM_GETNEXTITEM, TVGN_PREVIOUS, handle, Ctrl.Hwnd) {
            Ctrl.CollapseRecursiveNotify(handle)
        }
        handle := Item
        while handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, handle, Ctrl.Hwnd) {
            Ctrl.CollapseRecursiveNotify(handle)
        }
        Ctrl.Redraw()
        return 'Collapsed siblings'
    }
    SelectCopyLabel(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        text := Ctrl.GetText(Item)
        A_Clipboard := text
        return 'Copied: ' text
    }
    SelectCopyNodeId(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        A_Clipboard := Item
        ; The text that is returned gets displayed in the tooltip.
        ; The option "ShowTooltips" must be enabled for the tooltips to be displayed.
        return 'Copied: ' Item
    }
    SelectExpandAllRecursive(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        Ctrl.SetRedraw(0)
        Ctrl.ExpandRecursiveNotify()
        Ctrl.EnsureVisible(SendMessage(TVM_GETNEXTITEM, TVGN_ROOT, 0, Ctrl.Hwnd))
        Ctrl.SetRedraw(1)
        return 'Expanded all nodes'
    }
    SelectExpandRecursive(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        Ctrl.ExpandRecursiveNotify(Item)
        Ctrl.Redraw()
        return 'Expanded from node: ' Ctrl.GetText(Item)
    }
    SelectExpandPartial(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        Ctrl.ExpandPartial(Item)
        Ctrl.Redraw()
        return 'Expanded from node: ' Ctrl.GetText(Item)
    }
    SelectScrollToBottom(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        Ctrl.EnsureVisible(SendMessage(TVM_GETNEXTITEM, TVGN_LASTVISIBLE, 0, Ctrl.Hwnd))
        Ctrl.Redraw()
    }
    SelectScrollToTop(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        Ctrl.EnsureVisible(SendMessage(TVM_GETNEXTITEM, TVGN_ROOT, 0, Ctrl.Hwnd))
        Ctrl.Redraw()
    }
    SelectSelectNextSibling(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        handle := SendMessage(TVM_GETNEXTITEM, TVGN_NEXT, Item, Ctrl.Hwnd)
        Ctrl.Select(handle)
        Ctrl.EnsureVisible(handle)
        Ctrl.Redraw()
        return 'Selected node: ' ctrl.GetText(handle)
    }
    SelectSelectParent(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        handle := SendMessage(TVM_GETNEXTITEM, TVGN_PARENT, Item, Ctrl.Hwnd)
        Ctrl.Select(handle)
        Ctrl.EnsureVisible(handle)
        Ctrl.Redraw()
        return 'Selected node: ' ctrl.GetText(handle)
    }
    SelectSelectPreviousSibling(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        handle := SendMessage(TVM_GETNEXTITEM, TVGN_PREVIOUS, Item, Ctrl.Hwnd)
        Ctrl.Select(handle)
        Ctrl.EnsureVisible(handle)
        Ctrl.Redraw()
        return 'Selected node: ' ctrl.GetText(handle)
    }
}

; https://github.com/Nich-Cebolla/AutoHotkey-FormatStr/tree/main

/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-FormatStr
    Author: Nich-Cebolla
    License: MIT
*/

; An AutoHotkey (AHK) library for creating customizable and extensible text formatting logic to suit any project's needs.

class FormatStr_FormatCodesCollection extends Map {
    /**
     * @param {...*} [Values] - A variadic series of values in this order: FormatCode, Value, FormatCodeType
     */
    __New(Values*) {
        types := this.Types := []
        types.Length := FormatStrConstructor.FormatCodeTypes.Length
        for formatCodeType in FormatStrConstructor.FormatCodeTypes {
            types[formatCodeType] := Map()
        }
        if Values.Length {
            this.Add(Values)
        }
    }
    /**
     * @param {*[]} [Values] - An array of values in this order: FormatCode, Value, FormatCodeType
     */
    Add(Values) {
        loop Values.Length / 3 {
            this.Types[Values[A_Index * 3]].Set(Values[A_Index * 3 - 2], Values[A_Index * 3 - 1])
            Values[A_Index * 3 - 1].DefineProp('FormatCodeType', { Value: Values[A_Index * 3] })
        }
    }
    Has(Key, &FormatCodeType?) {
        if IsSet(FormatCodeType) {
            return this.Types[FormatCodeType].Has(Key)
        } else {
            for m in this.Types {
                if m.Has(Key) {
                    FormatCodeType := A_Index
                    return 1
                }
            }
        }
    }
    Get(Key, &FormatCodeType?) {
        if IsSet(FormatCodeType) {
            return this.Types[FormatCodeType].Get(Key)
        } else {
            for m in this.Types {
                if m.Has(Key) {
                    FormatCodeType := A_Index
                    return m.Get(Key)
                }
            }
        }
        throw UnsetItemError('Item not found.', -1, Key)
    }
    __Enum(VarCount) {
        items := Map()
        for m in this.Types {
            for key, val in m {
                items.Set(key, val)
            }
        }
        return items.__Enum(VarCount)
    }
}
class FormatStr_FormatCodeParamsCollection extends Array {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        desc := Array.Prototype.GetOwnPropDesc('__Item')
        proto.DefineProp('GetItem', { Call: desc.Get })
        proto.DefineProp('SetItem', { Call: desc.Set })
    }
    __Item[Index] {
        Get {
            if Index {
                return this.GetItem(Index)
            } else {
                return ''
            }
        }
        Set => this.SetItem(Value, Index)
    }
}
class FormatStr_FormatCodeCollection extends Map {
}
class FormatStr_ConstructorCollection extends FormatStr_PrototypeCollection {
}
class FormatStr_PrototypeCollection extends Array {
    ConditionalGroup => this[FORMATSTR_TYPE_INDEX_CONDITIONALGROUP]
    FormatCode => this[FORMATSTR_TYPE_INDEX_FORMATCODE]
    FormatSpecifier => this[FORMATSTR_TYPE_INDEX_FORMATSPECIFIER]
    PlainText => this[FORMATSTR_TYPE_INDEX_PLAINTEXT]
    SignificantCondition => this[FORMATSTR_TYPE_INDEX_SIGNIFICANTCONDITION]
    SimpleCondition => this[FORMATSTR_TYPE_INDEX_SIMPLECONDITION]
    TokenBase => this[FORMATSTR_TYPE_INDEX_PLAINTEXT].Base
    FormatSpecifierBase => this[FORMATSTR_TYPE_INDEX_FORMATSPECIFIER].Base
}
class FormatStr_TokenCollection extends Array {
}

; The parameters are:
; 1. FormatCode
; 2. FormatCodeParams
; 3. ConditionalGroupToken
; 4. FormatStrObj

FormatStr_FormatCode_AllSpecifiers(DefaultFormatCode, FormatCodeParams, ConditionalGroupToken, *) {
    if ConditionalGroupToken {
        ConditionalGroupToken.SetFlag(FORMATSTR_FLAG_ALLCONDITIONS, 1)
    } else {
        throw Error('The "!a" format code may only be used within a conditional group.')
    }
}

FormatStr_SortCompare(address, localeName, flags, NLSVersionInfo, a, b) {
    if result := DllCall(
        address
      , 'ptr', localeName
      , 'uint', flags
      , 'ptr', a
      , 'int', -1
      , 'ptr', b
      , 'int', -1
      , 'ptr', NLSVersionInfo
      , 'ptr', 0
      , 'ptr', 0
      , 'int'
    ) {
        return result - 2
    } else {
        throw OSError()
    }
}

FormatStr_GetPrototypes(Base) {
    if not Base is Array {
        throw TypeError('``Base`` must inherit from ``Array``.', -1)
    }
    result := FormatStr_PrototypeCollection()
    prototypes := FormatStrConstructor.Prototypes
    result.Length := prototypes.Length
    _base := _GetBase(FormatStrTokenBase.Prototype)
    ObjSetBase(_base, Base)
    base_formatSpecifier := _GetBase(FormatStrToken_FormatSpecifierBase.Prototype)
    ObjSetBase(base_formatSpecifier, _base)
    _Proc([ FORMATSTR_TYPE_INDEX_CONDITIONALGROUP, FORMATSTR_TYPE_INDEX_PLAINTEXT ], _base)
    _Proc(
        [   FORMATSTR_TYPE_INDEX_FORMATCODE
          , FORMATSTR_TYPE_INDEX_FORMATSPECIFIER
          , FORMATSTR_TYPE_INDEX_SIGNIFICANTCONDITION
          , FORMATSTR_TYPE_INDEX_SIMPLECONDITION
        ]
      , base_formatSpecifier
    )
    _Proc([ FORMATSTR_TYPE_INDEX_DEFAULTFORMATCODE ], prototypes[FORMATSTR_TYPE_INDEX_FORMATCODE])

    return result

    _GetBase(proto) {
        local base := []
        for prop in proto.OwnProps() {
            base.DefineProp(prop, proto.GetOwnPropDesc(prop))
        }
        return base
    }
    _Proc(indices, base) {
        for i in indices {
            result[i] := _GetBase(prototypes[i])
            ObjSetBase(result[i], base)
        }
    }
}

FormatStr_SetConstants() {
    global
    if IsSet(FORMATSTR_TYPE_INDEX_CONDITIONALGROUP) {
        throw Error('Values have already been initialized.')
    }
    FORMATSTR_TYPE_INDEX_CONDITIONALGROUP :=
    FORMATSTR_TYPE_INDEX_DEFAULTFORMATCODE :=
    FORMATSTR_TYPE_INDEX_FORMATCODE :=
    FORMATSTR_TYPE_INDEX_FORMATSPECIFIER :=
    FORMATSTR_TYPE_INDEX_PLAINTEXT :=
    FORMATSTR_TYPE_INDEX_SIGNIFICANTCONDITION :=
    FORMATSTR_TYPE_INDEX_SIMPLECONDITION :=
    0
    local i := 0
    FORMATSTR_FLAG_ALLCONDITIONS := ++i

    local i := 0
    FORMATSTR_FORMATCODE_TYPE_CALL_EARLY := ++i
    FORMATSTR_FORMATCODE_TYPE_CALL_STANDARD := ++i
}

/**
 * Sorts an array. The returned array is a new array; the original array is not modified.
 *
 * The process used by `ScriptParser_QuickSort` makes liberal usage of the system's memory. My tests demonstrated
 * an average memory consumption of over 9x the capacity of the input array. These tests were
 * performed using input arrays with 1000 numbers across an even distribution.
 *
 * @param {Array} Arr - The array to be sorted.
 *
 * @param {*} [CompareFn = (a, b) => a - b] - A `Func` or callable object that compares two values.
 *
 * Parameters:
 * 1. A value to be compared.
 * 2. A value to be compared.
 *
 * Returns {Number} - A number to one of the following effects:
 * - If the number is less than zero it indicates the first parameter is less than the second parameter.
 * - If the number is zero it indicates the two parameters are equal.
 * - If the number is greater than zero it indicates the first parameter is greater than the second parameter.
 *
 * @param {Integer} [ArrSizeThreshold = 17] - Sets a threshold at which insertion sort is used to
 * sort the array instead of the core procedure. The default value of 17 was decided by testing various
 * values, but currently more testing is needed to evaluate arrays of various kinds of distributions.
 *
 * @param {Integer} [PivotCandidates = 7] - Note that `PivotCandidates` must be an integer greater
 * than 1.
 *
 * Defines the sample size used when selecting a pivot from a random sample. This seeks to avoid the
 * efficiency cost associated with selecting a low quality pivot. By choosing from a random sample,
 * it is expected that, on average, the number of comparisons required to evaluate the middle pivot
 * in the sample is significantly less than the number of comparisons avoided due to selecting a low
 * quality pivot.
 *
 * The default value of 7 was decided by testing various values. More testing is needed to evaluate
 * arrays of various kinds of distributions.
 *
 * @returns {Array} - The sorted array.
 *
 * @throws {ValueError} - "`PivotCandidates` must be an integer greater than one."
 */
FormatStr_QuickSort(Arr, CompareFn := (a, b) => a - b, ArrSizeThreshold := 17, PivotCandidates := 7) {
    if PivotCandidates <= 1 {
        throw ValueError('``PivotCandidates`` must be an integer greater than one.', -1, PivotCandidates)
    }
    halfPivotCandidates := Ceil(PivotCandidates / 2)
    if Arr.Length <= ArrSizeThreshold {
        if Arr.Length == 2 {
            if CompareFn(StrPtr(Arr[1]), StrPtr(Arr[2])) > 0 {
                return [Arr[2], Arr[1]]
            }
            return Arr.Clone()
        } else if arr.Length > 1 {
            arr := Arr.Clone()
            ; Insertion sort.
            i := 1
            loop arr.Length - 1 {
                j := i
                current := arr[++i]
                loop j {
                    if CompareFn(StrPtr(arr[j]), StrPtr(current)) < 0 {
                        break
                    }
                    arr[j + 1] := arr[j--]
                }
                arr[j + 1] := current
            }
            return arr
        } else {
            return arr.Clone()
        }
    }

    return _Proc(Arr)

    _Proc(Arr) {
        if Arr.Length <= ArrSizeThreshold {
            if Arr.Length == 2 {
                if CompareFn(StrPtr(Arr[1]), StrPtr(Arr[2])) > 0 {
                    return [Arr[2], Arr[1]]
                }
            } else if Arr.Length > 1 {
                ; Insertion sort.
                i := 1
                loop Arr.Length - 1 {
                    j := i
                    current := Arr[++i]
                    loop j {
                        if CompareFn(StrPtr(arr[j]), StrPtr(current)) < 0 {
                            break
                        }
                        Arr[j + 1] := Arr[j--]
                    }
                    Arr[j + 1] := current
                }
            }
            return Arr
        }
        candidates := []
        loop candidates.Capacity := PivotCandidates {
            candidates.Push(Arr[Random(1, Arr.Length)])
        }
        i := 1
        loop candidates.Length - 1 {
            j := i
            current := candidates[++i]
            loop j {
                if CompareFn(StrPtr(candidates[j]), StrPtr(current)) < 0 {
                    break
                }
                candidates[j + 1] := candidates[j--]
            }
            candidates[j + 1] := current
        }
        pivot := candidates[halfPivotCandidates]
        left := []
        right := []
        left.Capacity := right.Capacity := Arr.Length
        for item in Arr {
            if CompareFn(StrPtr(item), StrPtr(pivot)) < 0 {
                left.Push(item)
            } else {
                right.Push(item)
            }
        }
        result := _Proc(left)
        result.Push(_Proc(right)*)

        return result
    }
}

class FormatStrToken_ConditionalGroup extends FormatStrTokenBase {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.__desc_SetFlag := proto.GetOwnPropDesc('__SetFlag')
        proto.__desc_AddDefaultFormatCode := proto.GetOwnPropDesc('__AddDefaultFormatCode')
        proto.Flags := Map() ; So it always returns 0
        proto.Flags.Default := 0
    }
    __New(IndexToken, Str) {
        this.Push(
            IndexToken
          , Str
          , InStr(Str, this.TOKEN_FORMAT_SPECIFIER)
          , InStr(Str, this.TOKEN_SIGNIFICANT_CONDITION)
          , 0 ; Flag to signal no default format codes have been added yet.
        )
        this.Tokens := FormatStr_TokenCollection()
        if !HasProp(this, 'FormatCodes') {
            this.FormatCodes := []
        }
    }
    AddDefaultFormatCode(IndexDefaultFormatCode) {
        if !this.HasOwnProp('DefaultFormatCodes') {
            this.DefineProp('DefaultFormatCodes', { Value: [] })
        }
        this.DefineProp('AddDefaultFormatCode', this.__desc_AddDefaultFormatCode)
        ; Flag to signal that a default format code was added.
        this[5] := 1
        return this.AddDefaultFormatCode(IndexDefaultFormatCode)
    }
    __AddDefaultFormatCode(Token) {
        this.DefaultFormatCodes.Push(Token)
    }
    SetFlag(Flag, Value) {
        if !this.HasOwnProp('Flags') {
            this.DefineProp('Flags', { Value: Map() })
            this.Flags.Default := 0
        }
        this.DefineProp('SetFlag', this.__desc_SetFlag)
        return this.SetFlag(Flag, Value)
    }
    __SetFlag(Flag, Value) {
        this.Flags.Set(Flag, Value)
    }
    HasDefaultFormatCode => this[5]
    HasFormatSpecifier => this[3]
    HasSignificantCondition => this[4]
    Str => this[2]
}
class FormatStrToken_DefaultFormatCode extends FormatStrToken_FormatCode {
}
class FormatStrToken_FormatCode extends FormatStrToken_FormatSpecifierBase {
    __New(IndexToken, IndexFormatCode, IndexFormatCodeParams) {
        this.Push(IndexToken, IndexFormatCode, IndexFormatCodeParams)
        if IndexFormatCode {
            this.DefineProp('FormatCodeFunction', { Value: this.FormatCodes.Get(this.FormatCode) })
        }
    }
    IndexFormatCode => this[2]
    IndexFormatCodeParams => this[3]
    FormatCode => this.FormatCodeMap.Get(this[2])
    Params => this.FormatCodeParams[this[3]]
}
class FormatStrToken_FormatSpecifier extends FormatStrToken_FormatSpecifierBase {
}
class FormatStrToken_PlainText extends FormatStrTokenBase {
    __New(IndexToken, Str) {
        this.Push(IndexToken, Str)
    }
    Str => this[2]
}
class FormatStrToken_SignificantCondition extends FormatStrToken_FormatSpecifierBase {
}
class FormatStrToken_SimpleCondition extends FormatStrToken_FormatSpecifierBase {
}
class FormatStrToken_FormatSpecifierBase extends FormatStrTokenBase {
    __New(IndexToken, IndexFormatSpecifier, IndexSpecifierCode) {
        this.Push(IndexToken, IndexFormatSpecifier, IndexSpecifierCode)
        if IndexSpecifierCode {
            this.DefineProp('SpecifierCodeFunction', { Value: this.SpecifierCodes.Get(this.SpecifierCodeMap.Get(this[3])) })
        }
    }
    SpecifierCode => this.SpecifierCodeMap.Get(this[3])
    IndexSpecifierCode => this[3]
    IndexFormatSpecifier => this[2]
    FormatSpecifierName => this.Names[this[2]]
}
class FormatStrTokenBase extends Array {
    IndexToken => this[1]
}

/**
 * `FormatStr` makes it easy to create a unique, customizable, and extensible text formatting system
 * just like the standard printf-style format codes "%d", "%u", "%i", and the like. With a feature-rich
 * API based on caller-defined callback functions, there's no limit to the possibilities.
 *
 * See "README.md" for documentation.
 */
class FormatStrConstructor {
    static __New() {
        this.DeleteProp('__New')
        this.__Initialize()
    }
    /**
     * The purpose of {@link FormatStrConstructor.Initialize} is to give external code a meaningful
     * entrypoint for invoking the initialization logic. The following information explains why
     * {@link FormatStrConstructor.Initialize} just deletes itself, and is intended for readers
     * who do not yet have a strong understanding of AutoHotkey's class system.
     *
     * When AutoHotkey processes the {@link https://www.autohotkey.com/docs/v2/Scripts.htm#auto auto-execute thread},
     * it proceeds in top-down order until reaching the end.
     *
     * Class objects are initialized when the auto-execute thread reaches the class definition, or
     * when the class is first referenced, whichever occurs first.
     *
     * In the case of {@link FormatStrConstructor}, the class initialization logic includes setting
     * a number of global variables. A subset of these global variables might be needed by external
     * code to prepare the functions and options it will use.
     *
     * If {@link FormatStrConstructor} has not yet been referenced or reached in the auto-execute
     * thread, using the global variables will throw an unset var error.
     *
     * To handle this, this library's documentation directs the user to call
     * {@link FormatStrConstructor.Initialize} to set the global variables with their values.
     *
     * In some cases, the call to {@link FormatStrConstructor.Initialize} will be the first time
     * {@link FormatStrConstructor} was referenced. When this is true, AutoHotkey will automatically
     * call {@link FormatStrConstructor.__New} BEFORE calling {@link FormatStrConstructor.Initialize}.
     * If both methods are defined to initialize the values, then the values will be initialized
     * twice consecutively, which is a waste of processing time and also can cause issues depending
     * on the initialization logic.
     *
     * In other cases, the call to {@link FormatStrConstructor.Initialize} will not be the first
     * time {@link FormatStrConstructor} was referenced, and so re-initializing the values might
     * incidentally overwrite the existing values depending on the initialization logic.
     *
     * Consequently, the optimal approach is to define {@link FormatStrConstructor.Initialize} to
     * do nothing. If the call to {@link FormatStrConstructor.Initialize} is also the first time
     * {@link FormatStrConstructor} is referenced, then {@link FormatStrConstructor.__New} is called
     * and the values are still initialized. If the call to {@link FormatStrConstructor.Initialize}
     * is not the first time {@link FormatStrConstructor} is referenced, then the values are
     * already initialized and we don't want to re-initialize them.
     *
     * Here is the actual sequence of execution that occurs when a call to
     * {@link FormatStrConstructor.Initialize} is the first time {@link FormatStrConstructor} is
     * referenced:
     *
     * 1. Code calls {@link FormatStrConstructor.Initialize}.
     * 2. AutoHotkey calls `FormatStrConstructor.__Init` (method defined by AutoHotkey not seen in our code).
     * 3. AutoHotkey calls `FormatStrConstructor.Options.__Init` (method defined by AutoHotkey not seen in our code).
     * 4. AutoHotkey calls {@link FormatStrConstructor.__New}.
     * 5. The body of {@link FormatStrConstructor.__New} calls {@link FormatStrConstructor.__Initialize}.
     * 6. The original call to {@link FormatStrConstructor.Initialize} is finally processed, which
     *    simply deletes itself so future calls will throw an error.
     *
     * This avoids the issue of double-consecutive-initialization while still providing a meaningful
     * method for callers to use to set the global variables.
     */
    static Initialize() {
        if this.HasOwnProp('Initialize') {
            this.DeleteProp('Initialize')
        }
    }
    ; Do not call "__Initialize"; call "Initialize" instead.
    static __Initialize() {
        global FORMATSTR_TYPE_INDEX_CONDITIONALGROUP
        , FORMATSTR_TYPE_INDEX_DEFAULTFORMATCODE
        , FORMATSTR_TYPE_INDEX_FORMATCODE
        , FORMATSTR_TYPE_INDEX_FORMATSPECIFIER
        , FORMATSTR_TYPE_INDEX_PLAINTEXT
        , FORMATSTR_TYPE_INDEX_SIGNIFICANTCONDITION
        , FORMATSTR_TYPE_INDEX_SIMPLECONDITION
        FormatStr_SetConstants()
        prototypes := this.Prototypes := FormatStr_PrototypeCollection()
        prototypes.Capacity := 8
        for name in [ 'ConditionalGroup', 'DefaultFormatCode', 'FormatCode', 'FormatSpecifier', 'PlainText', 'SignificantCondition', 'SimpleCondition' ] {
            proto := FormatStrToken_%name%.Prototype
            prototypes.Push(proto)
            FORMATSTR_TYPE_INDEX_%StrUpper(name)% := proto.TypeIndex := prototypes.Length
        }
        this.CompareStringsEx := DllCall('GetProcAddress', 'ptr', DllCall('GetModuleHandleW', 'wstr', 'kernel32', 'ptr'), 'astr', 'CompareStringEx', 'ptr')
        this.FormatCodeTypes := [
            FORMATSTR_FORMATCODE_TYPE_CALL_EARLY
          , FORMATSTR_FORMATCODE_TYPE_CALL_STANDARD
        ]
        this.DefaultFormatCodes := FormatStr_FormatCodesCollection(
            '!a', FormatStr_FormatCode_AllSpecifiers, FORMATSTR_FORMATCODE_TYPE_CALL_EARLY
        )
        defaultFormatCodeMap := this.defaultFormatCodeMap := Map()
        for name in this.DefaultFormatCodes {
            defaultFormatCodeMap.Set(name, String(A_Index), String(A_Index), name)
        }
        this.DefaultSpecifierCodes := Map(

        )
        this.DefaultFormatCodes.Default :=
        defaultFormatCodeMap.Default :=
        this.DefaultSpecifierCodes.Default := ''
    }

    /**
     * @param {String[]} FormatSpecifierNames - An array of format specifier names. These are the
     * symbols that the user will enclose in percent signs to include the format specifier in their
     * format string. When your code calls {@link FormatStr.Prototype.Call} to produces formatted text,
     * the format specifier name is passed to the first parameter of `Options.Callback`.
     * `Options.Callback` is expected to return the string that will replace the format specifier
     * in the formatted text.
     *
     * @param {*} [ Options.Callback = "" ] - A `Func` or callable object that is called once for each
     * format specifier when producing the output text.
     *
     * @param {Boolean} [ Options.CaseSense = false ] - When true, most logic that involves comparing
     * strings is performed with case sensitivity. When false, all logic that involves comparing
     * strings is performed without case sensitivity.
     *
     * @param {Map|FormatStr_FormatCodesCollection} [ Options.FormatCodes = "" ] - Custom format
     * codes. See the documentation for details.
     *
     * @param {*} [ Options.ReturnArray = false ] - (To understand this option, you should know that
     * when {@link FormatStr.Prototype.__New} is called, it converts the format string to an array
     * of tokens, each token representing a segment of the format string. When the format function is
     * called, the tokens are processed and the result of processing each token is incrementally added
     * onto a string value, which is then returned to the caller). When `Options.ReturnArray` is
     * true, the format function does not concatenate the result of processing each token; instead,
     * the values are added to an array as objects with two properties, { Value, Token }. "Value"
     * is the string value that was produced by the token. "Token" is the token object. Additionally,
     * the functions associated with format codes also receive an array of strings. (Functions associated
     * with specifier codes continue to receive the string that was to replace the format specifier,
     * as before). Conditional groups are also groups together as a nested array (the value of property
     * "Value" is an array). The objects associated with conditional groups have an additional property,
     * { Condition }, which is true when the condition was satisfied and false when it was not
     * satisfied. Local format code functions receive conditional group array. Objects are
     * added to the array even if the callback returned an empty string.
     *
     * @param {Map} [ Options.SpecifierCodes = "" ] - Custom specifier codes. See the documentation
     * for details.
     *
     * @param {Integer} [ Options.StrCapacity = 1024 ] - The size, in bytes, passed to
     * `VarSetStrCapacity` before incrementally building the output text. This is to avoid resizing
     * the string.
     */
    __New(FormatSpecifierNames, Options?) {
        options := FormatStrConstructor.Options(Options ?? unset)
        names := FormatStr_QuickSort(
            FormatSpecifierNames
          , FormatStr_SortCompare.Bind(
                FormatStrConstructor.CompareStringsEx
              , options.SortLocaleName
              , options.SortFlags
              , options.SortNLSVersionInfo
            )
        )
        namesMap := Map()
        namesMap.CaseSense := options.CaseSense
        namesMap.Default := ''
        for s in FormatSpecifierNames {
            namesMap.Set(s, String(A_Index))
        }
        this.Constructor := Class()
        this.Constructor.Base := FormatStr
        proto := this.Constructor.Prototype := {
            Callback: options.Callback
          , CaseSense: options.CaseSense
          , DefaultOperators: options.DefaultOperators
          , DefaultOperatorsLowerCode: options.DefaultOperatorsLowerCode
          , FormatCodes: options.FormatCodes
          , ReturnArray: options.ReturnArray
          , SpecifierCodes: options.SpecifierCodes
          , StrCapacity: options.StrCapacity
          , SubstringPattern: _ProcNames(FormatSpecifierNames, options.CaseSense)
          , NamesMap: namesMap
          , Names: FormatSpecifierNames
          , __Class: FormatStr.Prototype.__Class
        }
        ObjSetBase(proto, FormatStr.Prototype)
        index := 0
        if options.FormatCodes {
            proto.FormatCodeMap := Map()
            _ProcCodes(&index, proto.FormatCodeMap, options.FormatCodes)
        }
        index := 0
        proto.SpecifierCodeMap := Map()
        ; Add the defaults first so the keys can be overridden if the user is using a same key.
        _ProcCodes(&index, proto.SpecifierCodeMap, FormatStrConstructor.DefaultSpecifierCodes)
        if options.SpecifierCodes {
            _ProcCodes(&index, proto.SpecifierCodeMap, options.SpecifierCodes)
        }

        return

        _ProcCodes(&index, mapObj, codes) {
            if !mapObj.Count {
                mapObj.CaseSense := options.CaseSense
                mapObj.Default := ''
            }
            for name in codes {
                mapObj.Set(name, String(++index), String(index), name)
            }
        }

        _ProcNames(FormatSpecifierNames, CaseSense) {
            first := ''
            remainder := ''
            VarSetStrCapacity(&first, FormatSpecifierNames.Length)
            VarSetStrCapacity(&remainder, FormatSpecifierNames.Length * 16)
            for s in FormatSpecifierNames {
                c := SubStr(s, 1, 1)
                if !InStr(first, c, CaseSense) {
                    first .= c
                }
                if StrLen(s) > 1 {
                    remainder .= SubStr(s, 2) '|'
                }
            }
            return (
                '(?<open>\{)'
                '?%'
                '(?<specifier>'
                    '(?:'
                        '(?<name>'
                            '[' first ']'
                            '(?:'
                                remainder
                            ')'
                        ')'
                        '(?::(?<code>\w+))?'
                    ')'
                '|'
                    '.+?'
                ')'
                '%(?<close>\})?'
            )
        }
    }
    Call(FormatStr) {
        return this.Constructor.Call(FormatStr)
    }

    class Options {
        static Default := {
            Callback: ''
          , CaseSense: false
          , DefaultOperators: '[\x{2000}-\x{2009}]'
          , DefaultOperatorsLowerCode: 0x2000
          , FormatCodes: ''
        ;   , IndentLen: 4 not yet implemented
          , ReturnArray: false
          , SortLocaleName: 0
          , SortFlags: 0
          , SortNLSVersionInfo: 0
          , SpecifierCodes: ''
          , StrCapacity: 1024
        }
        static Call(Options?) {
            if IsSet(Options) {
                o := {}
                d := this.Default
                for prop in d.OwnProps() {
                    o.%prop% := HasProp(Options, prop) ? Options.%prop% : d.%prop%
                }
                return o
            } else {
                return this.Default.Clone()
            }
        }
    }
}
class FormatStr {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.FormatCodes := proto.FormatCodeMap := proto.SpecifierCodes := proto.SpecifierCodeMap :=
        proto.GlobalFormatCodes := proto.ReturnArray := ''
    }
    __New(FormatStr) {
        this.FormatStr := FormatStr
        _formatStr := ''
        VarSetStrCapacity(&_formatStr, StrLen(FormatStr))

        ; The purpose of this block is to shave off a few milliseconds of processing.

        ; The block opens by checking `this.DefaultOperators`, which is a value specified by
        ; option `Options.DefaultOperators` when calling `FormatStrConstructor.Prototype.__New`.
        ; The default value is a regex pattern that spans a unicode code point range. These
        ; are semi-arbitrary, chosen because they are 2-byte characters that are very unlikely to be
        ; used.

        ; If `this.DefaultOperators` matches with `FormatStr`, then the values assigned to each
        ; of the below variables are checked one at a time against `FormatStr` until all variables
        ; have been assigned a character that does not exist in `FormatStr`.

        ; If `this.DefaultOptions` does not match with `FormatStr`, then we know none of the characters
        ; exist in `FormatStr`, and can assign each without checking. The idea is that since it is
        ; unlikely that anyone will use one of these characters while also using this library,
        ; this will almost always result in a net performance gain, albeit a minor one.

        ; To similarly minded folk, if you know your input strings will contain a character in
        ; the default range, you can assign a new pattern to `Options.DefaultOperators`. Don't
        ; forget to set `Options.DefaultOperatorsLowerCode` to the correct number.

        n := this.DefaultOperatorsLowerCode - 1
        if RegExMatch(FormatStr, this.DefaultOperators, &match) {
            ++n
            LITERAL_BACKSLASH := this.LITERAL_BACKSLASH := _GetChar()
            ++n
            LITERAL_CLOSE := this.LITERAL_CLOSE := _GetChar()
            ++n
            LITERAL_PERCENT := this.LITERAL_PERCENT := _GetChar()
            ++n
            LITERAL_OPEN := this.LITERAL_OPEN := _GetChar()
            ++n
            TOKEN_FORMAT_CODE := this.TOKEN_FORMAT_CODE := _GetChar()
            ++n
            TOKEN_FORMAT_CODE_DEFAULT := this.TOKEN_FORMAT_CODE_DEFAULT := _GetChar()
            ++n
            TOKEN_FORMAT_SPECIFIER := this.TOKEN_FORMAT_SPECIFIER := _GetChar()
            ++n
            TOKEN_SIGNIFICANT_CONDITION := this.TOKEN_SIGNIFICANT_CONDITION := _GetChar()
        } else {
            LITERAL_BACKSLASH := this.LITERAL_BACKSLASH := Chr(++n)
            LITERAL_CLOSE := this.LITERAL_CLOSE := Chr(++n)
            LITERAL_PERCENT := this.LITERAL_PERCENT := Chr(++n)
            LITERAL_OPEN := this.LITERAL_OPEN := Chr(++n)
            TOKEN_FORMAT_CODE := this.TOKEN_FORMAT_CODE := Chr(++n)
            TOKEN_FORMAT_CODE_DEFAULT := this.TOKEN_FORMAT_CODE_DEFAULT := Chr(++n)
            TOKEN_FORMAT_SPECIFIER := this.TOKEN_FORMAT_SPECIFIER := Chr(++n)
            TOKEN_SIGNIFICANT_CONDITION := this.TOKEN_SIGNIFICANT_CONDITION := Chr(++n)
        }

        ; The token objects require references to various values. To accommodate this, this block
        ; creates prototype objects and constructor class objects for each of the token classes
        ; and assigns properties with the needed values.
        prototype := []
        prototype.TOKEN_FORMAT_SPECIFIER := TOKEN_FORMAT_SPECIFIER
        prototype.TOKEN_SIGNIFICANT_CONDITION := TOKEN_SIGNIFICANT_CONDITION
        prototype.Names := this.Names
        prototypes := FormatStr_GetPrototypes(prototype)
        constructors := this.Constructors := FormatStr_ConstructorCollection()
        constructors.Capacity := prototypes.Length
        for prototype in prototypes {
            constructors.Push(Class())
            constructors[A_Index].Base := %prototype.__Class%
            constructors[A_Index].Prototype := prototype
        }
        ; Handles the format codes.
        prototypes[FORMATSTR_TYPE_INDEX_FORMATCODE].FormatCodes := this.FormatCodes
        formatCodeMap := prototypes[FORMATSTR_TYPE_INDEX_FORMATCODE].FormatCodeMap := this.FormatCodeMap
        if this.FormatCodes {
            globalFormatCodes := this.GlobalFormatCodes := []
        } else {
            prototypes[FORMATSTR_TYPE_INDEX_FORMATCODE].DefineProp('FormatCodeFunction', { Value: '' })
            globalFormatCodes := prototypes[FORMATSTR_TYPE_INDEX_CONDITIONALGROUP].FormatCodes := ''
        }
        ; Handles the specifier codes.
        prototypes[FORMATSTR_TYPE_INDEX_FORMATSPECIFIER].Base.SpecifierCodes :=
        prototypes[FORMATSTR_TYPE_INDEX_FORMATCODE].SpecifierCodes := this.SpecifierCodes
        specifierCodeMap := prototypes[FORMATSTR_TYPE_INDEX_FORMATSPECIFIER].Base.SpecifierCodeMap :=
        prototypes[FORMATSTR_TYPE_INDEX_FORMATCODE].SpecifierCodeMap := this.SpecifierCodeMap
        if !this.SpecifierCodes {
            prototypes[FORMATSTR_TYPE_INDEX_FORMATSPECIFIER].Base.DefineProp('SpecifierCodeFunction', { Value: '' })
        }
        defaultFormatCodes :=
        prototypes[FORMATSTR_TYPE_INDEX_CONDITIONALGROUP].DefaultFormatCodes :=
        prototypes[FORMATSTR_TYPE_INDEX_DEFAULTFORMATCODE].FormatCodes :=
        FormatStrConstructor.DefaultFormatCodes
        defaultFormatCodeMap :=
        prototypes[FORMATSTR_TYPE_INDEX_CONDITIONALGROUP].DefaultFormatCodeMap :=
        prototypes[FORMATSTR_TYPE_INDEX_DEFAULTFORMATCODE].FormatCodeMap :=
        FormatStrConstructor.DefaultFormatCodeMap
        globalDefaultFormatCodes := this.GlobalDefaultFormatCodes := []
        formatCodeParams := prototypes[FORMATSTR_TYPE_INDEX_FORMATCODE].FormatCodeParams := FormatStr_FormatCodeParamsCollection()

        pos := 1
        ; The tokenizer makes three passes over `FormatStr`. The first pass handles any escape
        ; sequences. For consistency, all backslashes that precede a curly brace ( }{ ) or percent ( % )
        ; are treated as escape characters, whether or not the escape sequence was necessary in that
        ; context. Here we process escape sequences and replace with tokens indicating literal
        ; characters, which will later be re-replaced with the correct character.
        while RegExMatch(FormatStr, 's)(.*?)(\\+)([{}%])', &match, pos) {
            pos := match.Pos + match.Len
            _formatStr .= match[1]
            if match.Len[2] == 1 {
                switch match[3] {
                    case '{': _formatStr .= LITERAL_OPEN
                    case '}': _formatStr .= LITERAL_CLOSE
                    case '%': _formatStr .= LITERAL_PERCENT
                }
            } else {
                loop Floor(match.Len[2] / 2) {
                    _formatStr .= LITERAL_BACKSLASH
                }
                if Mod(match.Len[2], 2) {
                    switch match[3] {
                        case '{': _formatStr .= LITERAL_OPEN
                        case '}': _formatStr .= LITERAL_CLOSE
                        case '%': _formatStr .= LITERAL_PERCENT
                    }
                }
            }
        }
        _formatStr .= SubStr(FormatStr, pos)
        pos := 1
        if this.CaseSense {
            pattern := this.SubstringPattern
        } else {
            pattern := 'i)' this.SubstringPattern
        }
        namesMap := this.NamesMap
        ; The second pass is over `_formatStr` which now has all literal backslashes, curly braces
        ; and percents removed and replaced with tokens. `this.SubstringPattern` is the output from
        ; processing the names into a regex pattern. If the format specifier is directly enclosed in
        ; brackets, e.g. "{%line%}", then the token used is TOKEN_SIGNIFICANT_CONDITION. This is
        ; because that is the syntax for specifying a significant condition. If the format
        ; specifier is not enclosed directly in brackets, e.g. "{Extra: %extra%`n}", then the token
        ; used is TOKEN_FORMAT_SPECIFIER. Following the token is the index of the format specifier, which
        ; are arbitrary integers assigned in `FormatStrConstructor.Prototype.__New`. When the format
        ; string is processed later, the index is used to get the name of the format specifier at that
        ; location.
        while RegExMatch(_formatStr, pattern, &match, pos) {
            pos := match.Pos
            ; If the text between percent symbols matches with a format specifier name
            name := _ReplaceLiteralTokens(match['name'])
            if index := namesMap.Get(name) {
                ; If the format specifier is encompassed by curly braces
                if match['open'] && match['close'] {
                    ; If there is a specifier code
                    if match['code'] {
                        ; If specifier codes were provided
                        if specifierCodeMap {
                            code := _ReplaceLiteralTokens(match['code'])
                            ; If the specifier code matches with one of the provided specifier codes
                            if _index := specifierCodeMap.Get(code) {
                                _formatStr := StrReplace(_formatStr, match[0], TOKEN_SIGNIFICANT_CONDITION index ':' _index)
                            } else {
                                _ThrowMissingSpecifierCode(code)
                            }
                        } else {
                            _ThrowNoSpecifierCodes(code)
                        }
                    } else {
                        _formatStr := StrReplace(_formatStr, match[0], TOKEN_SIGNIFICANT_CONDITION index)
                    }
                } else {
                    if match['code'] {
                        if specifierCodeMap {
                            code := _ReplaceLiteralTokens(match['code'])
                            if _index := specifierCodeMap.Get(code) {
                                _formatStr := StrReplace(_formatStr, '%' match['specifier'] '%', TOKEN_FORMAT_SPECIFIER index ':' _index)
                            } else {
                                _ThrowMissingSpecifierCode(code)
                            }
                        } else {
                            _ThrowNoSpecifierCodes(code)
                        }
                    } else {
                        _formatStr := StrReplace(_formatStr, '%' match['specifier'] '%', TOKEN_FORMAT_SPECIFIER index)
                    }
                }
            } else {
                code := _ReplaceLiteralTokens(match['specifier'])
                if posColon := InStr(code, ':') {
                    formatCode := SubStr(code, 1, posColon - 1)
                    formatCodeParams.Push(SubStr(code, posColon + 1))
                    _index := ':' formatCodeParams.Length
                } else {
                    formatCode := code
                    _index := ''
                }
                ; If the text does not match and if format codes have been supplied, treat it as a format code
                if formatCodeMap {
                    if index := formatCodeMap.Get(formatCode) {
                        _formatStr := StrReplace(_formatStr, '%' match['specifier'] '%', TOKEN_FORMAT_CODE index _index)
                    } else if defaultFormatCodeMap.Has(formatCode) {
                        _formatStr := StrReplace(_formatStr, '%' match['specifier'] '%', TOKEN_FORMAT_CODE_DEFAULT defaultFormatCodeMap.Get(formatCode) _index)
                    } else {
                        ; If you get this error it means you provided a set of format codes but this
                        ; specific code was not found in the set. Check the spelling and case sense
                        ; option (default is off).
                        throw UnsetItemError('Missing format code.', -1, code)
                    }
                } else if defaultFormatCodeMap.Has(formatCode) {
                    _formatStr := StrReplace(_formatStr, '%' match['specifier'] '%', TOKEN_FORMAT_CODE_DEFAULT defaultFormatCodeMap.Get(formatCode) _index)
                } else {
                    ; If you get this error, it means that, in your format string, there is text enclosed
                    ; by percent symbols that was not found in the list of format specifier names.
                    ; If you aren't using format specifier codes, check the spelling and case sense
                    ; option (default is off).
                    throw Error('A format code was included in the format string, but no format codes have been supplied.', -1, code)
                }
            }
        }
        tokens := this.Tokens := FormatStr_TokenCollection()
        pos := 1
        pattern := '([' TOKEN_FORMAT_CODE TOKEN_FORMAT_CODE_DEFAULT TOKEN_FORMAT_SPECIFIER TOKEN_SIGNIFICANT_CONDITION '])(\d+)(?::(\d+))?'
        ; The third pass generates the token objects in the order in which the substrings appear
        ; in the format string, separating out the conditional groups to be handled separately
        ; from the other text.
        while RegExMatch(_formatStr, 's)([^{]*)\{(.+?)\}', &match, pos) {
            pos := match.Pos + match.Len
            ; If there is preceding text, process it separately.
            if match.Len[1] {
                _Proc(1, tokens, globalFormatCodes, FORMATSTR_TYPE_INDEX_SIMPLECONDITION)
            }
            ; If the text between the brackets contains one or more of TOKEN_FORMAT_SPECIFIER or TOKEN_SIGNIFICANT_CONDITION,
            ; process the text as a conditional group.
            if RegExMatch(match[2], pattern) {
                tokens.Push(constructors[FORMATSTR_TYPE_INDEX_CONDITIONALGROUP].Call(tokens.Length + 1, match[2]))
                _Proc(2, tokens[-1].Tokens, tokens[-1].FormatCodes, FORMATSTR_TYPE_INDEX_SIGNIFICANTCONDITION, tokens[-1])
                ; If the conditional group has one or more significant conditions
                if tokens[-1][4] {
                    ; This separates the significant condition tokens from the others so we can check those
                    ; first and fail early to avoid wasting processing time.
                    significantConditions := tokens[-1].SignificantConditions := FormatStr_TokenCollection()
                    for _token in tokens[-1].Tokens {
                        if _token.TypeIndex == FORMATSTR_TYPE_INDEX_SIGNIFICANTCONDITION {
                            significantConditions.Push(_token)
                        }
                    }
                } else {
                    ; Similarly, this separates the format specifier tokens from the others so we
                    ; can check those first and fail early to avoid wasting processing time.
                    replacmentStrings := tokens[-1].FormatSpecifiers := FormatStr_TokenCollection()
                    for _token in tokens[-1].Tokens {
                        if _token.TypeIndex == FORMATSTR_TYPE_INDEX_FORMATSPECIFIER {
                            replacmentStrings.Push(_token)
                        }
                    }
                }
            ; If the text does not have either token, process the text as plain text.
            } else {
                tokens.Push(constructors[FORMATSTR_TYPE_INDEX_PLAINTEXT].Call(tokens.Length + 1, '{' match[2] '}'))
            }
        }
        ; Process any trailing text.
        len := StrLen(_formatStr)
        if pos !== StrLen(_formatStr) + 1 {
            RegExMatch(_formatStr, 's)(.*)', &match, pos)
            _Proc(1, tokens, globalFormatCodes, FORMATSTR_TYPE_INDEX_SIMPLECONDITION)
        }

        ; Delete any empty format code arrays
        for token in this.Tokens {
            if token.TypeIndex == FORMATSTR_TYPE_INDEX_CONDITIONALGROUP {
                if IsObject(token.FormatCodes) && !token.FormatCodes.Length {
                    token.DefineProp('FormatCodes', { Value: '' })
                }
            }
        }

        return

        _GetChar() {
            while InStr(FormatStr, Chr(n)) {
                n++
            }
            return Chr(n)
        }
        ; Parameter `significantConditionIndex` specifies what type index should be used when
        ; encountering TOKEN_SIGNIFICANT_CONDITION. If we find a TOKEN_SIGNIFICANT_CONDITION outside
        ; of a conditional group, then it is actually just a conditional group with one condition
        ; and no extra text. I included class `FormatStrToken_SimpleCondition` to identify
        ; these cases so later our code can make quick work of the format specifier and avoid all
        ; the extra logic needed to handle the other types.
        _Proc(index, tokens, formatCodes, significantConditionIndex, token := '') {
            local pos, _match
            pos := 1
            while RegExMatch(match[index], pattern, &_match, pos) {
                ; Treat leading text as plain text.
                if _match.Pos !== pos {
                    tokens.Push(constructors[FORMATSTR_TYPE_INDEX_PLAINTEXT].Call(tokens.Length + 1, SubStr(_ReplaceLiteralTokens(match[index]), pos, _match.Pos - pos)))
                }
                switch _match[1] {
                    case TOKEN_FORMAT_CODE:
                        if formatCodes is FormatStr_FormatCodesCollection {
                            formatCode := formatCodeMap.Get(_match[2])
                            formatCodeFunction := formatCodes.Get(defaultFormatCode, &formatCodeType)
                            switch formatCodeType {
                                case FORMATSTR_FORMATCODE_TYPE_CALL_EARLY:
                                    formatCodeFunction(formatCode, _match[3], token, this)
                                case FORMATSTR_FORMATCODE_TYPE_CALL_STANDARD:
                                    if token {
                                        formatCodes.Push(constructors[FORMATSTR_TYPE_INDEX_FORMATCODE].Call(tokens.Length + 1, _match[2], _match[3]))
                                    } else {
                                        globalFormatCodes.Push(constructors[FORMATSTR_TYPE_INDEX_FORMATCODE].Call(tokens.Length + 1, _match[2], _match[3]))
                                    }
                            }
                        } else {
                            formatCodes.Push(constructors[FORMATSTR_TYPE_INDEX_FORMATCODE].Call(tokens.Length + 1, _match[2], _match[3]))
                        }
                    case TOKEN_FORMAT_CODE_DEFAULT:
                        defaultFormatCode := defaultFormatCodeMap.Get(_match[2])
                        formatCodeFunction := defaultFormatCodes.Get(defaultFormatCode, &formatCodeType)
                        switch formatCodeType {
                            case FORMATSTR_FORMATCODE_TYPE_CALL_EARLY:
                                formatCodeFunction(defaultFormatCode, _match[3], token, this)
                            case FORMATSTR_FORMATCODE_TYPE_CALL_STANDARD:
                                if token {
                                    token.AddDefaultFormatCode(constructors[FORMATSTR_TYPE_INDEX_DEFAULTFORMATCODE].Call(tokens.Length + 1, _match[2], _match[3]))
                                } else {
                                    globalDefaultFormatCodes.Push(constructors[FORMATSTR_TYPE_INDEX_DEFAULTFORMATCODE].Call(tokens.Length + 1, _match[2], _match[3]))
                                }
                        }
                    case TOKEN_FORMAT_SPECIFIER:
                        tokens.Push(constructors[FORMATSTR_TYPE_INDEX_FORMATSPECIFIER].Call(tokens.Length + 1, _match[2], _match[3]))
                    case TOKEN_SIGNIFICANT_CONDITION:
                        tokens.Push(constructors[significantConditionIndex].Call(tokens.Length + 1, _match[2], _match[3]))
                }
                pos := _match.Pos + _match.Len
            }
            if pos !== StrLen(match[index]) + match.Pos[index] {
                ; Treat trailing text as plaintext.
                tokens.Push(constructors[FORMATSTR_TYPE_INDEX_PLAINTEXT].Call(tokens.Length + 1, _ReplaceLiteralTokens(SubStr(match[index], pos, StrLen(match[index]) + match.Pos[index] - pos + 1))))
            }
        }
        _ReplaceLiteralTokens(str) => StrReplace(StrReplace(StrReplace(StrReplace(str, LITERAL_BACKSLASH, '\'), LITERAL_CLOSE, '}'), LITERAL_PERCENT, '%'), LITERAL_OPEN, '{')
        _ThrowMissingSpecifierCode(code) {
            ; If you get this error it means that your format string contains a format specifier that
            ; is followed by a colon character and some text, and also you provided a set of specifier
            ; codes, but that particular code is absent from the set. Check the spelling and case sense
            ; option (default is off).
            throw UnsetItemError('Missing specifier code.', -1, code)
        }
        _ThrowNoSpecifierCodes(code) {
            ; If you get this error it means that your format string contains a format specifier that
            ; is followed by a colon character and some text, but you did not provide any specifier
            ; codes (which are passed as an option to `FormatStrConstructor`.
            throw Error('A specifier code was included in a format specifier, but no specifer codes have been supplied.', -1, code)
        }
    }

    Call(Params := '', Callback?) {
        if !IsSet(Callback) {
            Callback := this.Callback
        }
        ; LITERAL_BACKSLASH := this.LITERAL_BACKSLASH
        ; LITERAL_CLOSE := this.LITERAL_CLOSE
        ; LITERAL_PERCENT := this.LITERAL_PERCENT
        ; LITERAL_OPEN := this.LITERAL_OPEN
        ; TOKEN_SIGNIFICANT_CONDITION := this.TOKEN_SIGNIFICANT_CONDITION
        ; TOKEN_FORMAT_SPECIFIER := this.TOKEN_FORMAT_SPECIFIER
        formatCodes := this.FormatCodes
        specifierCodes := this.SpecifierCodes
        tokens := this.Tokens

        if this.ReturnArray {
            result := []
            result.Capacity := tokens.Length

            for token in tokens {
                switch token.TypeIndex {
                    case FORMATSTR_TYPE_INDEX_CONDITIONALGROUP:
                        ; If the conditional group has one or more significant conditions
                        if token[4] {
                            ; One or more format specifiers specified as a significant condition
                            ; must be replaced by one or more characters for the text to be included
                            ; in the output.
                            replacementResults := []
                            replacementResults.Capacity := token.SignificantConditions.Length
                            ; Flag to indicate all format specifiers must be replaced with one or more
                            ; characters to satisfy the condition.
                            if token.Flags.Get(FORMATSTR_FLAG_ALLCONDITIONS) {
                                flag_replace := true
                                for _token in token.SignificantConditions {
                                    replacementResults.Push(Callback(_token.FormatSpecifierName, Params, _token, token))
                                    if !replacementResults[-1] {
                                        flag_replace := false
                                    }
                                }
                            } else {
                                flag_replace := false
                                for _token in token.SignificantConditions {
                                    replacementResults.Push(Callback(_token.FormatSpecifierName, Params, _token, token))
                                    if replacementResults[-1] {
                                        flag_replace := true
                                        break
                                    }
                                }
                            }
                            group := []
                            group.Capacity := token.Tokens.Length
                            for _token in token.Tokens {
                                switch _token.TypeIndex {
                                    case FORMATSTR_TYPE_INDEX_PLAINTEXT:
                                        group.Push({ Token: _token, Value: _token[2] })
                                    case FORMATSTR_TYPE_INDEX_FORMATSPECIFIER:
                                        if _token[3] {
                                            group.Push({ Token: _token, Value: _token.SpecifierCodeFunction.Call(Callback(_token.FormatSpecifierName, Params, _token, token), Params, _token, token) })
                                        } else {
                                            group.Push({ Token: _token, Value: Callback(_token.FormatSpecifierName, Params, _token, token) })
                                        }
                                    case FORMATSTR_TYPE_INDEX_SIGNIFICANTCONDITION:
                                        if _token[3] {
                                            if replacementResults.Length {
                                                group.Push({ Token: _token, Value: _token.SpecifierCodeFunction.Call(replacementResults.RemoveAt(1), Params, _token, token) })
                                            } else {
                                                group.Push({ Token: _token, Value: _token.SpecifierCodeFunction.Call(Callback(_token.FormatSpecifierName, Params, _token, token), Params, _token, token) })
                                            }
                                        } else {
                                            if replacementResults.Length {
                                                group.Push({ Token: _token, Value: replacementResults.RemoveAt(1) })
                                            } else {
                                                group.Push({ Token: _token, Value: Callback(_token.FormatSpecifierName, Params, _token, token) })
                                            }
                                        }
                                }
                            }
                        } else {
                            ; One or more format specifiers must be replaced by one or more characters
                            ; for the text to be included in the output.
                            replacementResults := []
                            replacementResults.Capacity := token.FormatSpecifiers.Length
                            ; Flag to indicate all format specifiers must be replaced with one or more
                            ; characters to satisfy the condition.
                            if token.Flags.Get(FORMATSTR_FLAG_ALLCONDITIONS) {
                                flag_replace := true
                                for _token in token.FormatSpecifiers {
                                    replacementResults.Push(Callback(_token.FormatSpecifierName, Params, _token, token))
                                    if !replacementResults[-1] {
                                        flag_replace := false
                                    }
                                }
                            } else {
                                flag_replace := false
                                for _token in token.FormatSpecifiers {
                                    replacementResults.Push(Callback(_token.FormatSpecifierName, Params, _token, token))
                                    if replacementResults[-1] {
                                        flag_replace := true
                                        break
                                    }
                                }
                            }
                            group := []
                            group.Capacity := token.Tokens.Length
                            for _token in token.Tokens {
                                switch _token.TypeIndex {
                                    case FORMATSTR_TYPE_INDEX_PLAINTEXT:
                                        group.Push({ Token: _token, Value: _token[2] })
                                    case FORMATSTR_TYPE_INDEX_FORMATSPECIFIER:
                                        if _token[3] {
                                            if replacementResults.Length {
                                                group.Push({ Token: _token, Value: _token.SpecifierCodeFunction.Call(replacementResults.RemoveAt(1), Params, _token, token) })
                                            } else {
                                                group.Push({ Token: _token, Value: _token.SpecifierCodeFunction.Call(Callback(_token.FormatSpecifierName, Params, _token, token), Params, _token, token) })
                                            }
                                        } else {
                                            if replacementResults.Length {
                                                group.Push({ Token: _token, Value: replacementResults.RemoveAt(1) })
                                            } else {
                                                group.Push({ Token: _token, Value: Callback(_token.FormatSpecifierName, Params, _token, token) })
                                            }
                                        }
                                }
                            }
                        }
                        if flag_replace {
                            if token.FormatCodes {
                                for formatCode in token.FormatCodes {
                                    formatCode.FormatCodeFunction.Call(group, Params, formatCode.Params, token)
                                }
                            }
                            if token[5] {
                                for defaultFormatCode in token.DefaultFormatCodes {
                                    defaultFormatCode.FormatCodeFunction.Call(group, Params, formatCode.Params, token)
                                }
                            }
                        }
                        result.Push({ Token: Token, Value: group, Condition: flag_replace })
                    case FORMATSTR_TYPE_INDEX_FORMATSPECIFIER:
                        if token[3] {
                            result.Push({ Token: token, Value: token.SpecifierCodeFunction.Call(Callback(token.FormatSpecifierName, Params, token, ''), Params, token, '') })
                        } else {
                            result.Push({ Token: token, Value: Callback(token.FormatSpecifierName, Params, token, '') })
                        }
                    case FORMATSTR_TYPE_INDEX_PLAINTEXT:
                        result.Push({ Token: token, Value: token[2] })
                    case FORMATSTR_TYPE_INDEX_SIMPLECONDITION:
                        if _str := Callback(token.FormatSpecifierName, Params, token, '') {
                            if token[3] {
                                result.Push({ Token: token, Value: token.SpecifierCodeFunction.Call(_str, Params, token, '') })
                            } else {
                                result.Push({ Token: token, Value: _str })
                            }
                        }
                }
            }
            if this.GlobalFormatCodes {
                for formatCode in this.GlobalFormatCodes {
                    formatCode.FormatCodeFunction.Call(result, Params, formatCode.Params, '')
                }
            }
            for defaultFormatCode in this.GlobalDefaultFormatCodes {
                defaultFormatCode.FormatCodeFunction.Call(result, Params, defaultFormatCode.Params, '')
            }

            return result
        } else {
            strCapacity := this.StrCapacity
            strCapacity2 := this.StrCapacity / 2
            str := ''
            VarSetStrCapacity(&str, strCapacity)

            for token in tokens {
                switch token.TypeIndex {
                    case FORMATSTR_TYPE_INDEX_CONDITIONALGROUP:
                        ; If the conditional group has one or more significant conditions
                        if token[4] {
                            ; One or more format specifiers specified as a significant condition
                            ; must be replaced by one or more characters for the text to be included
                            ; in the output.
                            replacementResults := []
                            replacementResults.Capacity := token.SignificantConditions.Length
                            ; Flag to indicate all format specifiers must be replaced with one or more
                            ; characters to satisfy the condition.
                            if token.Flags.Get(FORMATSTR_FLAG_ALLCONDITIONS) {
                                flag_replace := true
                                for _token in token.SignificantConditions {
                                    replacementResults.Push(Callback(_token.FormatSpecifierName, Params, _token, token))
                                    if !replacementResults[-1] {
                                        continue 2
                                    }
                                }
                            } else {
                                flag_replace := false
                                for _token in token.SignificantConditions {
                                    replacementResults.Push(Callback(_token.FormatSpecifierName, Params, _token, token))
                                    if replacementResults[-1] {
                                        flag_replace := true
                                        break
                                    }
                                }
                            }
                            if !flag_replace {
                                continue
                            }
                            _str := ''
                            VarSetStrCapacity(&_str, strCapacity2)
                            for _token in token.Tokens {
                                switch _token.TypeIndex {
                                    case FORMATSTR_TYPE_INDEX_PLAINTEXT:
                                        _str .= _token[2]
                                    case FORMATSTR_TYPE_INDEX_FORMATSPECIFIER:
                                        if _token[3] {
                                            _str .= _token.SpecifierCodeFunction.Call(Callback(_token.FormatSpecifierName, Params, _token, token), Params, _token, token)
                                        } else {
                                            _str .= Callback(_token.FormatSpecifierName, Params, _token, token)
                                        }
                                    case FORMATSTR_TYPE_INDEX_SIGNIFICANTCONDITION:
                                        if _token[3] {
                                            if replacementResults.Length {
                                                _str .= _token.SpecifierCodeFunction.Call(replacementResults.RemoveAt(1), Params, _token, token)
                                            } else {
                                                _str .= _token.SpecifierCodeFunction.Call(Callback(_token.FormatSpecifierName, Params, _token, token), Params, _token, token)
                                            }
                                        } else {
                                            if replacementResults.Length {
                                                _str .= replacementResults.RemoveAt(1)
                                            } else {
                                                _str .= Callback(_token.FormatSpecifierName, Params, _token, token)
                                            }
                                        }
                                }
                            }
                        } else {
                            ; One or more format specifiers must be replaced by one or more characters
                            ; for the text to be included in the output.
                            replacementResults := []
                            replacementResults.Capacity := token.FormatSpecifiers.Length
                            ; Flag to indicate all format specifiers must be replaced with one or more
                            ; characters to satisfy the condition.
                            if token.Flags.Get(FORMATSTR_FLAG_ALLCONDITIONS) {
                                flag_replace := true
                                for _token in token.FormatSpecifiers {
                                    replacementResults.Push(Callback(_token.FormatSpecifierName, Params, _token, token))
                                    if !replacementResults[-1] {
                                        continue 2
                                    }
                                }
                            } else {
                                flag_replace := false
                                for _token in token.FormatSpecifiers {
                                    replacementResults.Push(Callback(_token.FormatSpecifierName, Params, _token, token))
                                    if replacementResults[-1] {
                                        flag_replace := true
                                        break
                                    }
                                }
                            }
                            if !flag_replace {
                                continue
                            }
                            _str := ''
                            VarSetStrCapacity(&_str, strCapacity2)
                            for _token in token.Tokens {
                                switch _token.TypeIndex {
                                    case FORMATSTR_TYPE_INDEX_PLAINTEXT:
                                        _str .= _token[2]
                                    case FORMATSTR_TYPE_INDEX_FORMATSPECIFIER:
                                        if _token[3] {
                                            if replacementResults.Length {
                                                _str .= _token.SpecifierCodeFunction.Call(replacementResults.RemoveAt(1), Params, _token, token)
                                            } else {
                                                _str .= _token.SpecifierCodeFunction.Call(Callback(_token.FormatSpecifierName, Params, _token, token), Params, _token, token)
                                            }
                                        } else {
                                            if replacementResults.Length {
                                                _str .= replacementResults.RemoveAt(1)
                                            } else {
                                                _str .= Callback(_token.FormatSpecifierName, Params, _token, token)
                                            }
                                        }
                                }
                            }
                        }
                        if token.FormatCodes {
                            for formatCode in token.FormatCodes {
                                formatCode.FormatCodeFunction.Call(&_str, Params, formatCode.Params, token)
                            }
                        }
                        if token[5] {
                            for defaultFormatCode in token.DefaultFormatCodes {
                                defaultFormatCode.FormatCodeFunction.Call(&_str, Params, formatCode.Params, token)
                            }
                        }
                        str .= _str
                    case FORMATSTR_TYPE_INDEX_FORMATSPECIFIER:
                        if token[3] {
                            str .= token.SpecifierCodeFunction.Call(Callback(token.FormatSpecifierName, Params, token, ''), Params, token, '')
                        } else {
                            str .= Callback(token.FormatSpecifierName, Params, token, '')
                        }
                    case FORMATSTR_TYPE_INDEX_PLAINTEXT:
                        str .= token[2]
                    case FORMATSTR_TYPE_INDEX_SIMPLECONDITION:
                        if _str := Callback(token.FormatSpecifierName, Params, token, '') {
                            if token[3] {
                                str .= token.SpecifierCodeFunction.Call(_str, Params, token, '')
                            } else {
                                str .= _str
                            }
                        }
                }
            }
            if this.GlobalFormatCodes {
                for formatCode in this.GlobalFormatCodes {
                    formatCode.FormatCodeFunction.Call(&str, Params, formatCode.Params, '')
                }
            }
            for defaultFormatCode in this.GlobalDefaultFormatCodes {
                defaultFormatCode.FormatCodeFunction.Call(&str, Params, defaultFormatCode.Params, '')
            }

            return str
        }
    }
}

#include ..\src

/**
 * ## Lists of node types
 *
 * The following information is regarding variables that contain a comma-separated list of node type
 * integers. Specifically:
 * - PIT_CONTEXTMENU_EXPAND_NODETYPE
 *
 * If you modify one of these variables, the string must begin and end with a comma and there must
 * be no whitespace. The format is ",<int>,<int>,...,<int>,".
 * @example
 * PIT_CONTEXTMENU_EXPAND_NODETYPE := (
 *     "," PROPSINFOTREE_NODETYPE_ENUMGROUP
 *     "," PROPSINFOTREE_NODETYPE_OBJECT
 *     "," PROPSINFOTREE_NODETYPE_ROOT
 *     ","
 * )
 * @
 */
PropsInfoTree_SetConstants(force := false) {
    global
    if !force && IsSet(PropsInfoTree_constants_set) {
        return
    }

    local i := 0
    PROPSINFOTREE_NODETYPE_BASE := ++i
    PROPSINFOTREE_NODETYPE_CALL := ++i
    PROPSINFOTREE_NODETYPE_CALLGROUP := ++i
    PROPSINFOTREE_NODETYPE_COMVALUE := ++i
    PROPSINFOTREE_NODETYPE_DYNAMIC := ++i
    PROPSINFOTREE_NODETYPE_DYNAMICGROUP := ++i
    PROPSINFOTREE_NODETYPE_ENUMERROR := ++i
    PROPSINFOTREE_NODETYPE_ENUMGROUP := ++i
    PROPSINFOTREE_NODETYPE_ERROR := ++i
    PROPSINFOTREE_NODETYPE_GET := ++i
    PROPSINFOTREE_NODETYPE_GETGROUP := ++i
    PROPSINFOTREE_NODETYPE_NUMBER := ++i
    PROPSINFOTREE_NODETYPE_OBJECT := ++i
    PROPSINFOTREE_NODETYPE_ROOT := ++i
    PROPSINFOTREE_NODETYPE_SET := ++i
    PROPSINFOTREE_NODETYPE_SETGROUP := ++i
    PROPSINFOTREE_NODETYPE_STRING := ++i
    PROPSINFOTREE_NODETYPE_UNSETARRAYITEM := ++i
    PROPSINFOTREE_NODETYPE_VALUE := ++i
    PROPSINFOTREE_NODETYPE_END := i

    /**
     * Used by {@link PropsInfoTree_ContextMenu_ExpandCallback} to choose what nodes to expand
     * when {@link ExpandRecursiveNotifySelective} is activated from the context menu.
     *
     * See the information about lists of node types in the description above
     * {@link PropsInfoTree_SetConstants}.
     *
     * The default value includes PROPSINFOTREE_NODETYPE_ENUMGROUP, PROPSINFOTREE_NODETYPE_OBJECT,
     * and PROPSINFOTREE_NODETYPE_ROOT.
     *
     * @var
     * @type {String}
     */
    PIT_CONTEXTMENU_EXPAND_NODETYPE := (
        ',' PROPSINFOTREE_NODETYPE_ENUMGROUP
        ',' PROPSINFOTREE_NODETYPE_OBJECT
        ',' PROPSINFOTREE_NODETYPE_ROOT
        ','
    )

    /**
     * Used by {@link PropsInfoTree_ContextMenu_ExpandCallback} when {@link ExpandRecursiveNotifySelective}
     * is activated from the context menu. If the number of expanded nodes exceeds this value,
     * {@link ExpandRecursiveNotifySelective} is directed to end the function call.
     * @var
     * @type {Integer}
     */
    PIT_CONTEXTMENU_EXPAND_MAXNODES := 64

    PropsInfoTree_constants_set := 1
}

PropsInfoTree_StrEscape(Str, MaxChars?) {
    if IsSet(MaxChars) && StrLen(Str) > MaxChars {
        return SubStr(StrReplace(StrReplace(StrReplace(StrReplace(Str, '``', '````'), '`n', '``n'), '`r', '``r'), '"', '``"'), 1, MaxChars) '...'
    } else {
        return StrReplace(StrReplace(StrReplace(StrReplace(Str, '``', '````'), '`n', '``n'), '`r', '``r'), '"', '``"')
    }
}

PropsInfoTree_GetDisplayType(value, *) {
    if value is ComValue {
        return Type(value)
    } else if ObjHasOwnProp(value, '__Class') {
        return 'Prototype : ' value.__Class
    } else if value is Class {
        return 'Class : ' value.Prototype.__Class
    } else {
        return value.__Class
    }
}

PropsInfoTree_GetType_Accessors(value, node) {
    return Type(value) ' : ' node.Accessor
}

PropsInfoTree_SetNodeConstructor(PropsInfoTreeObj, PropsInfoTreeOptions) {
    for obj in PropsInfoTree.NodeTypes {
        ; Each of these individual constructor properties can be used to make changes that affect
        ; just the relevant nodes associated with this PropsInfoTree object. These are also used
        ; to construct new node objects.
        constructor := PropsInfoTreeObj.NodeConstructor_%obj.Name% := TreeViewEx_NodeConstructor()
        constructor.Prototype := { PropsInfoTreeOptions: PropsInfoTreeOptions, HwndCtrl: PropsInfoTreeObj.Hwnd, __Class: obj.Class.Prototype.__Class }
        ObjSetBase(constructor.Prototype, obj.Class.Prototype)
    }
}

PropsInfoTree_ShowTooltip(Str) {
    static N := [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
    Z := N.Pop()
    OM := CoordMode('Mouse', 'Screen')
    OT := CoordMode('Tooltip', 'Screen')
    MouseGetPos(&x, &y)
    Tooltip(Str, x + 10, y + 10, Z)
    SetTimer(_End.Bind(Z), -1500)
    CoordMode('Mouse', OM)
    CoordMode('Tooltip', OT)

    _End(Z) {
        ToolTip(,,,Z)
        N.Push(Z)
    }
}

PropsInfoTree_CallbackValue_Name(value) {
    return value.Name
}

PropsInfoTree_CallbackValue_Type(value) {
    return value.Type
}

/**
 * @description - Converts a string path to an object reference. The object at the input path must
 * exist in the current scope of the function call.
 * @param {String} Str - The object path.
 * @param {Object} [InitialObj] - If set, the object path will be parsed as a property / item of
 * this object.
 * @returns {Object} - The object reference.
 * @example
 *  Obj := {
 *      Prop1: [1, 2, Map(
 *              'key1', 'value1',
 *              'key2', {prop2: 2, prop3: [3, 4]}
 *          )
 *      ]
 *  }
 *  Path := 'obj.prop1[3]["key2"].prop3'
 *  ObjReference := GetObjectFromString(Path)
 *  OutputDebug(ObjReference[2]) ; 4
 * @
 * This is compatible with class references.
 * @example
 *
 *  class Test {
 *      class NestedClass {
 *          InstanceProp {
 *              Get{
 *                  return ['Val1', { Prop: 'Hello, world!' }]
 *              }
 *          }
 *      }
 *  }
 *  Path := 'Test.NestedClass.Prototype.InstanceProp[2]'
 *  Obj := GetObjectFromString(Path)
 *  OutputDebug(Obj.Prop) ; Hello, world!
 * @
 * Using an initial object.
 * @example
 *  Obj := {
 *      Prop1: [1, 2, Map(
 *              'key1', 'value1',
 *              'key2', {prop2: 2, prop3: [3, 4]}
 *          )
 *      ]
 *  }
 *  Path := '[3]["key2"].prop3'
 *  Arr := Obj.Prop1
 *  InnerArr := GetObjectFromString(Path, Arr)
 *  OutputDebug(InnerArr[2]) ; 4
 * @
 *
 */
PropsInfoTree_GetObjectFromString(Str, InitialObj?) {
    if IsSet(InitialObj) {
        NewObj := InitialObj
        Pos := 1
        if SubStr(Str, 1, 1) !== '.' {
            Str := '.' Str
        }
    } else {
        RegExMatch(Str, '^[\w\d_]+', &InitialSegment)
        Pos := InitialSegment.Pos + InitialSegment.Len
        NewObj := %InitialSegment[0]%
    }
    while RegExMatch(Str, 'S)(?<=\.)[\w_\d]+(?COnProp)|\[\s*\K-?\d+(?COnIndex)|\[\s*(?<quote>[`'"])(?<key>.*?)(?<!``)(?:````)*\g{quote}(?COnKey)', &Match, Pos) {
        Pos := Match.Pos + Match.Len
    }

    return NewObj

    OnProp(Match, *) {
        NewObj := NewObj.%Match[0]%
    }
    OnIndex(Match, *) {
        NewObj := NewObj[Number(Match[0])]
    }
    OnKey(Match, *) {
        NewObj := NewObj[Match['key']]
    }
}

PropsInfoTree_CallbackCallEnum(node) {
    return node.Value is Array ? 1 : 2
}

PropsInfoTree_PreviewFormat_SpecifierCode_Split_Quoted(Str, *) {
    ; Quotation mark to make up for losing one from the split
    return '"' StrSplit(Str, ' ')[2]
}

PropsInfoTree_PreviewFormat_SpecifierCode_Split(Str, *) {
    return StrSplit(Str, ' ')[2]
}


/**
 * Use {@link PropsInfoTree_CallbackList} for any option for which you need to supply multiple
 * callback functions. When the option is invoked, this will iterate the functions in the list,
 * calling each consecutively until a function returns a nonzero value, or until they have all been
 * called, whichever occurs first.
 */
class PropsInfoTree_CallbackList extends Container {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.ToCbString(PropsInfoTree_CallbackValue_Name, , LINGUISTIC_IGNORECASE)
    }
    __New(Items?) {
        if IsSet(Items) {
            this.InsertList(Items)
        }
    }
    Call(Params*) {
        for callback in this {
            if value := callback(Params*) {
                return value
            }
        }
    }
}

class PropsInfoTree_ContextMenu extends TreeViewEx_ContextMenu {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.DefaultItems := Container.Prototype.DeepClone.Call(TreeViewEx_ContextMenu.Prototype.DefaultItems)
        ; Used accelerators: A, B, C, D, E, F, H, I, J, K, O, P, Q, R, S, T, V, W, X, Z
        proto.DefaultItems.Push(
            { Name: 'Add as root node (&R)', Value: 'SelectAddAsRootNode' }
          , { Name: 'Add object root node (&Y)', Value: 'SelectAddObjectAsRootNode' }
          , { Name: 'Copy object path (&J)', Value: 'SelectCopyObjectPath' }
          , { Name: 'Copy object property list (&H)', Value: 'SelectCopyObjectPropertyList' }
          , { Name: 'Copy object property list with values (&I)', Value: 'SelectCopyObjectPropertyListWithValues' }
          , { Name: 'Copy value (&K)', Value: 'SelectCopyValue' }
        )
        proto.__node := ''
    }
    Dispose() {
        if this.HasOwnProp('TvexTabCollection') {
            this.TvexTabCollection.Clear()
            this.DeleteProp('TvexTabCollection')
        }
        if this.HasOwnProp('__node') {
            this.DeleteProp('__node')
        }
    }
    HandlerItemAvailability(Ctrl, IsRightClick, Item, X, Y) {
        super.HandlerItemAvailability(Ctrl, IsRightClick, Item, X, Y)
        items := this.__Item
        if Item {
            this.__node := Ctrl.GetNode_Ptr(Item)
            if HasMethod(this.__node, 'AddAsRoot') {
                items.Get('Add as root node (&R)').Enable()
                if items.Has('Add as new tab (&V)') {
                    items.Get('Add as new tab (&V)').Enable()
                }
            } else {
                items.Get('Add as root node (&R)').Disable()
                if items.Has('Add as new tab (&V)') {
                    items.Get('Add as new tab (&V)').Disable()
                }
            }
            if this.__node.PropsInfo {
                items.Get('Copy object property list (&H)').Enable()
            } else {
                items.Get('Copy object property list (&H)').Disable()
            }
            if IsObject(this.__node.Value) {
                items.Get('Copy value (&K)').Disable()
            } else {
                items.Get('Copy value (&K)').Enable()
            }
        } else {
            items.Get('Add as root node (&R)').Disable()
            if items.Has('Add as new tab (&V)') {
                items.Get('Add as new tab (&V)').Disable()
            }
            items.Get('Copy object property list (&H)').Disable()
            items.Get('Copy value (&K)').Disable()
        }
    }
    RegisterTreeViewExTab(HwndPit, TvexTab, CallbackAdd, CallbackDelete) {
        if IsSet(TreeViewEx_Tab) {
            if !this.HasOwnProp('TvexTabCollection') {
                this.DefineProp('TvexTabCollection', { Value: TreeViewExCollection_TvexTabCollection() })
                this.AddObject({ Name: 'Add as new tab (&V)', Value: 'SelectAddAsNewTab' })
                this.AddObject({ Name: 'Delete tab', Value: 'SelectDeleteTab' })
            }
            this.TvexTabCollection.Set(HwndPit, { TvexTabId: TvexTab.Id, CallbackAdd: CallbackAdd, CallbackDelete: CallbackDelete })
        } else {
            ; If you get this error, make sure you have a copy of TreeViewEx_Tab.ahk in your lib folder,
            ; and `#include <TreeViewEx_Tab>` within the script that is using this feature.
            throw UnsetError('The class ``TreeViewEx_Tab`` is not found.')
        }
    }
    SelectAddAsRootNode(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        this.__node.AddAsRoot()
        Ctrl.Redraw()
    }
    SelectAddAsNewTab(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        obj := this.TvexTabCollection.Get(Ctrl.Hwnd)
        pit := obj.CallbackAdd.Call(TreeViewEx_Tab.Get(obj.TvexTabId), this.__node, Ctrl)
        this.TvexTabCollection.Set(pit.Hwnd, obj)
    }
    SelectAddObjectAsRootNode(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        options := {
            Title: 'Add object as root node'
          , Message: 'Input object path:'
          , CallbackOk: CallbackOk
          , CallbackTest: CallbackTest
          , CallbackCancel: CallbackCancel
          , Ctrl: Ctrl
        }

        this.ShowInputWindow(options)

        CallbackOk(text, g) {
            try {
                obj := PropsInfoTree_GetObjectFromString(text)
                g.options.Ctrl.AddRootNode(obj, text)
                g.Hide()
                g.options.DeleteProp('Ctrl')
            } catch {
                return 'Object not found. Input object path:'
            }
        }
        CallbackTest(text, g) {
            try {
                obj := PropsInfoTree_GetObjectFromString(text)
                return 'Ok'
            } catch {
                return 'Not found'
            }
        }
        CallbackCancel(text, g) {
            g.Hide()
        }
    }
    SelectCopyObjectPath(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        A_Clipboard := Ctrl.GetNode_Ptr(Item).Path.Call()
        return 'Copied: ' A_Clipboard
    }
    SelectCopyObjectPropertyList(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        A_Clipboard := this.__node.PropsInfo.ToList(true, '`n', true, true, true, true, true, '`n`n')
        return 'Copied: ' A_Clipboard
    }
    SelectCopyObjectPropertyListWithValues(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        if this.__node.PropsInfo {
            A_Clipboard := this.__node.PropsInfo.ToList(false, '`n', true, true, true, true, true, '`n`n')
            return 'Copied: ' A_Clipboard
        } else {
            return 'Cannot copy this value.'
        }
    }
    SelectCopyValue(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        A_Clipboard := this.__node.Value
        return 'Copied: ' A_Clipboard
    }
    SelectDeleteTab(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        obj := this.TvexTabCollection.Get(Ctrl.Hwnd)
        this.TvexTabCollection.Delete(Ctrl.Hwnd)
        obj.CallbackDelete.Call(TreeViewEx_Tab.Get(obj.TvexTabId), Ctrl)
    }
    SelectExpandRecursive(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        global PropsInfoTree_ContextMenu_ExpandCallback_count := 0
        Ctrl.SetRedraw(0)
        Ctrl.ExpandRecursiveNotifySelective(PropsInfoTree_ContextMenu_ExpandCallback, Item)
        Ctrl.EnsureVisible(SendMessage(TVM_GETNEXTITEM, TVGN_ROOT, 0, Ctrl.Hwnd))
        Ctrl.SetRedraw(1)
        return 'Expanded from node: ' Ctrl.GetText(Item)
    }
    SelectExpandAllRecursive(Name, ItemPos, MenuObj, GuiObj, Ctrl, Item) {
        global PropsInfoTree_ContextMenu_ExpandCallback_count := 0
        Ctrl.SetRedraw(0)
        Ctrl.ExpandRecursiveNotifySelective(PropsInfoTree_ContextMenu_ExpandCallback)
        Ctrl.EnsureVisible(SendMessage(TVM_GETNEXTITEM, TVGN_ROOT, 0, Ctrl.Hwnd))
        Ctrl.SetRedraw(1)
        return 'Expanded all nodes'
    }
    ShowInputWindow(Options) {
        CoordMode('Mouse', 'Screen')
        MouseGetPos(&x, &y)
        if this.HasOwnProp('InputWindow') {
            try {
                g := this.InputWindow
                g.Title := Options.Title
                g['TxtMessage'].TextEx := Options.Message
                g['TxtTest'].Text := ''
                g['EdtInput'].Text := ''
                g.GetPos(, , &w, &h)
                g.Show('x' (x - w * 0.5) ' y' (y - h * 0.5))
                return
            }
        }
        eventHandler := PropsInfoTree_ContextMenu.InputWindowEventHandler()
        g := this.InputWindow := Gui(, Options.Title, eventHandler)
        g.EventHandler := eventHandler
        g.options := Options
        lf := Options.Ctrl.GetFont()
        g.SetFont('s' lf.FontSize, lf.FaceName)
        g.Add('Text', 'Section vTxtMessage', Options.Message)
        g.Add('Edit', 'xs w350 vEdtInput')
        g.Add('Button', 'xs Section vBtnOk', 'Ok').OnEvent('Click', 'HClickButtonOk')
        g.Add('Button', 'ys vBtnCancel', 'Cancel').OnEvent('Click', 'HClickButtonCancel')
        g.Add('Button', 'ys vBtnTest', 'Test').OnEvent('Click', 'HClickButtonTest')
        g.Add('Text', 'ys vTxtTest', '--')
        g['TxtTest'].GetPos(, &txty, , &txth)
        g.Show('x' (x - 185) ' y' (y - (txty + txth + g.MarginY * 2)))
    }

    class InputWindowEventHandler {
        HClickButtonOk(Ctrl, *) {
            g := Ctrl.Gui
            if result := g.options.CallbackOk.Call(g['EdtInput'].Text, g) {
                g['TxtMessage'].TextEx := result
            }
        }
        HClickButtonTest(Ctrl, *) {
            g := Ctrl.Gui
            g['TxtTest'].TextEx :=  g.options.CallbackTest.Call(g['EdtInput'].Text, g)
        }
        HClickButtonCancel(Ctrl, *) {
            g := Ctrl.Gui
            g.options.CallbackCancel.Call(g['EdtInput'].Text, g)
        }
    }
}

PropsInfoTree_ContextMenu_ExpandCallback(handle, parent, depth, pit) {
    global PropsInfoTree_ContextMenu_ExpandCallback_count
    if depth >= TVEX_MAX_RECURSION {
        return 3
    }
    if InStr(PIT_CONTEXTMENU_EXPAND_NODETYPE, ',' pit.GetNode_Ptr(handle).Type ',') {
        if ++PropsInfoTree_ContextMenu_ExpandCallback_count = PIT_CONTEXTMENU_EXPAND_MAXNODES {
            return 2
        } else if PropsInfoTree_ContextMenu_ExpandCallback_count > PIT_CONTEXTMENU_EXPAND_MAXNODES {
            return 4
        } else {
            return 0
        }
    } else {
        return 3
    }
}

class PropsInfoTree_Node extends TreeViewEx_Node {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.Handle := proto.Path := proto.InfoItem := proto.NodeEnumGroup := proto.NodeDynamicGroup :=
        proto.NodeCallGroup := proto.NodeGetGroup := proto.NodeSetGroup := proto.NodeBase :=
        proto.DynamicAccessors := proto.CallAccessors := proto.GetAccessors := proto.SetAccessors :=
        proto.PropsList := proto.KeyWidthExtent := proto.KeyWidthChar := proto.EnumList :=
        proto.NodeEnumError := proto.Value :=
        ''
        proto.__size := TreeViewEx_Size()
        proto.flag_children := proto.EnumVarCount := 0
        proto.__ItemBase := { IsError: false }
        proto.__ItemBase.DefineProp('Name', { Get: (self) => self.InfoItem.Name })
    }

    __New(Path, Value, InfoItem?) {
        this.DefineProp('Path', { Value: Path })
        this.DefineProp('Value', { Value: Value })
        if IsSet(InfoItem) {
            this.DefineProp('InfoItem', { Value: InfoItem })
        }
    }
    OnDeleteItem(Struct) {
        if this.Ctrl.IsAncestor(, this.Handle) {
            this.Ctrl.Select(0)
        }
        if this.PropsInfoTreeOptions.__CallbackDelete {
            this.PropsInfoTreeOptions.__CallbackDelete.Call(this)
        }
        ObjRelease(Struct.lParam_old)
    }
    OnGetInfoImage(Struct) {
        if Struct.mask & TVIF_IMAGE {
            if this.PropsInfoTreeOptions.__CallbackGetImage {
                return this.PropsInfoTreeOptions.__CallbackGetImage.Call(this, Struct, 'iImage')
            }
        }
    }
    OnGetInfoSelectedImage(Struct) {
        if Struct.mask & TVIF_SELECTEDIMAGE {
            if this.PropsInfoTreeOptions.__CallbackGetSelectedImage {
                return this.PropsInfoTreeOptions.__CallbackGetSelectedImage.Call(this, Struct, 'iSelectedImage')
            }
        }
    }
    OnGetInfoName(Struct) {
        Struct.pszText := this.Label
        if this.PropsInfoTreeOptions.__DI_SETITEM {
            Struct.mask := Struct.mask | TVIF_DI_SETITEM
        }
    }
    OnGetInfoTip(Struct) {
        Struct.pszText := this.Label
    }
    OnItemExpanded(Struct) {
        switch Struct.action {
            case TVE_COLLAPSE, TVE_COLLAPSERESET:
                if this.PropsInfoTreeOptions.__DeleteOnCollapse {
                    this.Ctrl.DeleteChildren(this.Handle)
                    this.flag_children := 0
                }
        }
        this.Ctrl.Redraw()
    }
    OnItemExpanding(Struct) {
        if (Struct.action = TVE_EXPAND || (Struct.action == TVE_TOGGLE && !this.IsExpanded)) && !this.flag_children {
            return this.AddChildren()
        }
        return 0
    }
    SetLabel() => this.Ctrl.SetLabel(this.Label, this.Handle)
    SetChildren(Value := 0, flag_children := 0) {
        item := TvItem()
        item.mask := TVIF_HANDLE | TVIF_CHILDREN
        item.hItem := this.Handle
        item.cChildren := Value
        if !SendMessage(TVM_SETITEMW, 0, item.Ptr, this.HwndCtrl) {
            throw OSError()
        }
        this.flag_children := flag_children
        return
    }
    __GetChildLabelKeyChar(childNode) {
        path := childNode.Path
        return Format('{:-' this.KeyWidthChar.max '}', IsNumber(path.Name) ? path.Name : PropsInfoTree_StrEscape(path.Name, this.PropsInfoTreeOptions.__PreviewItemMaxChars))
    }
    __GetChildLabelKeyExtent(childNode) {
        info := this.KeyWidthExtent
        path := childNode.Path
        str := PropsInfoTree_StrEscape(path.Name)
        context := TreeViewEx_SelectFontIntoDc(this.HwndCtrl)
        if DllCall(
            g_gdi32_GetTextExtentPoint32W
            , 'Ptr', context.hdc
            , 'Ptr', StrPtr(Str)
            , 'Int', StrLen(Str)
            , 'Ptr', this.__size
            , 'Int'
        ) {
            s := ''
            spaceList := this.PropsInfoTreeOptions.SpaceExtentList
            diff := info.max - this.__size.W
            if !IsNumber(str) {
                diff -= spaceList.Quote.W * 2
            }
            if diff < 0 {
                len := StrLen(str)
                str := DllCall(g_msvcrt__wcsrev, 'ptr', StrPtr(str), 'ptr')
                sz := TreeViewEx_Size()
                lpnFit := Buffer(4)
                if DllCall(
                    g_gdi32_GetTextExtentExPointW
                    , 'ptr', context.hdc
                    , 'ptr', str                                            ; String to measure
                    , 'int', len                                            ; String length in WORDs
                    , 'int', info.max - spaceList.Ellipses.W - (IsNumber(path.Name) ? 0 : spaceList.Quote.W * 2)    ; Maximum extent
                    , 'ptr', lpnFit                                         ; To receive number of characters that can fit
                    , 'ptr', 0                                              ; lpnDx
                    , 'ptr', sz                                             ; To receive the dimensions of the string.
                    , 'ptr'
                ) {
                    str := SubStr(StrGet(str), 1, NumGet(lpnFit, 'int'))
                    if DllCall(
                        g_gdi32_GetTextExtentPoint32W
                        , 'Ptr', context.hdc
                        , 'Ptr', StrPtr(Str)
                        , 'Int', StrLen(Str)
                        , 'Ptr', sz
                        , 'Int'
                    ) {
                        diff := info.max - sz.W - spaceList.Ellipses.W - (IsNumber(path.Name) ? 0 : spaceList.Quote.W * 2)
                        str := '...' StrGet(DllCall(g_msvcrt__wcsrev, 'ptr', StrPtr(str), 'ptr'))
                    } else {
                        context()
                        throw OSError()
                    }
                } else {
                    context()
                    throw OSError()
                }
            }
            if diff >= spaceList[1].W {
                i := 0
                for sz in spaceList {
                    ++i
                    if !Mod(diff, sz.W) {
                        ch := Chr(sz.ord)
                        loop diff / sz.W {
                            s .= ch
                        }
                        break
                    }
                }
                if !s {
                    i := 0
                    loop spaceList.Length {
                        n := spaceList[++i].W
                        for sz in spaceList {
                            if !Mod(diff - n, sz.W) {
                                ch := Chr(sz.ord)
                                s .= Chr(spaceList[i].ord)
                                loop (diff - n) / sz.W {
                                    s .= ch
                                }
                                break 2
                            }
                        }
                    }
                    if !s {
                        ch := Chr(spaceList[1].ord)
                        loop Floor(diff / spaceList[1].W) {
                            s .= ch
                        }
                    }
                }
            }
            context()
        } else {
            context()
            throw OSError()
        }
        if IsNumber(path.Name) {
            return s str
        } else {
            return s '"' str '"'
        }
    }
    HasObjectValue => IsObject(this.Value)
    ParentNode => this.Ctrl.GetNode_Ptr(this.Parent)
    PreviousNode => this.Ctrl.GetNode_Ptr(this.Previous)
    PropsInfo => ''
    RootNode => this.Ctrl.GetNode_Ptr(this.Root)
    Name => this.Path.Name
    NextNode => this.Ctrl.GetNode_Ptr(this.Next)
}

class PropsInfoTree_Node_Object extends PropsInfoTree_Node {
    AddAsRoot(InsertAfter := TVI_LAST) {
        return this.Ctrl.AddNode2(this.Ctrl.NodeConstructor_Root.Call(this.Path, this.Value), 'insert root')
    }
    AddChildren() {
        options := this.PropsInfoTreeOptions
        ctrl := this.Ctrl
        path := this.Path
        _struct := ctrl.GetTemplate('insert')
        _struct.hParent := this.Handle
        _struct.hInsertAfter := TVI_LAST
        _structStaticChildren := ctrl.GetTemplate('insert static children')
        _structStaticChildren.hParent := this.Handle
        _structStaticChildren.hInsertAfter := TVI_LAST
        if this.__HasChildren {
            if options.__BaseProp || this.DynamicAccessors || this.PropsList {
                _structStaticChildren.cChildren := 1
                if options.__BaseProp {
                    if this.Value.Base {
                        this.NodeBase := ctrl.NodeConstructor_Base.Call(path.MakeProp('Base'), this.Value.Base)
                        ctrl.AddNode2(this.NodeBase, _structStaticChildren)
                    }
                }
                if this.DynamicAccessors {
                    if options.__CombineAccessorTypes {
                        this.NodeDynamicGroup := ctrl.NodeConstructor_DynamicGroup.Call()
                        ctrl.AddNode2(this.NodeDynamicGroup, _structStaticChildren)
                    } else {
                        for c in this.DynamicAccessors {
                            this.Node%c.Name%Group := ctrl.NodeConstructor_%c.Name%Group.Call()
                            ctrl.AddNode2(this.Node%c.Name%Group, _structStaticChildren)
                        }
                    }
                }
                if this.EnumCount {
                    this.NodeEnumGroup := ctrl.NodeConstructor_EnumGroup.Call()
                    ctrl.AddNode2(this.NodeEnumGroup, _structStaticChildren)
                }
                if this.PropsList {
                    if options.__CallbackAddChildrenProps {
                        options.__CallbackAddChildrenProps.Call(this, &callbackProcess, &callbackEnd)
                    }
                    _structStaticChildren.cChildren := 0
                    if IsSet(callbackProcess) {
                        if options.__PropertyErrors {
                            for o in this.PropsList {
                                if o.IsError {
                                    node := ctrl.NodeConstructor_Error.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                    struct := _struct
                                } else {
                                    if o.Value is ComValue {
                                        node := ctrl.NodeConstructor_ComValue.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                        struct := _structStaticChildren
                                    } else if IsObject(o.Value) {
                                        node := ctrl.NodeConstructor_Object.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                        struct := _struct
                                    } else if IsNumber(o.Value) {
                                        node := ctrl.NodeConstructor_Number.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                        struct := _structStaticChildren
                                    } else {
                                        node := ctrl.NodeConstructor_String.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                        struct := _structStaticChildren
                                    }
                                }
                            }
                            callbackProcess(node, A_Index, struct)
                            ctrl.AddNode2(node, struct)
                        } else {
                            for o in this.PropsList {
                                if o.Value is ComValue {
                                    node := ctrl.NodeConstructor_ComValue.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                    struct := _structStaticChildren
                                } else if IsObject(o.Value) {
                                    node := ctrl.NodeConstructor_Object.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                    struct := _struct
                                } else if IsNumber(o.Value) {
                                    node := ctrl.NodeConstructor_Number.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                    struct := _structStaticChildren
                                } else {
                                    node := ctrl.NodeConstructor_String.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem)
                                    struct := _structStaticChildren
                                }
                            }
                            callbackProcess(node, A_Index, struct)
                            ctrl.AddNode2(node, struct)
                        }
                        callbackEnd(this, callbackProcess)
                    } else {
                        if options.__PropertyErrors {
                            for o in this.PropsList {
                                if o.IsError {
                                    ctrl.AddNode2(ctrl.NodeConstructor_Error.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _struct)
                                } else {
                                    if o.Value is ComValue {
                                        ctrl.AddNode2(ctrl.NodeConstructor_ComValue.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _structStaticChildren)
                                    } else if IsObject(o.Value) {
                                        ctrl.AddNode2(ctrl.NodeConstructor_Object.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _struct)
                                    } else if IsNumber(o.Value) {
                                        ctrl.AddNode2(ctrl.NodeConstructor_Number.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _structStaticChildren)
                                    } else {
                                        ctrl.AddNode2(ctrl.NodeConstructor_String.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _structStaticChildren)
                                    }
                                }
                            }
                        } else {
                            for o in this.PropsList {
                                if o.Value is ComValue {
                                    ctrl.AddNode2(ctrl.NodeConstructor_ComValue.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _structStaticChildren)
                                } else if IsObject(o.Value) {
                                    ctrl.AddNode2(ctrl.NodeConstructor_Object.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _struct)
                                } else if IsNumber(o.Value) {
                                    ctrl.AddNode2(ctrl.NodeConstructor_Number.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _structStaticChildren)
                                } else {
                                    ctrl.AddNode2(ctrl.NodeConstructor_String.Call(path.MakeProp(o.InfoItem.Name), o.Value, o.InfoItem), _structStaticChildren)
                                }
                            }
                        }
                    }
                }
                this.flag_children := 1
            } else if this.EnumCount {
                enumList := this.EnumList
                if options.__CallbackAddChildrenEnum {
                    options.__CallbackAddChildrenEnum.Call(this, &callbackProcess, &callbackEnd)
                    if IsSet(callbackProcess) {
                        this.__AddChildrenPreviewList := []
                        this.__AddChildrenExtentList := []
                        loop enumList.Length / 2 {
                            callbackProcess(enumlist[A_Index * 2 - 1], A_Index)
                        }
                        callbackEnd(this, callbackProcess)
                    }
                }
                _structStaticChildren.cChildren := 0
                loop enumList.Length / 2 {
                    ctrl.AddNode2(enumlist[A_Index * 2 - 1], enumList[A_Index * 2] ? _struct : _structStaticChildren)
                }
                this.DeleteProp('EnumList')
                this.flag_children := 1
            } else if this.NodeEnumError {
                ctrl.AddNode2(this.NodeEnumError, _struct)
                this.flag_children := 1
            } else {
                this.SetChildren()
                return 1
            }
        } else {
            this.SetChildren()
            return 1
        }

        return 0
    }
    DefinePropsInfo() {
        this.DefineProp('PropsInfo', { Value: this.PropsInfoTreeOptions.GetPropsInfo(this) })
        return this.PropsInfo
    }
    DeleteEnumGroupNode() {
        this.Ctrl.DeleteItem(this.NodeEnumGroup.Handle)
        this.DeleteProp('NodeEnumGroup')
        if !this.HasChildren {
            this.SetChildren()
        }
    }
    EvaluateEnum() {
        value := this.Value
        options := this.PropsInfoTreeOptions
        ctrl := this.Ctrl
        path := this.Path
        if HasMethod(value, '__Enum')
        && (!options.__CallbackCallEnum || (n := options.__CallbackCallEnum.Call(this)))
        && !ObjHasOwnProp(value, '__Class') {
            if options.__CallbackEnumProcess {
                if options.__CallbackEnumProcess.Call(this, &callbackProcess, &callbackEnd) {
                    this.DefineProp('EnumCount', { Value: 0 })
                    return 0
                }
            }
            if IsSet(callbackProcess) {
                make := _MakeCallback
            } else {
                make := _Make
            }
            enumList := []
            enumList.Capacity := HasProp(value, 'Capacity') ? value.Capacity : 1024
            if options.__NormalizeKeyExtent {
                _sum := greatest := 0
                least := 2 ** 32 - 1
                switch options.__NormalizeKeyExtent, 0 {
                    case 1: measure := _Measure1
                    case 2:
                        sz := this.__size
                        measure := _Measure2
                        context := TreeViewEx_SelectFontIntoDc(this.HwndCtrl)
                        hdc := context.hdc
                    case 3:
                        extent := Map()
                        measure := _Measure3
                        context := TreeViewEx_SelectFontIntoDc(this.HwndCtrl)
                        hdc := context.hdc
                }
                if IsSet(n) {
                    switch n, 0 {
                        case 0: ; do nothing
                        case 1:
                            try {
                                for value in this.Value {
                                    if make(&value) {
                                        measure()
                                    }
                                }
                                this.DefineProp('EnumVarCount', { Value: 1 })
                            } catch Error as err {
                                enumList.Length := 0
                            }
                        case 2:
                            try {
                                for key, value in this.Value {
                                    if make(&value, &key) {
                                        measure(&key)
                                    }
                                }
                                this.DefineProp('EnumVarCount', { Value: 2 })
                            } catch Error as err {
                                enumList.Length := 0
                            }
                    }
                } else {
                    try {
                        for key, value in this.Value {
                            if make(&value, &key) {
                                measure(&key)
                            }
                        }
                        this.DefineProp('EnumVarCount', { Value: 1 })
                    } catch {
                        enumList.Length := 0
                        try {
                            for value in this.Value {
                                if make(&value) {
                                    measure()
                                }
                            }
                            this.DefineProp('EnumVarCount', { Value: 2 })
                        } catch Error as err {
                            enumList.Length := 0
                        }
                    }
                }
            } else if IsSet(n) {
                switch n, 0 {
                    case 0: ; do nothing
                    case 1:
                        try {
                            for value in this.Value {
                                make(&value)
                            }
                            this.DefineProp('EnumVarCount', { Value: 1 })
                        } catch Error as err {
                            enumList.Length := 0
                        }
                    case 2:
                        try {
                            for key, value in this.Value {
                                make(&value, &key)
                            }
                            this.DefineProp('EnumVarCount', { Value: 2 })
                        } catch Error as err {
                            enumList.Length := 0
                        }
                }
            } else {
                try {
                    for key, value in this.Value {
                        make(&value, &key)
                    }
                    this.DefineProp('EnumVarCount', { Value: 2 })
                } catch {
                    enumList.Length := 0
                    try {
                        for value in this.Value {
                            make(&value)
                        }
                        this.DefineProp('EnumVarCount', { Value: 1 })
                    } catch Error as err {
                        enumList.Length := 0
                    }
                }
            }
            this.DefineProp('EnumCount', { Value: Integer(enumList.Length / 2) })
            if enumList.Length {
                switch options.__NormalizeKeyExtent, 0 {
                    case 1:
                        this.DefineProp('KeyWidthChar', {
                            Value: {
                                count: this.EnumCount
                              , max: Min(options.__MaxKeyWidthChar, greatest)
                              , min: least
                              , sum: _sum
                            }
                        })
                        this.DefineProp('GetChildLabelKey', PropsInfoTree_Node.Prototype.GetOwnPropDesc('__GetChildLabelKeyChar'))
                    case 2, 3:
                        this.DefineProp('KeyWidthExtent', {
                            Value: {
                                count: this.EnumCount
                              , extent: extent ?? ''
                              , max: Min(options.__MaxKeyWidthExtent, greatest + options.SpaceExtentList.Quote.W * 2)
                              , min: least
                              , sum: _sum
                            }
                        })
                        this.DefineProp('GetChildLabelKey', PropsInfoTree_Node.Prototype.GetOwnPropDesc('__GetChildLabelKeyExtent'))
                }
                this.EnumList := enumList
            } else if IsSet(err) && options.__EnumErrors {
                this.NodeEnumError := ctrl.NodeConstructor_EnumError.Call(path.MakeProp('__Enum'), err)
            }
            if IsSet(context) {
                context()
            }
            if IsSet(callbackEnd) {
                callbackEnd(this)
            }
        } else {
            this.DefineProp('EnumCount', { Value: 0 })
        }

        return this.EnumCount

        _Make(&value, &key := A_Index) {
            if IsSet(value) {
                if value is ComValue {
                    enumList.Push(ctrl.NodeConstructor_ComValue.Call(path.MakeItem(key), value), 0)
                } else if IsObject(value) {
                    enumList.Push(ctrl.NodeConstructor_Object.Call(path.MakeItem(key), value), 1)
                } else if IsNumber(value) {
                    enumList.Push(ctrl.NodeConstructor_Number.Call(path.MakeItem(key), value), 0)
                } else {
                    enumList.Push(ctrl.NodeConstructor_String.Call(path.MakeItem(key), value), 0)
                }
            } else {
                enumList.Push(ctrl.NodeConstructor_UnsetArrayItem.Call(path.MakeItem(key)), 0)
            }
            return 1
        }
        _MakeCallback(&value, &key := A_Index) {
            if IsSet(value) {
                if value is ComValue {
                    enumList.Push(ctrl.NodeConstructor_ComValue.Call(path.MakeItem(key), value), 0)
                } else if IsObject(value) {
                    enumList.Push(ctrl.NodeConstructor_Object.Call(path.MakeItem(key), value), 1)
                } else if IsNumber(value) {
                    enumList.Push(ctrl.NodeConstructor_Number.Call(path.MakeItem(key), value), 0)
                } else {
                    enumList.Push(ctrl.NodeConstructor_String.Call(path.MakeItem(key), value), 0)
                }
            } else {
                enumList.Push(ctrl.NodeConstructor_UnsetArrayItem.Call(path.MakeItem(key)), 0)
            }
            if callbackProcess(&key, &value, enumList[-2], this) {
                enumList.RemoveAt(-2, 2)
                return 0
            }
            return 1
        }
        _Measure1(&key := A_Index) {
            greatest := Max(StrLen(key), greatest)
            least := Min(StrLen(key), least)
            _sum += StrLen(key)
        }
        _Measure2(&key := A_Index) {
            str := String(key)
            if DllCall(
                g_gdi32_GetTextExtentPoint32W
                , 'Ptr', hdc
                , 'Ptr', StrPtr(str)
                , 'Int', StrLen(str)
                , 'Ptr', sz
                , 'Int'
            ) {
                greatest := Max(sz.W, greatest)
                least := Min(sz.W, least)
                _sum += sz.W
            } else {
                throw OSError()
            }
        }
        _Measure3(&key := A_Index) {
            str := String(key)
            sz := TreeViewEx_Size()
            if DllCall(
                g_gdi32_GetTextExtentPoint32W
                , 'Ptr', hdc
                , 'Ptr', StrPtr(str)
                , 'Int', StrLen(str)
                , 'Ptr', sz
                , 'Int'
            ) {
                greatest := Max(sz.W, greatest)
                least := Min(sz.W, least)
                _sum += sz.W
                extent.Set(key, sz)
            } else {
                throw OSError()
            }
        }
    }
    EvaluateObject() {
        options := this.PropsInfoTreeOptions
        value := this.Value
        ctrl := this.Ctrl
        flag_hasChildren := this.EvaluateEnum()
        if propsInfoObj := this.PropsInfo {
            if !flag_hasChildren {
                flag_hasChildren := options.__BaseProp
            }
            if propsInfoObj.Count {
                b := this.__ItemBase
                make := options.__PropertyErrors ? _MakeError : _Make
                propsList := Container.CbString(PropsInfoTree_CallbackValue_Name, , LINGUISTIC_IGNORECASE)
                propValues := options.__PropValues
                if options.__CallbackProcessProps {
                    flag_skip := options.__CallbackProcessProps.Call(this, &callbackProcess, &callbackEnd)
                } else {
                    flag_skip := false
                }
                if !flag_skip {
                    if options.Accessors {
                        call := get := set := 0
                        accessors := Container.CbString(PropsInfoTree_CallbackValue_Name, , LINGUISTIC_IGNORECASE)
                        for name in [ 'Call', 'Get', 'Set' ] {
                            if options.__%name%Accessors {
                                accessors.Push(%name% := Container.CbString(PropsInfoTree_CallbackValue_Name, , LINGUISTIC_IGNORECASE))
                                accessors[-1].Name := name
                            }
                        }
                        if IsSet(callbackProcess) {
                            for infoItem in propsInfoObj {
                                if callbackProcess(infoItem, this) {
                                    continue
                                }
                                switch infoItem.KindIndex {
                                    case 1:
                                        if call {
                                            call.Insert(infoItem)
                                        }
                                    case 2:
                                        if get {
                                            get.Insert(infoItem)
                                        }
                                        if propValues {
                                            make(infoItem)
                                        }
                                    case 3:
                                        if get {
                                            get.Insert(infoItem)
                                        }
                                        if set {
                                            set.Insert(infoItem)
                                        }
                                        if propValues {
                                            make(infoItem)
                                        }
                                    case 4:
                                        if set {
                                            set.Insert(infoItem)
                                        }
                                    case 5:
                                        if propValues {
                                            make(infoItem)
                                        }
                                }
                            }
                        } else {
                            for infoItem in propsInfoObj {
                                switch infoItem.KindIndex {
                                    case 1:
                                        if call {
                                            call.Insert(infoItem)
                                        }
                                    case 2:
                                        if get {
                                            get.Insert(infoItem)
                                        }
                                        if propValues {
                                            make(infoItem)
                                        }
                                    case 3:
                                        if get {
                                            get.Insert(infoItem)
                                        }
                                        if set {
                                            set.Insert(infoItem)
                                        }
                                        if propValues {
                                            make(infoItem)
                                        }
                                    case 4:
                                        if set {
                                            set.Insert(infoItem)
                                        }
                                    case 5:
                                        if propValues {
                                            make(infoItem)
                                        }
                                }
                            }
                        }
                        i := 0
                        flag_accessors := true
                        loop accessors.Length {
                            if accessors[++i].Length {
                                if flag_accessors {
                                    this.DynamicAccessors := accessors
                                    flag_accessors := false
                                    flag_hasChildren := true
                                }
                            } else {
                                accessors.RemoveAt(i--)
                            }
                        }
                    } else if propValues {
                        if IsSet(callbackProcess) {
                            for infoItem in propsInfoObj {
                                if callbackProcess(infoItem, this) {
                                    continue
                                }
                                switch infoItem.KindIndex {
                                    case 2, 3, 5: make(infoItem)
                                }
                            }
                        } else {
                            for infoItem in propsInfoObj {
                                switch infoItem.KindIndex {
                                    case 2, 3, 5: make(infoItem)
                                }
                            }
                        }
                    }
                    if propsList.Length {
                        this.PropsList := propsList
                        flag_hasChildren := true
                    }
                }
            }
        }
        this.DefineProp('__HasChildren', { Value: flag_hasChildren })
        if IsSet(callbackEnd) {
            callbackEnd(this)
        }
        return flag_hasChildren

        _Make(infoItem) {
            if !infoItem.GetValue(&v) {
                o := { InfoItem: infoItem, Value: v }
                o.Base := b
                propsList.Insert(o)
            }
        }
        _MakeError(infoItem) {
            if infoItem.GetValue(&v) {
                o := { InfoItem: infoItem, IsError: true, Value: v }
            } else {
                o := { InfoItem: infoItem, Value: v }
            }
            o.Base := b
            propsList.Insert(o)
        }
    }
    GetChildLabelKey(childNode) {
        return IsNumber(childNode.Path.Name) ? childNode.Path.Name : PropsInfoTree_StrEscape(childNode.Path.Name, this.PropsInfoTreeOptions.__PreviewItemMaxChars)
    }
    GetLabel() {
        if this.InfoItem {
            return this.InfoItem.Name (this.PropsInfoTreeOptions.__ShowOwnerIndex ? '(' this.InfoItem.Index ')' : '') ': ' this.GetPreview()
        } else if (path := this.Path).Type = PATHOBJ_TYPE_PROP {
            return path.Name ': ' this.GetPreview()
        } else if path.Type = PATHOBJ_TYPE_ITEM {
            return '[ ' this.ParentNode.GetChildLabelKey(this) ' ] = ' this.GetPreview()
        } else if path.Type = PATHOBJ_TYPE_ROOT {
            return this.GetPreview()
        }
    }
    GetPreview(CallbackGetType := PropsInfoTree_GetDisplayType) {
        if this.HasOwnProp('__Preview') {
            return this.__Preview
        }
        value := this.Value
        if this.__HasChildren {
            options := this.PropsInfoTreeOptions
            if options.__CallbackPreview {
                if callback := options.__CallbackPreview.Call(this) {
                    return callback(this)
                }
            }
            previewMaxChars := options.__PreviewMaxChars
            itemMaxChars := options.__PreviewItemMaxChars
            params := CallbackGetType.MaxParams = 1 ? [ value ] : [ value, this ]
            s := ''
            VarSetStrCapacity(&s, previewMaxChars)
            s .= '<' CallbackGetType(params*) '>'
            if StrLen(s) < previewMaxChars {
                if this.PropsList {
                    s2 := ''
                    VarSetStrCapacity(&s2, previewMaxChars - StrLen(s))
                    s2 .= ' {'
                    separator := _AddSeparator1
                    i := 0
                    if options.__CallbackPreviewProps && (previewProps := options.__CallbackPreviewProps.Call(this)) {
                        previewProps := ',' previewProps ','
                        for o in this.PropsList {
                            if InStr(previewProps, ',' o.InfoItem.Name ',') && !o.IsError {
                                _s := separator() o.InfoItem.Name ': '
                                if IsObject(o.Value) {
                                    _s .= '{ ' CallbackGetType(o.Value) ' }'
                                } else if IsNumber(o.Value) {
                                    _s .= o.Value
                                } else {
                                    _s .= '"' PropsInfoTree_StrEscape(o.Value, itemMaxChars) '"'
                                }
                                if StrLen(s) + StrLen(s2) + StrLen(_s) > previewMaxChars {
                                    break
                                }
                                s2 .= _s
                                ++i
                            }
                        }
                    } else {
                        for o in this.PropsList {
                            if !o.IsError {
                                _s := separator() o.InfoItem.Name ': '
                                if IsObject(o.Value) {
                                    _s .= '{ ' CallbackGetType(o.Value) ' }'
                                } else if IsNumber(o.Value) {
                                    _s .= o.Value
                                } else {
                                    _s .= '"' PropsInfoTree_StrEscape(o.Value, itemMaxChars) '"'
                                }
                                if StrLen(s) + StrLen(s2) + StrLen(_s) > previewMaxChars {
                                    break
                                }
                                s2 .= _s
                                ++i
                            }
                        }
                    }
                    if i = this.PropsList.Length {
                        s .= s2 ' }'
                    } else {
                        s .= s2 ', ... }'
                    }
                }
            }
            if this.EnumCount {
                s .= ' (' this.EnumCount ') ['
                StrLen(s) < previewMaxChars
                separator := _AddSeparator1
                if this.EnumVarCount = 1 {
                    for v in value {
                        if IsSet(v) {
                            if IsObject(v) {
                                _s := separator() '{ ' CallbackGetType(v) ' }'
                            } else if IsNumber(v) {
                                _s := separator() v
                            } else {
                                _s := separator() '"' PropsInfoTree_StrEscape(v, itemMaxChars) '"'
                            }
                        } else {
                            _s := separator() 'unset'
                        }
                        if StrLen(s) + StrLen(_s) > previewMaxChars {
                            break
                        }
                        s .= _s
                    }
                    s .= ' ]'
                } else if this.EnumVarCount = 2 {
                    i := 0
                    for k, v in value {
                        if IsObject(k) {
                            k := '{ ' CallbackGetType(k) ' }'
                        } else if !IsNumber(k) {
                            k := '"' PropsInfoTree_StrEscape(k, itemMaxChars) '"'
                        }
                        if IsObject(v) {
                            v := '{ ' CallbackGetType(v) ' }'
                        } else if !IsNumber(v) {
                            v := '"' PropsInfoTree_StrEscape(v, itemMaxChars) '"'
                        }
                        _s := separator() '[ ' k ', ' v ' ]'
                        if StrLen(s) + StrLen(_s) + 2 > previewMaxChars {
                            break
                        }
                        s .= _s
                        ++i
                    }
                    if i = this.EnumCount {
                        s .= ' ]'
                    } else {
                        s .= ', ... ]'
                    }
                } else {
                    throw ValueError('Unexpected value of property "EnumVarCount".', , this.EnumVarCount)
                }
            }
            return s || '<' CallbackGetType(params*) '>'
        } else {
            params := CallbackGetType.MaxParams = 1 ? [ value ] : [ value, this ]
            return '<' CallbackGetType(params*) '>'
        }

        _AddSeparator1() {
            separator := _AddSeparator2
            return ' '
        }
        _AddSeparator2() {
            return ', '
        }
    }
    OnGetInfoChildren(Struct) {
        Struct.mask := Struct.mask | TVIF_DI_SETITEM
        Struct.cChildren := this.__HasChildren
        return 0
    }
    EnumCount => this.EvaluateEnum()
    Label => this.GetLabel()
    PropsCount => this.PropsList ? this.PropsList.Length : 0
    PropsInfo => this.DefinePropsInfo()
    Type => PROPSINFOTREE_NODETYPE_OBJECT
    Value => this.PropsInfo.Root
    __HasChildren => this.EvaluateObject()
}
class PropsInfoTree_Node_Root extends PropsInfoTree_Node_Object {
    __New(Path, Value) {
        this.DefineProp('Path', { Value: Path.ToRoot() })
        this.DefineProp('Value', { Value: Value })
    }
    Type => PROPSINFOTREE_NODETYPE_ROOT
}
class PropsInfoTree_Node_Base extends PropsInfoTree_Node_Object {
    __New(Path, Value) {
        this.DefineProp('Path', { Value: Path })
        this.DefineProp('Value', { Value: Value })
    }
    Label => 'Base: ' this.GetPreview()
    Type => PROPSINFOTREE_NODETYPE_BASE
}
class PropsInfoTree_Node_Error extends PropsInfoTree_Node_Object {
    Type => PROPSINFOTREE_NODETYPE_ERROR
}
class PropsInfoTree_Node_EnumError extends PropsInfoTree_Node_Error {
    Type => PROPSINFOTREE_NODETYPE_ENUMERROR
}

class PropsInfoTree_Node_Dynamic extends PropsInfoTree_Node_Object {
    Label => this.Path.Name ': ' this.GetPreview(PropsInfoTree_GetType_Accessors)
    Type => PROPSINFOTREE_NODETYPE_DYNAMIC
}
class PropsInfoTree_Node_Call extends PropsInfoTree_Node_Dynamic {
    Accessor => 'Call'
    Type => PROPSINFOTREE_NODETYPE_CALL
}
class PropsInfoTree_Node_Get extends PropsInfoTree_Node_Dynamic {
    Accessor => 'Get'
    Type => PROPSINFOTREE_NODETYPE_GET
}
class PropsInfoTree_Node_Set extends PropsInfoTree_Node_Dynamic {
    Accessor => 'Set'
    Type => PROPSINFOTREE_NODETYPE_SET
}

class PropsInfoTree_Node_EnumGroup extends PropsInfoTree_Node {
    __New() {
    }
    AddChildren() {
        options := this.PropsInfoTreeOptions
        enumList := this.ParentNode.EnumList
        if options.__CallbackAddChildrenEnum {
            options.__CallbackAddChildrenEnum.Call(this, &callbackProcess, &callbackEnd)
            if IsSet(callbackProcess) {
                this.__AddChildrenPreviewList := []
                this.__AddChildrenExtentList := []
                loop enumList.Length / 2 {
                    callbackProcess(enumlist[A_Index * 2 - 1], A_Index)
                }
                callbackEnd(this, callbackProcess)
            }
        }
        ctrl := this.Ctrl
        _struct := ctrl.GetTemplate('insert')
        _structStaticChildren := ctrl.GetTemplate('insert static children')
        _struct.hParent := _structStaticChildren.hParent := this.Handle
        _struct.hInsertAfter := _structStaticChildren.hInsertAfter := TVI_LAST
        _structStaticChildren.cChildren := 0
        loop enumList.Length / 2 {
            ctrl.AddNode2(enumlist[A_Index * 2 - 1], enumList[A_Index * 2] ? _struct : _structStaticChildren)
        }
        this.ParentNode.DeleteProp('EnumList')
        this.flag_children := 1
        return 0
    }
    GetChildLabelKey(childNode) {
        return this.ParentNode.GetChildLabelKey(childNode)
    }
    Label => 'Enum (' this.ParentNode.EnumCount ')'
    Type => PROPSINFOTREE_NODETYPE_ENUMGROUP
}
class PropsInfoTree_Node_DynamicGroup extends PropsInfoTree_Node {
    __New() {
    }
    AddChildren() {
        ctrl := this.Ctrl
        parentNode := this.ParentNode
        path := parentNode.Path
        _structStaticChildren := ctrl.GetTemplate('insert static children')
        _structStaticChildren.cChildren := 1
        _structStaticChildren.hParent := this.Handle
        _structStaticChildren.hInsertAfter := TVI_LAST
        for name, list in parentNode.DynamicAccessors {
            constructor := ctrl.NodeConstructor_%name%
            for infoItem in list {
                ctrl.AddNode2(constructor(path.MakeProp(infoItem.Name), infoItem.%name%, infoItem), _structStaticChildren)
            }
        }
        this.flag_children := 1
        return 0
    }
    OnItemExpanding(Struct) {
        if (Struct.action = TVE_EXPAND || (Struct.action == TVE_TOGGLE && !this.IsExpanded)) && !this.flag_children {
            return this.AddChildren()
        }
        return 0
    }
    __AddChildren(Name) {
        ctrl := this.Ctrl
        parentNode := this.ParentNode
        path := parentNode.Path
        _structStaticChildren := ctrl.GetTemplate('insert static children')
        _structStaticChildren.cChildren := 1
        _structStaticChildren.hParent := this.Handle
        _structStaticChildren.hInsertAfter := TVI_LAST
        constructor := ctrl.NodeConstructor_%Name%
        for infoItem in parentNode.DynamicAccessors.GetValue(Name) {
            ctrl.AddNode2(constructor(path.MakeProp(infoItem.Name), infoItem.%Name%, infoItem), _structStaticChildren)
        }
        this.flag_children := 1
        return 0
    }
    Label => 'Dynamic accessors'
    Type => PROPSINFOTREE_NODETYPE_DYNAMICGROUP
}
class PropsInfoTree_Node_CallGroup extends PropsInfoTree_Node_DynamicGroup {
    AddChildren() => this.__AddChildren('Call')
    Label => 'Call accessors'
    Type => PROPSINFOTREE_NODETYPE_CALLGROUP
}
class PropsInfoTree_Node_GetGroup extends PropsInfoTree_Node_DynamicGroup {
    AddChildren() => this.__AddChildren('Get')
    Label => 'Get accessors'
    Type => PROPSINFOTREE_NODETYPE_GETGROUP
}
class PropsInfoTree_Node_SetGroup extends PropsInfoTree_Node_DynamicGroup {
    AddChildren() => this.__AddChildren('Set')
    Label => 'Set accessors'
    Type => PROPSINFOTREE_NODETYPE_SETGROUP
}

class PropsInfoTree_Node_Value extends PropsInfoTree_Node {
    Type => PROPSINFOTREE_NODETYPE_VALUE
}
class PropsInfoTree_Node_Number extends PropsInfoTree_Node_Value {
    Label {
        Get {
            if this.InfoItem {
                return this.InfoItem.Name (this.PropsInfoTreeOptions.__ShowOwnerIndex ? '(' this.InfoItem.Index ')' : '') ': ' this.Value
            } else if (path := this.Path).Type = PATHOBJ_TYPE_PROP {
                return path.Name ': ' this.Value
            } else if path.Type = PATHOBJ_TYPE_ITEM {
                if IsNumber(path.Name) {
                    return '[ ' path.Name ' ] = ' this.Value
                } else {
                    return '[ "' PropsInfoTree_StrEscape(path.Name, this.PropsInfoTreeOptions.__LabelMaxChars) '" ] = ' this.Value
                }
            }
        }
    }
    Type => PROPSINFOTREE_NODETYPE_NUMBER
}
class PropsInfoTree_Node_String extends PropsInfoTree_Node_Value {
    Label {
        Get {
            if this.InfoItem {
                return this.InfoItem.Name (this.PropsInfoTreeOptions.__ShowOwnerIndex ? '(' this.InfoItem.Index ')' : '') ': "' PropsInfoTree_StrEscape(this.Value, this.PropsInfoTreeOptions.__LabelMaxChars) '"'
            } else if (path := this.Path).Type = PATHOBJ_TYPE_PROP {
                return path.Name ': "' PropsInfoTree_StrEscape(this.Value, this.PropsInfoTreeOptions.__LabelMaxChars) '"'
            } else if path.Type = PATHOBJ_TYPE_ITEM {
                if IsNumber(path.Name) {
                    return '[ ' path.Name ' ] = "' PropsInfoTree_StrEscape(this.Value, this.PropsInfoTreeOptions.__LabelMaxChars) '"'
                } else {
                    return '[ "' PropsInfoTree_StrEscape(path.Name, this.PropsInfoTreeOptions.__LabelMaxChars) '" ] = "' PropsInfoTree_StrEscape(this.Value, this.PropsInfoTreeOptions.__LabelMaxChars) '"'
                }
            }
        }
    }
    Type => PROPSINFOTREE_NODETYPE_STRING
}
class PropsInfoTree_Node_ComValue extends PropsInfoTree_Node_Value {
    Label {
        Get {
            if this.InfoItem {
                return this.InfoItem.Name (this.PropsInfoTreeOptions.__ShowOwnerIndex ? '(' this.InfoItem.Index ')' : '') ': { ' PropsInfoTree_GetDisplayType(this.Value) ' }'
            } else if (path := this.Path).Type = PATHOBJ_TYPE_PROP {
                return path.Name ': { ' PropsInfoTree_GetDisplayType(this.Value) ' }'
            } else if path.Type = PATHOBJ_TYPE_ITEM {
                if IsNumber(path.Name) {
                    return '[ ' path.Name ' ] = { ' PropsInfoTree_GetDisplayType(this.Value) ' }'
                } else {
                    return '[ "' PropsInfoTree_StrEscape(path.Name, this.PropsInfoTreeOptions.__LabelMaxChars) '" ] = { ' PropsInfoTree_GetDisplayType(this.Value) ' }'
                }
            }
        }
    }
    Type => PROPSINFOTREE_NODETYPE_COMVALUE
}
class PropsInfoTree_Node_UnsetArrayItem extends PropsInfoTree_Node_Value {
    __New(Path) {
        this.DefineProp('Path', { Value: Path })
    }
    Label => '[ ' this.Path.Name ' ] = unset'
    Type => PROPSINFOTREE_NODETYPE_UNSETARRAYITEM
}

class PropsInfoTree_PreviewFormat extends Container {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.ToCbString(PropsInfoTree_CallbackValue_Type, , LINGUISTIC_IGNORECASE)
        proto.CallbackType := [ PropsInfoTree_GetDisplayType, Type ]
        proto.Default := ''
    }
    /**
     * {@link PropsInfoTree_PreviewFormat} can be used with {@link PropsInfoTree.Options#CallbackPreview}.
     *
     * ### Usage
     *
     * Your code provides one or more items that associates format string with a type string, then
     * your code assigns the {@link PropsInfoTree_PreviewFormat} object to
     * {@link PropsInfoTree.Options#CallbackPreview}. When the text label for a tree-view item
     * associated with an object value is generated using
     * {@link PropsInfoTree_Node_Object.Prototype.GetPreview}, the function retrieves the item
     * from this collection and follows the instructions provided by the item.
     *
     * Before getting started, you should briefly review the
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-FormatStr/tree/main FormatStr readme} to
     * acquaint yourself with the system.
     *
     * The following are format specifiers available to all items:
     * - !type1 : Directs {@link PropsInfoTree_Node_Object.Prototype.GetPreview} to include the
     *   type string in the preview text as the return value from `Type`.
     * - !type2 : Directs {@link PropsInfoTree_Node_Object.Prototype.GetPreview} to include the
     *   type string in the preview text as the return value from {@link PropsInfoTree_GetDisplayType}.
     * - !enum : Directs {@link PropsInfoTree_Node_Object.Prototype.GetPreview} to include the
     *   values retuned by the enumerator.
     *   - If the object inherits from `Array`, calls the enumerator in 1-parameter mode.
     *   - If the object inherits from `Map`, `RegExMatchInfo`, or `Gui`, calls the enumerator in
     *     2-parameter mode.
     *   - If the object does not inherit from any of the above and if the object has a method
     *     "__Enum", first attempts to call the enumerator in 2-parameter mode. If an error
     *     occurs, attempts 1-parameter mode. If an error occurs again, returns an empty string
     *     for the !enum format specifier.
     *   - If the object does not have a method "__Enum", returns an empty string for the !enum
     *     format specifier.
     *   - Object values are passed to `CallbackGetType`. String values are passed to `CallbackString`.
     * - !enum1 : Directs {@link PropsInfoTree_Node_Object.Prototype.GetPreview} to include the
     *   values returned by the enumerator in 1-parameter mode. Values are listed separated by a
     *   comma and space. Object values are passed to `CallbackGetType`. String values are passed
     *   to `CallbackString`.
     * - !enum2 : Directs {@link PropsInfoTree_Node_Object.Prototype.GetPreview} to include the
     *   values returned by the enumerator in 1-parameter mode. Values pairs are listed between
     *   a pair of square brackets overall, and each pair is listed between another, nested pair
     *   of square brackets, each separated by a comma and space. Object values are passed to
     *   `CallbackGetType`. String values are passed to `CallbackString`.
     * - !props : Directs {@link PropsInfoTree_Node_Object.Prototype.GetPreview} to include
     *   property : value pairs in alphabetical order until the maximum extent is reached or until
     *   all properties have been processed. Object values are passed to `CallbackGetType`. String
     *   values are passed to `CallbackString`.
     *
     * @param {Object|PropsInfoTree_PreviewFormat.Item|Object[]|PropsInfoTree_PreviewFormat.Item[]} [Items] -
     * One of the following:
     * - An object with properties as described below.
     * - A {@link PropsInfoTree_PreviewFormat.Item} object.
     * - An array of objects with properties as described below.
     * - An array of {@link PropsInfoTree_PreviewFormat.Item} objects.
     *
     * Objects can have the following properties:
     * - {String|String[]} Type (required) - The object type to associate with the item, or an array
     *   of object types to associate with the item.
     * - Any of the options described above {@link PropsInfoTree_PreviewFormat.Item.Prototype.__New}.
     *   The name of the property should match with the name of the option.
     *
     * @param {Object|PropsInfoTree_PreviewFormat.Item|Boolean} [DefaultItem = false] - Defines the
     * default object that is returned when {@link PropsInfoTree_PreviewFormat.Prototype.Call} is
     * called with a type string that is not found in the collection.
     *
     * If `DefaultItem` is a nonzero primitive value, e.g. `true` or `1`,
     * {@link PropsInfoTree_PreviewFormat#Default} is set with a {@link PropsInfoTree_PreviewFormat.Item}
     * object created by calling {@link PropsInfoTree_PreviewFormat.Item.Prototype.__New} with no
     * parameters.
     *
     * If `DefaultItem` is an object, it can have any of the options described above
     * {@link PropsInfoTree_PreviewFormat.Item.Prototype.__New}. The name of the property should
     * match with the name of the option. The option `Options.Type` is ignored.
     *
     * @param {*|*[]} [CallbackType] - A `Func` or callable object that returns the type string
     * used to select an item from the container.
     * - Parmeter:
     *   1. {*} The object being evaluated.
     * - Returns: {String} The string used to select an item from the container.
     *
     * `CallbackType` can also be an array of callable objects. When an array, the objects are called
     * in order until one returns a value that is found in the container, or until each has been called.
     *
     * If unset, the default value is an array with two functions: {@link PropsInfoTree_GetDisplayType}
     * and `Type`.
     *
     * @param {Map} [SpecifierCodes] - If set, `SpecifierCodes` is set to the property "SpecifierCodes"
     * for every object in `Items`. Use this parameter to define a set of specifier codes that are
     * made available to all of the format strings, instead of assigning the option to each individual
     * item.
     */
    __New(Items?, DefaultItem := false, CallbackType?, SpecifierCodes?) {
        constructor := PropsInfoTree_PreviewFormat.Item
        cls := constructor.Prototype.__Class
        if IsSet(Items) {
            if not Items is Array {
                Items := [ Items ]
            }
            if IsSet(SpecifierCodes) {
                for item in Items {
                    if item.__Class = cls {
                        this.Insert(item)
                    } else if item.Type is Array {
                        item.SpecifierCodes := SpecifierCodes
                        _type := item.Type
                        for t in _type {
                            item.Type := t
                            this.Insert(constructor(item))
                        }
                    } else {
                        item.SpecifierCodes := SpecifierCodes
                        this.Insert(constructor(item))
                    }
                }
            } else {
                for item in Items {
                    if item.__Class = cls {
                        this.Insert(item)
                    } else if item.Type is Array {
                        _type := item.Type
                        for t in _type {
                            item.Type := t
                            this.Insert(constructor(item))
                        }
                    } else {
                        this.Insert(constructor(item))
                    }
                }
            }
        }
        if DefaultItem {
            if IsObject(DefaultItem) {
                if DefaultItem.__Class = cls {
                    this.Default := DefaultItem
                } else {
                    DefaultItem.SpecifierCodes := SpecifierCodes
                    this.Default := constructor(DefaultItem)
                }
            } else {
                this.Default := constructor()
            }
        }
        if IsSet(CallbackType) {
            this.DefineProp('CallbackType', { Value: CallbackType })
        }
        if this.CallbackType is Array {
            this.DefineProp('Call', PropsInfoTree_PreviewFormat.Prototype.GetOwnPropDesc('__Call_Array'))
        }
    }
    Call(node) {
        if this.Find(this.CallbackType.Call(node.Value), &item) {
            return item
        }
        return this.Default
    }
    __Call_Array(node) {
        for callback in this.CallbackType {
            if this.Find(callback(node.Value), &item) {
                return item
            }
        }
        return this.Default
    }

    class Item {
        static __New() {
            this.DeleteProp('__New')
            proto := this.Prototype
            proto.DefaultList := [ '!type1', '!type2', '!enum1', '!enum2', '!enum', '!props' ]
            proto.CallbackGetType := Type
            proto.CallbackString := PropsInfoTree_PreviewFormat_CallbackString_Quoted
            proto.MaxExtentEnumItem := proto.MaxExtentPropValue := 150
            proto.MaxExtentEnum := proto.MaxExtentProps := 400
            proto.NumericStringAsNumber := proto.QuotedStrings := true
            proto.IncludeErrors := false
            proto.PropertyList := proto.FormatFunction := proto.FormatStrConstructor := proto.Type :=
            proto.SeparatorExtent := ''
            proto.Separator := ', '
            proto.DefaultFormat := '{<%!type1%> }{[ %!enum% ] }{\{ %!props% \}}'
        }
        /**
         * @param {Object} [Options] - An object with options as property : value pairs.
         * `Options.Type` is generally required, unless creating an item to be used as the default
         * item.
         *
         * @param {Boolean} [Options.AlignSegments = true] - This option is intended to be used with
         * `PropsInfoTreeOptions.CallbackAddChildrenEnum` and `PropsInfoTreeOptions.CallbackAddChildrenProps`.
         * When true, when a node is expanded in the tree-view, extra whitespace characters
         * are added to pad the width of the segments of the preview string so the segments are
         * aligned when viewed by the user.
         * @example
         * exampleObj := {
         *     Values := [
         *         { name: "Blake", date: "2025/11/19", quantity: 67, profit: 1900.05 }
         *       , { name: "Elizabeth", date: "2025/11/19", quantity: 85, profit: 2410.51 }
         *       , { name: "Anjelica", date: "2025/11/19", quantity: 105, profit: 2977.69 }
         *     ]
         * }
         * previewFormat := PropsInfoTree_PreviewFormat(
         *     [
         *         {
         *             Type: 'Object'
         *           , Format: '%name%: |src: %src%, dst: %dst%, disp: %disposition%, billsec: %billsec%'
         *           , PropertyList: [ 'startTime', 'src', 'dst', 'disposition', 'billsec' ]
         *           , QuotedStrings: false
         *         }
         *     ]
         *   ,
         *   ,
         * ;   , Map('split', PropsInfoTree_PreviewFormat_SpecifierCode_Split)
         * )
         * @
         *
         * @param {*} [Options.CallbackGetType = 1] - One of the following:
         * - 1 : Object values encountered when generating the preview text are passed to
         *   `Type`, and the return value is enclosed in curly braces.
         * - 2 : Object values encountered when generating the preview text are passed to
         *   {@link PropsInfoTree_GetDisplayType}, and the return value is enclosed in curly braces.
         * - A `Func` or callable object : Object values encountered when generating the preview text
         *   are passed to `CallbackType`, and the return value is used to represent that object in
         *   the preview text.
         *   - Parameters:
         *     1. {*} The object.
         *   - Returns: {String} The string to include in the preview text.
         *
         * @param {*} [Options.CallbackString = PropsInfoTree_PreviewFormat_CallbackString_Quoted] -
         * If set, a `Func` or callable object to which all string values are passed to process the
         * string, such as enclosing the string in quote characters and escaping carriage return
         * / line feed / quote characters.
         * - Parameters:
         *   1. {VarRef} - The string to process. Modify the value directly.
         * - The return value is ignored.
         *
         * The default function is {@link PropsInfoTree_PreviewFormat_CallbackString_Quoted}, which
         * encloses the string in double quotes, replaces line feed characters with "`n", replaces
         * carriage return characters with "`r", and replaces double quote characters with "`"".
         *
         * If `Options.QuotedStrings` is false, and if your code does not provide
         * `Options.CallbackString`, {@link PropsInfoTree_PreviewFormat_CallbackString} is
         * used instead. {@link PropsInfoTree_PreviewFormat_CallbackString} replaces line feed
         * characters with "`n", and replaces carriage return characters with "`r".
         *
         * If you provide a `Options.CallbackString` value, and if `Options.QuotedStrings` is true,
         * the `Options.CallbackString` function must add enclosing double quotes.
         *
         * @param {String} [Options.Format = "{<%!type%> }{[ %!enum% ] }{\{ %!props% \}}"] -
         * {@link PropsInfoTree_PreviewFormat} utilizes {@link FormatStr}, a customizable and extensible
         * text formatting system. It is based on a system of caller-defined codes and callback
         * functions. In our context here, you can define a format string that customizes the tree-view
         * item label depending on the type of object associated with that tree-view item.
         *
         * @param {String} [Options.IncludeErrors = false] - If true, when attempting to access
         * a property's value results in an error, the error object is passed to `CallbackGetType`
         * and the return value is used to represent the property's value in the preview text. If
         * false, when attempting to access a property's value results in an error, the property
         * is skipped.
         *
         * @param {Integer} [Options.MaxExtentEnum = 400] - An integer representing the maximum text extent
         * for the !enum, !enum1, or !enum2 substring. The substring will be truncated, ending with
         * a comma and ellipses (e.g. "item", "item", "item", ...) if including all of the items
         * would exceed the maximum extent. This options is ignored if !enum, !enum1, and !enum2
         * are not represented in the format string.
         *
         * @param {Integer} [Options.MaxExtentEnumItem = 150] - An integer representing the maximum text extent
         * for any single value that is processed from the object's enumerator. The substring will
         * be truncated, ending with an ellipses (e.g. "very long string exa..."). This options is
         * ignored if !enum, !enum1, and !enum2 are not represented in the format string. This option
         * only applies to string values. Object and number values are represented in their entirety.
         *
         * @param {Integer} [Options.MaxExtentPropValue = 150] - An integer repesenting the maximum text
         * extent for any single property value. The substring will be truncated, ending with an
         * ellipses (e.g. "very long string exa..."). This option is applied to individual properties
         * listed in the format string as well as properties included as a result of the !props
         * format specifier. This options is ignored if !props is not represented in the format
         * string and if no individual properties are included in the format string. This option
         * only applies to string values. Object and number values are represented in their entirety.
         *
         * @param {Integer} [Options.MaxExtentProps = 400] - An integer representing the maximum text extent
         * for the !props substring. The substring will be truncated, ending with a comma and
         * ellipses (e.g. prop1: "val1", prop2: "val2", ...) if including all of the properties would
         * exceed the maximum extent. This options is ignored if !props is not represented in the
         * format string.
         *
         * @param {Boolean} [Options.NumericStringAsNumber = true] - If true, numeric strings are not enclosed
         * in double quotes. If false, numeric strings are enclosed in double quotes if
         * `Type(value) = "String"`. `Options.NumericStringAsNumber` is ignored if
         * `Options.QuotedStrings` is false.
         *
         * @param {String[]} [Options.PropertyList] -
         * - If set, an array of strings where each item in the array is the name of a property
         *   to include in the preview text. Your code should define `Format` with the properties as
         *   format specifiers. Here are some condisderations:
         *   - If there is a possibility that the property does not exist or that the property has
         *     an empty string / zero value, and if you would like the property to be skipped in that
         *     case, you can enclose the item in curly braces, which is the operator for a conditional
         *     group.
         *   - The format function will only replace the format specifier with the property value;
         *     it will not include the property name. Your format string should provide the property
         *     names if you would like the property names to be represented in the preview text.
         *
         * @param {Boolean} [Options.QuotedStrings = true] - If true, string values are enclosed
         * in double quotes.
         *
         * If `Options.QuotedStrings` is false, and if your code does not provide
         * `Options.CallbackString`, {@link PropsInfoTree_PreviewFormat_CallbackString} is
         * used instead of {@link PropsInfoTree_PreviewFormat_CallbackString_Quoted}.
         * {@link PropsInfoTree_PreviewFormat_CallbackString} replaces line feed characters with
         * "`n", and replaces carriage return characters with "`r".
         *
         * @param {String} [Options.Separator = ", "] - The substring that separates values returned
         * by the enumerator and property : value pairs when processing the !props format specifier.
         *
         * @param {Map} [Options.SpecifierCodes] - A Map with caller-defined specifier codes. Specifier
         * codes are optional values used to extend {@link FormatStr} with custom logic. See the
         * {@link https://github.com/Nich-Cebolla/AutoHotkey-FormatStr/tree/main readme} for more
         * information.
         *
         * @param {String} [Options.Type] - The object type to associate with this item.
         */
        __New(Options?) {
            if IsSet(Options) {
                PropsInfoTree_PreviewFormat.Item.Options(this, Options)
                if this.QuotedStrings {
                    this.DefineProp('Call', PropsInfoTree_PreviewFormat.Item.Prototype.GetOwnPropDesc('__Call_Quoted'))
                } else if !HasProp(Options, 'CallbackString') {
                    this.CallbackString := PropsInfoTree_PreviewFormat_CallbackString
                }
            } else if this.QuotedStrings {
                this.DefineProp('Call', PropsInfoTree_PreviewFormat.Item.Prototype.GetOwnPropDesc('__Call_Quoted'))
            }
            names := this.DefaultList.Clone()
            if this.PropertyList {
                names.Push(this.PropertyList*)
            }
            formatStrOptions := { Callback: this, ReturnArray: true }
            if HasProp(Options, 'SpecifierCodes') {
                formatStrOptions.SpecifierCodes := Options.SpecifierCodes
            }
            this.FormatStrConstructor := FormatStrConstructor(names, formatStrOptions)
            this.FormatFunction := this.FormatStrConstructor.Call(HasProp(Options, 'Format') ? Options.Format : this.DefaultFormat)
            ObjRelease(ObjPtr(this))
        }
        Align(Node, *) {
            context := TreeViewEx_SelectFontIntoDc(node.HwndCtrl)
            preview := this.FormatFunction.Call([ node, context.hdc ])
            if IsObject(preview) {
                extentList := this.__AlignNode.__AddChildrenExtentList
                if !extentList.Length {
                    loop extentList.Length := preview.Length {
                        extentList[A_Index] := 0
                    }
                }
                sz := TreeViewEx_Size()
                for obj in preview {
                    if StrLen(obj.Value) && InStr('FormatStrToken_FormatSpecifierFormatStrToken_SimpleCondition'
                    'FormatStrToken_SignificantCondition', obj.Token.__Class) {
                        obj.Extent := _GetExtent(String(obj.Value))
                        if obj.Extent > extentList[A_Index] {
                            extentList[A_Index] := obj.Extent
                        }
                    }
                }
                this.__AlignNode.__AddChildrenPreviewList.Push(preview)
            }
            context()

            return

            _GetExtent(str) {
                if DllCall(
                    g_gdi32_GetTextExtentPoint32W
                    , 'Ptr', context.hdc
                    , 'Ptr', StrPtr(str)
                    , 'Int', StrLen(str)
                    , 'Ptr', sz
                    , 'Int'
                ) {
                    return sz.W
                } else {
                    throw OSError()
                }
            }
        }
        Call(Name, Params, *) {
            switch Name {
                case '!type1': return Type(Params[1].Value)
                case '!type2': return PropsInfoTree_GetDisplayType(Params[1].Value)
                case '!enum', '!enum1', '!enum2':
                    node := Params[1]
                    enumCount := node.EnumCount
                    if !enumCount {
                        return
                    }
                    hdc := Params[2]
                    separator := this.Separator
                    value := Node.value
                    s := ''
                    VarSetStrCapacity(&s, 2048)
                    s .= '[ '
                    callbackGetType := this.CallbackGetType
                    callbackString := this.CallbackString
                    sz := TreeViewEx_Size()
                    lpnFit := Buffer(4)
                    e := '...'
                    if this.SeparatorExtent {
                        separatorExtent := this.SeparatorExtent
                        ellipsesExtent := this.EllipsesExtent
                        unsetExtent := this.UnsetExtent
                        bracketExtent := this.BracketExtentSquare
                    } else {
                        separatorExtent := this.SeparatorExtent := _GetExtent(&separator)
                        ellipsesExtent := this.EllipsesExtent := _GetExtent(&e)
                        ch := 'unset'
                        unsetExtent := this.UnsetExtent := _GetExtent(&ch)
                        ch := '[  ]'
                        bracketExtent := this.BracketExtentSquare := _GetExtent(&ch)
                        ch := '{  }'
                        this.BracketExtentCurly := _GetExtent(&ch)
                    }
                    partialExtent := ellipsesExtent
                    minRemainingExtent := ellipsesExtent + separatorExtent + 10
                    maxExtentEnum := this.MaxExtentEnum - separatorExtent - ellipsesExtent - bracketExtent
                    maxExtentEnumItem := this.MaxExtentEnumItem
                    extent := 0
                    switch Name {
                        case '!enum':
                            if value is Array {
                                _Enum1()
                            } else if value is Gui || value is RegExMatchInfo || value is Map {
                                _Enum2()
                            } else {
                                try {
                                    _Enum2()
                                } catch {
                                    s := ''
                                    VarSetStrCapacity(&s, 2048)
                                    s .= '[ '
                                    try {
                                        _Enum1()
                                    } catch {
                                        return
                                    }
                                }
                            }
                        case '!enum1':
                            try {
                                _Enum1()
                            } catch {
                                return
                            }
                        case '!enum2':
                            try {
                                _Enum2()
                            } catch {
                                return
                            }
                    }
                    return s
                case '!props':
                    node := Params[1]
                    propsList := node.PropsList
                    if !propsList {
                        return
                    }
                    hdc := Params[2]
                    separator := this.Separator
                    s := ''
                    VarSetStrCapacity(&s, 2048)
                    s .= '{ '
                    callbackGetType := this.CallbackGetType
                    callbackString := this.CallbackString
                    sz := TreeViewEx_Size()
                    lpnFit := Buffer(4)
                    e := '...'
                    if this.SeparatorExtent {
                        separatorExtent := this.SeparatorExtent
                        ellipsesExtent := this.EllipsesExtent
                        bracketExtent := this.BracketExtentCurly
                    } else {
                        separatorExtent := this.SeparatorExtent := _GetExtent(&separator)
                        ellipsesExtent := this.EllipsesExtent := _GetExtent(&e)
                        ch := 'unset'
                        unsetExtent := this.UnsetExtent := _GetExtent(&ch)
                        ch := '[  ]'
                        this.BracketExtentSquare := _GetExtent(&ch)
                        ch := '{  }'
                        bracketExtent := this.BracketExtentCurly := _GetExtent(&ch)
                    }
                    minRemainingExtent := ellipsesExtent + separatorExtent + 10
                    maxExtentProps := this.MaxExtentProps - separatorExtent - ellipsesExtent - bracketExtent
                    maxExtentPropValue := this.MaxExtentPropValue
                    includeErrors := this.IncludeErrors
                    extent := 0
                    for o in propsList {
                        if o.IsError && !includeErrors {
                            continue
                        }
                        _str := ''
                        VarSetStrCapacity(&_str, 1024)
                        _str .= o.InfoItem.Name ': '
                        if IsObject(o.Value) {
                            _str .= '{ ' callbackGetType(o.Value) ' }'
                        } else if IsNumber(o.Value) {
                            _str .= o.Value
                        } else {
                            v := o.Value
                            callbackString(&v)
                            _extent := _GetExtent(&v)
                            if _extent > maxExtentPropValue {
                                v := SubStr(v, 1, _GetFit(&v, maxExtentPropValue - ellipsesExtent)) e
                                _extent := _GetExtent(&v)
                            }
                            _str .= v
                        }
                        _extent := _GetExtent(&_str)
                        if extent + _extent > maxExtentProps {
                            s .= e ' }'
                            return
                        } else {
                            s .= _str separator
                            extent += _extent + separatorExtent
                        }
                    }
                    s .= ' }'
                    return s
                default:
                    node := Params[1]
                    if !HasProp(node.Value, Name) {
                        return
                    }
                    if InStr(Name, '.') {
                        v := GetObjectFromString(Name, node.Value)
                    } else {
                        v := node.Value.%Name%
                    }
                    if IsObject(v) {
                        return '{ ' this.CallbackGetType.Call(v) ' }'
                    } else if IsNumber(v) {
                        return v
                    } else {
                        hdc := Params[2]
                        sz := TreeViewEx_Size()
                        if !this.SeparatorExtent {
                            ch := this.Separator
                            this.SeparatorExtent := _GetExtent(&ch)
                            ch := '...'
                            this.EllipsesExtent := _GetExtent(&ch)
                            ch := 'unset'
                            this.UnsetExtent := _GetExtent(&ch)
                            ch := '[  ]'
                            this.BracketExtentSquare := _GetExtent(&ch)
                            ch := '{  }'
                            this.BracketExtentCurly := _GetExtent(&ch)
                        }
                        this.CallbackString.Call(&v)
                        _extent := _GetExtent(&v)
                        if _extent > this.MaxExtentPropValue {
                            lpnFit := Buffer(4)
                            return SubStr(v, 1, _GetFit(&v, this.MaxExtentPropValue - this.EllipsesExtent)) '...'
                        } else {
                            return v
                        }
                    }
            }

            return

            _Enum1() {
                for v in value {
                    if IsSet(v) {
                        if IsObject(v) {
                            v := '{ ' callbackGetType(v) ' }'
                            _extent := _GetExtent(&v)
                        } else if IsNumber(v) {
                            _extent := _GetExtent(&v)
                        } else {
                            callbackString(&v)
                            _extent := _GetExtent(&v)
                            if _extent > maxExtentEnumItem {
                                if extent + maxExtentEnumItem > maxExtentEnum {
                                    if A_Index < enumCount {
                                        cch := _GetFit(&v, maxExtentEnum - extent - ellipsesExtent * 2 - separatorExtent)
                                        if cch < 5 {
                                            s .= e
                                        } else {
                                            s .= SubStr(v, 1, cch) e separator e
                                        }
                                    } else {
                                        cch := _GetFit(&v, maxExtentEnum - extent - ellipsesExtent)
                                        if cch < 5 {
                                            s .= e
                                        } else {
                                            s .= SubStr(v, 1, cch) e
                                        }
                                    }
                                    s .= ' ]'
                                    return
                                }
                                v := SubStr(v, 1, _GetFit(&v, maxExtentEnumItem - ellipsesExtent)) e
                                _extent := _GetExtent(&v)
                                s .= v
                            } else if extent + _extent > maxExtentEnum {
                                if A_Index < enumCount {
                                    cch := _GetFit(&v, maxExtentEnum - extent - ellipsesExtent * 2 - separatorExtent)
                                    if cch < 5 {
                                        s .= e
                                    } else {
                                        s .= SubStr(v, 1, cch) e separator e
                                    }
                                } else {
                                    cch := _GetFit(&v, maxExtentEnum - extent - ellipsesExtent)
                                    if cch < 5 {
                                        s .= e
                                    } else {
                                        s .= SubStr(v, 1, cch) e
                                    }
                                }
                                s .= ' ]'
                                return
                            } else {
                                s .= v
                            }
                            extent += _extent
                            if extent + minRemainingExtent > maxExtentEnum {
                                if A_Index < enumCount {
                                    s .= separator e
                                }
                                s .= ' ]'
                                return
                            } else {
                                s .= separator
                                extent += separatorExtent
                            }
                            continue
                        }
                    } else {
                        v := 'unset'
                        _extent := unsetExtent
                    }
                    if extent + _extent > maxExtentEnum {
                        s .= e
                        s .= ' ]'
                        return
                    }
                    s .= v
                    extent += _extent
                    if extent + minRemainingExtent > maxExtentEnum {
                        if A_Index < enumCount {
                            s .= separator e
                        }
                        s .= ' ]'
                        return
                    } else {
                        s .= separator
                        extent += separatorExtent
                    }
                }
            }
            _Enum2() {
                for k, v in value {
                    _str := ''
                    VarSetStrCapacity(&_str, 1024)
                    _str .= '[ '
                    if IsObject(k) {
                        _str .= '{ ' callbackGetType(v) ' }'
                    } else if IsNumber(k) {
                        _str .= k
                    } else {
                        callbackString(&k)
                        _extent := _GetExtent(&k)
                        if _extent > maxExtentEnumItem {
                            k := SubStr(k, 1, _GetFit(&k, maxExtentEnumItem - ellipsesExtent)) e
                            _extent := _GetExtent(&k)
                        }
                    }
                    _str .= separator
                    if IsObject(v) {
                        _str .= '{ ' callbackGetType(v) ' }'
                    } else if IsNumber(v) {
                        _str .= v
                    } else {
                        callbackString(&v)
                        _extent := _GetExtent(&v)
                        if _extent > maxExtentEnumItem {
                            v := SubStr(v, 1, _GetFit(&v, maxExtentEnumItem - ellipsesExtent)) e
                            _extent := _GetExtent(&v)
                        }
                    }
                    _str .= ' ]'
                    _extent := _GetExtent(&_str)
                    if extent + _extent > maxExtentEnum {
                        s .= e ' ]'
                        return
                    } else {
                        s .= _str separator
                        extent += _extent + separatorExtent
                    }
                }
                s .= ' ]'
            }
            _GetExtent(&str) {
                if DllCall(
                    g_gdi32_GetTextExtentPoint32W
                    , 'Ptr', hdc
                    , 'Ptr', StrPtr(str)
                    , 'Int', StrLen(str)
                    , 'Ptr', sz
                    , 'Int'
                ) {
                    return sz.W
                } else {
                    throw OSError()
                }
            }
            _GetFit(&str, maxExtent) {
                if DllCall(
                    g_gdi32_GetTextExtentExPointW
                    , 'ptr', hdc
                    , 'ptr', StrPtr(str)                                    ; String to measure
                    , 'int', StrLen(str)                                    ; String length in WORDs
                    , 'int', maxExtent                                      ; Maximum extent
                    , 'ptr', lpnFit                                         ; To receive number of characters that can fit
                    , 'ptr', 0                                              ; lpnDx
                    , 'ptr', sz                                             ; To receive the dimensions of the string.
                    , 'ptr'
                ) {
                    return NumGet(lpnFit, 0, 'int')
                } else {
                    throw OSError()
                }
            }
        }
        __Call_Quoted(Name, Params, *) {
            switch Name {
                case '!type1': return Type(Params[1].Value)
                case '!type2': return PropsInfoTree_GetDisplayType(Params[1].Value)
                case '!enum', '!enum1', '!enum2':
                    node := Params[1]
                    enumCount := node.EnumCount
                    if !enumCount {
                        return
                    }
                    hdc := Params[2]
                    separator := this.Separator
                    value := Node.value
                    s := ''
                    VarSetStrCapacity(&s, 2048)
                    s .= '[ '
                    callbackGetType := this.CallbackGetType
                    callbackString := this.CallbackString
                    numericStringAsNumber := this.NumericStringAsNumber
                    sz := TreeViewEx_Size()
                    lpnFit := Buffer(4)
                    e := '...'
                    if this.SeparatorExtent {
                        separatorExtent := this.SeparatorExtent
                        ellipsesExtent := this.EllipsesExtent
                        quoteExtent := this.QuoteExtent
                        unsetExtent := this.UnsetExtent
                        bracketExtent := this.BracketExtentSquare
                    } else {
                        separatorExtent := this.SeparatorExtent := _GetExtent(&separator)
                        ellipsesExtent := this.EllipsesExtent := _GetExtent(&e)
                        ch := '"'
                        quoteExtent := this.QuoteExtent := _GetExtent(&ch)
                        ch := 'unset'
                        unsetExtent := this.UnsetExtent := _GetExtent(&ch)
                        ch := '[  ]'
                        bracketExtent := this.BracketExtentSquare := _GetExtent(&ch)
                        ch := '{  }'
                        this.BracketExtentCurly := _GetExtent(&ch)
                    }
                    partialExtent := ellipsesExtent - quoteExtent * 2
                    minRemainingExtent := partialExtent + separatorExtent + 10
                    maxExtentEnum := this.MaxExtentEnum - separatorExtent - ellipsesExtent - bracketExtent
                    maxExtentEnumItem := this.MaxExtentEnumItem
                    extent := 0
                    switch Name {
                        case '!enum':
                            if value is Array {
                                _Enum1()
                            } else if value is Gui || value is RegExMatchInfo || value is Map {
                                _Enum2()
                            } else {
                                try {
                                    _Enum2()
                                } catch {
                                    s := ''
                                    VarSetStrCapacity(&s, 2048)
                                    s .= '[ '
                                    try {
                                        _Enum1()
                                    } catch {
                                        return
                                    }
                                }
                            }
                        case '!enum1':
                            try {
                                _Enum1()
                            } catch {
                                return
                            }
                        case '!enum2':
                            try {
                                _Enum2()
                            } catch {
                                return
                            }
                    }
                    return s
                case '!props':
                    node := Params[1]
                    propsList := node.PropsList
                    if !propsList {
                        return
                    }
                    hdc := Params[2]
                    separator := this.Separator
                    s := ''
                    VarSetStrCapacity(&s, 2048)
                    s .= '{ '
                    callbackGetType := this.CallbackGetType
                    callbackString := this.CallbackString
                    numericStringAsNumber := this.NumericStringAsNumber
                    sz := TreeViewEx_Size()
                    lpnFit := Buffer(4)
                    e := '...'
                    if this.SeparatorExtent {
                        separatorExtent := this.SeparatorExtent
                        ellipsesExtent := this.EllipsesExtent
                        quoteExtent := this.QuoteExtent
                        bracketExtent := this.BracketExtentCurly
                    } else {
                        separatorExtent := this.SeparatorExtent := _GetExtent(&separator)
                        ellipsesExtent := this.EllipsesExtent := _GetExtent(&e)
                        ch := '"'
                        quoteExtent := this.QuoteExtent := _GetExtent(&ch)
                        ch := 'unset'
                        unsetExtent := this.UnsetExtent := _GetExtent(&ch)
                        ch := '[  ]'
                        this.BracketExtentSquare := _GetExtent(&ch)
                        ch := '{  }'
                        bracketExtent := this.BracketExtentCurly := _GetExtent(&ch)
                    }
                    partialExtent := ellipsesExtent - quoteExtent * 2
                    minRemainingExtent := partialExtent + separatorExtent + 10
                    maxExtentProps := this.MaxExtentProps - separatorExtent - ellipsesExtent - bracketExtent
                    maxExtentPropValue := this.MaxExtentPropValue
                    includeErrors := this.IncludeErrors
                    extent := 0
                    for o in propsList {
                        if o.IsError && !includeErrors {
                            continue
                        }
                        _str := ''
                        VarSetStrCapacity(&_str, 1024)
                        _str .= o.InfoItem.Name ': '
                        if IsObject(o.Value) {
                            _str .= '{ ' callbackGetType(o.Value) ' }'
                        } else if IsNumber(o.Value) {
                            if !numericStringAsNumber && Type(o.Value) = 'String' {
                                _str .= '"' o.Value '"'
                            } else {
                                _str .= o.Value
                            }
                        } else {
                            v := o.Value
                            callbackString(&v)
                            _extent := _GetExtent(&v)
                            if _extent > maxExtentPropValue {
                                v := SubStr(v, 2, -1)
                                v := '"' SubStr(v, 1, _GetFit(&v, maxExtentPropValue - partialExtent)) e '"'
                                _extent := _GetExtent(&v)
                            }
                            _str .= v
                        }
                        _extent := _GetExtent(&_str)
                        if extent + _extent > maxExtentProps {
                            s .= e ' }'
                            return
                        } else {
                            s .= _str separator
                            extent += _extent + separatorExtent
                        }
                    }
                    s .= ' }'
                    return s
                default:
                    ; `Name` is expected to be the name of a property on o.Value
                    ; this function will return the value of `node.Value.%Name%` after processing
                    ; and, if the value is a string, measuring it. The value is returned to
                    ; `FormatStr.Prototype.Call`, which was called by
                    ; `PropsInfoTree_Node_Object.Prototype.GetPreview`.

                    ; `FormatStr.Prototype.Call` may still modify this function's return value
                    ; if the user passed a value to parameter `SpecifierCodes` of `PropsInfoTree_PreviewFormat.Prototype.__New`.
                    ; If this function adds quotes to the string value, then the specifier code function
                    ; must account for this on its own.
                    node := Params[1]
                    if !HasProp(node.Value, Name) {
                        return
                    }
                    v := node.Value.%Name%
                    if IsObject(v) {
                        return '{ ' this.CallbackGetType.Call(v) ' }'
                    } else if IsNumber(v) {
                        if !this.NumericStringAsNumber && Type(v) = 'String' {
                            return '"' v '"'
                        } else {
                            return v
                        }
                    } else {
                        hdc := Params[2]
                        sz := TreeViewEx_Size()
                        if !this.SeparatorExtent {
                            ch := this.Separator
                            this.SeparatorExtent := _GetExtent(&ch)
                            ch := '...'
                            this.EllipsesExtent := _GetExtent(&ch)
                            ch := '"'
                            this.QuoteExtent := _GetExtent(&ch)
                            ch := 'unset'
                            this.UnsetExtent := _GetExtent(&ch)
                            ch := '[  ]'
                            this.BracketExtentSquare := _GetExtent(&ch)
                            ch := '{  }'
                            this.BracketExtentCurly := _GetExtent(&ch)
                        }
                        this.CallbackString.Call(&v)
                        _extent := _GetExtent(&v)
                        if _extent > this.MaxExtentPropValue {
                            lpnFit := Buffer(4)
                            v := SubStr(v, 2, -1)
                            return '"' SubStr(v, 1, _GetFit(&v, this.MaxExtentPropValue - this.EllipsesExtent - this.QuoteExtent * 2)) '..."'
                        } else {
                            return v
                        }
                    }
            }

            return

            _Enum1() {
                for v in value {
                    if IsSet(v) {
                        if IsObject(v) {
                            v := '{ ' callbackGetType(v) ' }'
                            _extent := _GetExtent(&v)
                        } else if IsNumber(v) {
                            if !numericStringAsNumber && Type(v) = 'String' {
                                v := '"' v '"'
                            }
                            _extent := _GetExtent(&v)
                        } else {
                            callbackString(&v)
                            _extent := _GetExtent(&v)
                            if _extent > maxExtentEnumItem {
                                v := SubStr(v, 2, -1)
                                if extent + maxExtentEnumItem > maxExtentEnum {
                                    if A_Index < enumCount {
                                        cch := _GetFit(&v, maxExtentEnum - extent - partialExtent - separatorExtent - ellipsesExtent)
                                        if cch < 5 {
                                            s .= e
                                        } else {
                                            s .= '"' SubStr(v, 1, cch) e '"' separator e
                                        }
                                    } else {
                                        cch := _GetFit(&v, maxExtentEnum - extent - partialExtent)
                                        if cch < 5 {
                                            s .= e
                                        } else {
                                            s .= '"' SubStr(v, 1, cch) e '"'
                                        }
                                    }
                                    s .= ' ]'
                                    return
                                }
                                v := '"' SubStr(v, 1, _GetFit(&v, maxExtentEnumItem - partialExtent)) e '"'
                                _extent := _GetExtent(&v)
                                s .= v
                            } else if extent + _extent > maxExtentEnum {
                                v := SubStr(v, 2, -1)
                                if A_Index < enumCount {
                                    cch := _GetFit(&v, maxExtentEnum - extent - partialExtent - separatorExtent - ellipsesExtent)
                                    if cch < 5 {
                                        s .= e
                                    } else {
                                        s .= '"' SubStr(v, 1, cch) e '"' separator e
                                    }
                                } else {
                                    cch := _GetFit(&v, maxExtentEnum - extent - partialExtent)
                                    if cch < 5 {
                                        s .= e
                                    } else {
                                        s .= '"' SubStr(v, 1, cch) e '"'
                                    }
                                }
                                s .= ' ]'
                                return
                            } else {
                                s .= v
                            }
                            extent += _extent
                            if extent + minRemainingExtent > maxExtentEnum {
                                if A_Index < enumCount {
                                    s .= separator e
                                }
                                s .= ' ]'
                                return
                            } else {
                                s .= separator
                                extent += separatorExtent
                            }
                            continue
                        }
                    } else {
                        v := 'unset'
                        _extent := unsetExtent
                    }
                    if extent + _extent > maxExtentEnum {
                        s .= e
                        s .= ' ]'
                        return
                    }
                    s .= v
                    extent += _extent
                    if extent + minRemainingExtent > maxExtentEnum {
                        if A_Index < enumCount {
                            s .= separator e
                        }
                        s .= ' ]'
                        return
                    } else {
                        s .= separator
                        extent += separatorExtent
                    }
                }
            }
            _Enum2() {
                for k, v in value {
                    _str := ''
                    VarSetStrCapacity(&_str, 1024)
                    _str .= '[ '
                    if IsObject(k) {
                        _str .= '{ ' callbackGetType(v) ' }'
                    } else if IsNumber(k) {
                        if !numericStringAsNumber && Type(v) = 'String' {
                            _str .= '"' k '"'
                        } else {
                            _str .= k
                        }
                    } else {
                        callbackString(&k)
                        _extent := _GetExtent(&k)
                        if _extent > maxExtentEnumItem {
                            k := SubStr(k, 2, -1)
                            k := '"' SubStr(k, 1, _GetFit(&k, maxExtentEnumItem - partialExtent)) e '"'
                            _extent := _GetExtent(&k)
                        }
                    }
                    _str .= separator
                    if IsObject(v) {
                        _str .= '{ ' callbackGetType(v) ' }'
                    } else if IsNumber(v) {
                        if !numericStringAsNumber && Type(v) = 'String' {
                            _str .= '"' v '"'
                        } else {
                            _str .= v
                        }
                    } else {
                        callbackString(&v)
                        _extent := _GetExtent(&v)
                        if _extent > maxExtentEnumItem {
                            v := SubStr(v, 2, -1)
                            v := '"' SubStr(v, 1, _GetFit(&v, maxExtentEnumItem - partialExtent)) e '"'
                            _extent := _GetExtent(&v)
                        }
                    }
                    _str .= ' ]'
                    _extent := _GetExtent(&_str)
                    if extent + _extent > maxExtentEnum {
                        s .= e ' ]'
                        return
                    } else {
                        s .= _str separator
                        extent += _extent + separatorExtent
                    }
                }
                s .= ' ]'
            }
            _GetExtent(&str) {
                if DllCall(
                    g_gdi32_GetTextExtentPoint32W
                    , 'Ptr', hdc
                    , 'Ptr', StrPtr(str)
                    , 'Int', StrLen(str)
                    , 'Ptr', sz
                    , 'Int'
                ) {
                    return sz.W
                } else {
                    throw OSError()
                }
            }
            _GetFit(&str, maxExtent) {
                if DllCall(
                    g_gdi32_GetTextExtentExPointW
                    , 'ptr', hdc
                    , 'ptr', StrPtr(str)                                    ; String to measure
                    , 'int', StrLen(str)                                    ; String length in WORDs
                    , 'int', maxExtent                                      ; Maximum extent
                    , 'ptr', lpnFit                                         ; To receive number of characters that can fit
                    , 'ptr', 0                                              ; lpnDx
                    , 'ptr', sz                                             ; To receive the dimensions of the string.
                    , 'ptr'
                ) {
                    return NumGet(lpnFit, 0, 'int')
                } else {
                    throw OSError()
                }
            }
        }
        __Delete() {
            ObjPtrAddRef(this)
            if this.FormatStrConstructor {
                this.DeleteProp('FormatStrConstructor')
            }
            if this.FormatFunction {
                this.DeleteProp('FormatFunction')
            }
        }

        Format => this.FormatFunction.FormatStr

        class Options {
            static Options := [ 'AlignSegments', 'CallbackString', 'IncludeErrors'
            , 'MaxExtentEnumItem', 'MaxExtentPropValue', 'MaxExtentEnum', 'MaxExtentProps'
            , 'NumericStringAsNumber', 'PropertyList', 'QuotedStrings', 'Type', 'Separator' ]
            static Call(Item, Options) {
                for prop in this.Options {
                    if HasProp(Options, prop) {
                        Item.%prop% := Options.%prop%
                    }
                }
                if HasProp(Options, 'CallbackGetType') {
                    if IsObject(Options.CallbackGetType) {
                        Item.CallbackGetType := Options.CallbackGetType
                    } else {
                        switch Options.CallbackGetType, 0 {
                            case 1: ; do nothing
                            case 2: Item.CallbackGetType := PropsInfoTree_GetDisplayType
                            default: throw ValueError('Invalid ``CallbackGetType`` value.', , Options.CallbackGetType)
                        }
                    }
                }
            }
        }
    }
}

PropsInfoTree_PreviewFormat_CallbackString(&str) {
    str := StrReplace(StrReplace(str, '`n', '``n'), '`r', '``r')
}
PropsInfoTree_PreviewFormat_CallbackString_Quoted(&str) {
    str := '"' StrReplace(StrReplace(StrReplace(str, '`n', '``n'), '`r', '``r'), '"', '``"') '"'
}


class PropsInfoTree_PropsInfoParams {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.StopAt := '-Object'
        proto.Exclude := ''
        proto.ExcludeMethods := false
    }
}


class PropsInfoTree_PropsTypeMap extends Container {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.ToCbString(PropsInfoTree_CallbackValue_Type, , LINGUISTIC_IGNORECASE)
        proto.CallbackType := [ PropsInfoTree_GetDisplayType, Type ]
        proto.AddDefaultToItems := false
        proto.Default := ''
    }
    /**
     * {@link PropsInfoTree_PropsTypeMap} can be used with {@link PropsInfoTree.Options#CallbackProcessProps}.
     *
     * Creates an object that can be used to conditionally exclude properties as a function
     * of the type of object that is being evaluated. This is intended to be used as a callback function
     * for {@link PropsInfoTree.Options#CallbackProcessProps}, which is called for each property
     * that is evaluated within the body of {@link PropsInfoTree_Node_Object.Prototype.EvaluateObject}.
     *
     * In the below example, when {@link PropsInfoTree_Node_Object.Prototype.EvaluateObject} processes
     * a value, if the value is a `Map` or `Buffer` object, the associated item will be retrieved
     * from the container and the properties in "List" will be skipped and will not be represented
     * in the tree-view control for that value.
     *
     * @example
     * ptm := PropsInfoTree_PropsTypeMap([
     *     { Type: "Map", List: "Count,__Class,Capacity" }
     *   , { Type: "Buffer", List: "Size,Ptr" }
     * ])
     * propsInfoTreeOptions := { CallbackProcessProps: ptm }
     * g := Gui()
     * pit := PropsInfoTree(g, , propsInfoTreeOptions)
     * @
     *
     * Note that, by default, the built-in properties for `Array`, `Buffer`, `Class`, `Map` and
     * `Object` are not represented as tree-view items, and so the above code would actually be
     * inconsequential.
     *
     * The above example demonstrates how to use {@link PropsInfoTree_PropsTypeMap} to specify properties to
     * exclude from the {@link PropsInfoTree}. To instead use {@link PropsInfoTree_PropsTypeMap} to specify
     * properties to include, set the "Positive" value to 0.
     *
     * @example
     * ptm := PropsInfoTree_PropsTypeMap([
     *     { Type: "Map", List: "Count,__Class,Capacity", Positive: 0 }
     *   , { Type: "Buffer", List: "Size,Ptr", Positive: 0 }
     * ])
     * propsInfoTreeOptions := { CallbackProcessProps: ptm }
     * g := Gui()
     * pit := PropsInfoTree(g, , propsInfoTreeOptions)
     * @
     *
     * This will direct {@link PropsInfoTree_Node_Object.Prototype.EvaluateObject} to only include
     * properties in the list.
     *
     *
     * @param {Object|PropsInfoTree_PropsTypeMap.Item|Object[]|PropsInfoTree_PropsTypeMap.Item[]} [Items] - One of the following:
     * - An object with properties as described below.
     * - A {@link PropsInfoTree_PropsTypeMap.Item} object.
     * - An array of objects with properties as described below.
     * - An array of {@link PropsInfoTree_PropsTypeMap.Item} objects.
     *
     * Objects can have the following properties:
     * - {String|String[]} Type (required) - The object type to associate with the item, or an array
     *   of object types to associate with the item.
     * - {String} List (required) - A comma-separated list of property names, e.g. "__Class,Prototype,Count".
     * - {*} Positive (optional) - If set, this specifies the return value when the item object is called
     *   for a property that is in the list.
     * - {*} Negative (optional) - If set, this specifies the return value when the item object is called
     *   with a property name that is not in the list.
     * - {Boolean} AddToDefault (optional) - If set, and if true, when
     *   {@link PropsInfoTree_PropsTypeMap.Prototype.__New} process the item, if parameter
     *   {@link PropsInfoTree_PropsTypeMap.Prototype.__New~DefaultItem DefaultItem} is set,
     *   the default list of properties are appended to this item's list.
     *
     * @param {Object|PropsInfoTree_PropsTypeMap.Item|String} [DefaultItem] - If set, when the object is called with
     * a string that is not found in the container, the default item is returned.
     *
     * If `DefaultItem` is an object, it can have the following properties:
     * - List (required) - A comma-separated list of property names, e.g. "__Class,Prototype,Count".
     * - Positive (optional) - If set, this specifies the return value when the item object is called
     *   with a property name that is in the list.
     * - Negative (optional) - If set, this specifies the return value when the item object is called
     *   with a property name that is not in the list.
     *
     * `DefaultItem` can also be a string list of comma-separated properties.
     *
     * @param {*|*[]} [CallbackType] - A `Func` or callable object that returns the type string
     * used to select an item from the container.
     * - Parmeter:
     *   1. {*} The object being evaluated.
     * - Returns: {String} The string used to select an item from the container.
     *
     * `CallbackType` can also be an array of callable objects. When an array, the objects are called
     * in order until one returns a value that is found in the container, or until each has been called.
     *
     * If unset, the default value is an array with two functions: {@link PropsInfoTree_GetDisplayType}
     * and `Type`.
     */
    __New(Items?, DefaultItem?, CallbackType?) {
        constructor := PropsInfoTree_PropsTypeMap.Item
        cls := constructor.Prototype.__Class
        if IsSet(Items) {
            if not Items is Array {
                Items := [ Items ]
            }
            for item in Items {
                if item.__Class = cls {
                    this.Insert(item)
                } else if item.Type is Array {
                    params := [ item.List ]
                    params.Length := 4
                    if HasProp(item, 'Positive') {
                        params[2] := item.Positive
                    }
                    if HasProp(item, 'Negative') {
                        params[3] := item.Negative
                    }
                    if HasProp(item, 'AddToDefault') {
                        params[4] := item.AddToDefault
                    }
                    for t in item.Type {
                        this.Insert(constructor(t, params*))
                    }
                } else {
                    this.Insert(constructor(
                        item.Type
                      , item.List
                      , HasProp(item, 'Positive') ? item.Positive : unset
                      , HasProp(item, 'Negative') ? item.Negative : unset
                      , HasProp(item, 'AddToDefault') ? item.AddToDefault : unset
                    ))
                }
            }
        }
        if IsSet(DefaultItem) {
            if IsObject(DefaultItem) {
                if not DefaultItem is PropsInfoTree_PropsTypeMap.Item {
                    DefaultItem := constructor(
                        ''
                      , DefaultItem.List
                      , HasProp(DefaultItem, 'Positive') ? DefaultItem.Positive : unset
                      , HasProp(DefaultItem, 'Negative') ? DefaultItem.Negative : unset
                    )
                }
            } else {
                DefaultItem := PropsInfoTree_PropsTypeMap.Item('', DefaultItem)
            }
            this.Default := DefaultItem
            defaultList := LTrim(DefaultItem.List, ',')
            for item in this {
                if item.AddToDefault {
                    item.List .= defaultList
                }
            }
        }
        if IsSet(CallbackType) {
            this.DefineProp('CallbackType', { Value: CallbackType })
        }
        if this.CallbackType is Array {
            this.DefineProp('Call', PropsInfoTree_PropsTypeMap.Prototype.GetOwnPropDesc('__Call_Array'))
        }
    }
    Call(node, &OutCallbackProcess, *) {
        if !this.Find(this.CallbackType.Call(node.Value), &OutCallbackProcess) && this.Default {
            OutCallbackProcess := this.Default
        }
    }
    __Call_Array(node, &OutCallbackProcess, *) {
        for callback in this.CallbackType {
            if this.Find(callback(node.Value), &OutCallbackProcess) {
                return
            }
        }
        if this.Default {
            OutCallbackProcess := this.Default
        }
    }

    class Item {
        /**
         * The "Call" method is overridden depending on the values of `Positive` and `Negative.
         *
         * - If `Positive` is set
         *   - If `Negative` is set
         *     - "Call" is overridden with "__Call_Both", which returns the respective values
         *       appropriately.
         *   - If `Negative` is not set
         *     - If `Positive` is nonzero
         *       - "Call" is overridden with "__Call_Positive1" which returns `Positive` when the
         *         string is found in `List`, and returns 0 when the string is not found in `List`.
         *     - If `Positive` is zero or an empty string
         *       - "Call" is overridden with "__Call_Positive2" which returns `Positive` when the
         *         string is found in `List`, and returns 1 when the string is not found in `List`.
         * - If `Positive` is not set
         *   - If `Negative` is set
         *     - If `Negative` is nonzero
         *       - "Call" is overridden with "__Call_Negative1" which returns `Negative` when the
         *         string is not found in `List`, and returns 0 when the string is found in `List`.
         *     - If `Negative` is zero or an empty string
         *       - "Call" is overridden with "__Call_Negative2" which returns `Negative` when the
         *         string is not found in `List`, and returns 1 when the string is found in `List`.
         *   - If `Negative` is not set
         *     - "Call" is not overridden. "Call" returns `InStr(this.List, ',' Str ',')`.
         *
         * @param {String} Type - The object type to associate with this item.
         * @param {String} List - The comma-separated list of properties to associate with this item,
         * e.g. "__Class,Prototype,Count".
         * @param {*} [Positive] - The value to return when the object is called with a string that
         * is present in `List`.
         * @param {*} [Negative] - The value to return when the object is called with a string that
         * is not present in `List`.
         * @param {Boolean} [AddToDefault = false] - If true, when
         * {@link PropsInfoTree_PropsTypeMap.Prototype.__New} process the item, if parameter
         * {@link PropsInfoTree_PropsTypeMap.Prototype.__New~DefaultItem DefaultItem} is set,
         * the default list of properties are appended to this item's list. This is ignored for
         * the default item itself.
         */
        __New(Type, List, Positive?, Negative?, AddToDefault := false) {
            this.Type := Type
            this.List := ',' List ','
            this.AddToDefault := AddToDefault
            proto := PropsInfoTree_PropsTypeMap.Item.Prototype
            if IsSet(Positive) {
                this.Positive := Positive
                if IsSet(Negative) {
                    this.Negative := Negative
                    this.DefineProp('Call', proto.GetOwnPropDesc('__Call_Both'))
                } else if Positive {
                    this.DefineProp('Call', proto.GetOwnPropDesc('__Call_Positive1'))
                } else {
                    this.DefineProp('Call', proto.GetOwnPropDesc('__Call_Positive2'))
                }
            } else if IsSet(Negative) {
                this.Negative := Negative
                if Negative {
                    this.DefineProp('Call', proto.GetOwnPropDesc('__Call_Negative1'))
                } else {
                    this.DefineProp('Call', proto.GetOwnPropDesc('__Call_Negative2'))
                }
            }
        }
        Call(InfoItem, *) {
            return InStr(this.List, ',' InfoItem.Name ',')
        }
        Add(Str) {
            return this.List .= Str ','
        }
        Remove(Str) {
            return this.List := RegExReplace(this.List, 'iS),\Q' Str '\E(?=,)', '')
        }
        Replace(Old, New) {
            return this.List := RegExReplace(this.List, 'iS)(?<=,)\Q' Old '\E(?=,)', New)
        }
        __Call_Both(InfoItem, *) {
            return InStr(this.List, ',' InfoItem.Name ',') ? this.Positive : this.Negative
        }
        __Call_Negative1(InfoItem, *) {
            return InStr(this.List, ',' InfoItem.Name ',') ? 0 : this.Negative
        }
        __Call_Negative2(InfoItem, *) {
            return InStr(this.List, ',' InfoItem.Name ',') ? 1 : this.Negative
        }
        __Call_Positive1(InfoItem, *) {
            return InStr(this.List, ',' InfoItem.Name ',') ? this.Positive : 0
        }
        __Call_Positive2(InfoItem, *) {
            return InStr(this.List, ',' InfoItem.Name ',') ? this.Positive : 1
        }

        List2 => Trim(this.List, ',')
    }
}


class PropsInfoTree extends TreeViewEx {
    static __New() {
        this.DeleteProp('__New')
        nodeTypes := this.NodeTypes := []
        nodeTypes.Length := PROPSINFOTREE_NODETYPE_END
        nodeTypes[PROPSINFOTREE_NODETYPE_BASE] := { Name: 'Base', Class: PropsInfoTree_Node_Base }
        nodeTypes[PROPSINFOTREE_NODETYPE_CALL] := { Name: 'Call', Class: PropsInfoTree_Node_Call }
        nodeTypes[PROPSINFOTREE_NODETYPE_CALLGROUP] := { Name: 'CallGroup', Class: PropsInfoTree_Node_CallGroup }
        nodeTypes[PROPSINFOTREE_NODETYPE_COMVALUE] := { Name: 'ComValue', Class: PropsInfoTree_Node_ComValue }
        nodeTypes[PROPSINFOTREE_NODETYPE_DYNAMIC] := { Name: 'Dynamic', Class: PropsInfoTree_Node_Dynamic }
        nodeTypes[PROPSINFOTREE_NODETYPE_DYNAMICGROUP] := { Name: 'DynamicGroup', Class: PropsInfoTree_Node_DynamicGroup }
        nodeTypes[PROPSINFOTREE_NODETYPE_ENUMERROR] := { Name: 'EnumError', Class: PropsInfoTree_Node_EnumError }
        nodeTypes[PROPSINFOTREE_NODETYPE_ENUMGROUP] := { Name: 'EnumGroup', Class: PropsInfoTree_Node_EnumGroup }
        nodeTypes[PROPSINFOTREE_NODETYPE_ERROR] := { Name: 'Error', Class: PropsInfoTree_Node_Error }
        nodeTypes[PROPSINFOTREE_NODETYPE_GET] := { Name: 'Get', Class: PropsInfoTree_Node_Get }
        nodeTypes[PROPSINFOTREE_NODETYPE_GETGROUP] := { Name: 'GetGroup', Class: PropsInfoTree_Node_GetGroup }
        nodeTypes[PROPSINFOTREE_NODETYPE_NUMBER] := { Name: 'Number', Class: PropsInfoTree_Node_Number }
        nodeTypes[PROPSINFOTREE_NODETYPE_OBJECT] := { Name: 'Object', Class: PropsInfoTree_Node_Object }
        nodeTypes[PROPSINFOTREE_NODETYPE_ROOT] := { Name: 'Root', Class: PropsInfoTree_Node_Root }
        nodeTypes[PROPSINFOTREE_NODETYPE_SET] := { Name: 'Set', Class: PropsInfoTree_Node_Set }
        nodeTypes[PROPSINFOTREE_NODETYPE_SETGROUP] := { Name: 'SetGroup', Class: PropsInfoTree_Node_SetGroup }
        nodeTypes[PROPSINFOTREE_NODETYPE_STRING] := { Name: 'String', Class: PropsInfoTree_Node_String }
        nodeTypes[PROPSINFOTREE_NODETYPE_UNSETARRAYITEM] := { Name: 'UnsetArrayItem', Class: PropsInfoTree_Node_UnsetArrayItem }
        nodeTypes[PROPSINFOTREE_NODETYPE_VALUE] := { Name: 'Value', Class: PropsInfoTree_Node_Value }
    }
    /**
     * The reason for doing this is to make it possible to make changes to all node objects
     * associated with just this {@link PropsInfoTree} at the same time, without influencing
     * any other node objects NOT associated with this.
     *
     * If you change the font size of the tree-view control, and if you use NormalizeKeyExtent = 2 / 3,
     * call PropsInfoTreeOptions.SetSpaceExtentList.
     *
     * @param {Map} [PropsInfoOptions.CallbackLabelTypeMap] - If set, a `Map` object where the
     * key is an object type string (see section "Type maps" in README.md for details) and the
     * value is a `Func` or callable object that returns the string to use as the tree-view item's
     * label.
     * - Parameters:
     *   1. The value associated with the tree-view item.
     *   2. The node object associated with the tree-view item.
     * - Returns {String} - The string to use as the label.
     *
     * @param {Integer} [PropsInfoTreeOptions.NormalizeKeyExtent = 0] - This option changes the
     * formatting of the tree-view item label for nodes that are associated with values returned
     * by an object's enumerator, e.g. map items of array items. The default label format for these
     * is:
     * <pre>
     * [ key ] = <Type> ... remaining details
     * </pre>
     *
     * This option changes just the "key" portion of the label. For array objects, the "key" is the
     * array item index. The valid values are:
     * - 0 : Do not adjust the width of the key.
     * - 1 : Normalize the width of the key using number of characters.
     * - 2 : Normalize the width of the key using extent point (width in pixels).
     * - 3 : Normalize the width of the key using extent point (width in pixels) and also cache
     *   the {@link TreeViewEx_Size} objects for each key.
     *
     * If using a monospaced font, 1 is an effective option to normalize the width. If not using
     * a monospaced font, 2 and 3 will normalize the width by measuring the strings and
     * padding the labels with extra space characters. See {@link TreeViewEx_GetSpaceExtentList}.
     *
     * You can use this option if using a custom label callback;
     * {@link PropsInfoTree_Node_Object.Prototype.AddChildren} will measure the keys for each item,
     * and the result of this is cached on property {@link PropsInfoTree_Node_Object#KeyWidthChar}
     * or {@link PropsInfoTree_Node_Object#KeyWidthExtent} or the parent node (the node that was
     * expanded), respectively. The values of these properties are an object with properties:
     * - count - The number of items returned by the enumeraetor.
     * - extent - If `PropsInfoTreeOptions.NormalizeKeyExtent = 3`, a map object where the key is
     *   the key and the value is the {@link TreeViewEx_Size} object. For other values, "extent"
     *   is an empty string.
     * - max - The greatest width / extent of all of the item keys.
     * - min - The smallest width / extent of all of the item keys.
     * - sum - The sum of the width / extent of all of the item keys.
     */
    __New(GuiObj, TreeViewExOptions?, PropsInfoTreeOptions?) {
        super.__New(GuiObj, TreeViewExOptions ?? unset)
        propsInfoTreeOptions := this.PropsInfoTreeOptions := PropsInfoTree.Options(this, PropsInfoTreeOptions ?? unset)
        ; General insert item template
        struct := TvInsertStruct()
        struct.cChildren := I_CHILDRENCALLBACK
        struct.pszText := LPSTR_TEXTCALLBACKW
        struct.mask := TVIF_CHILDREN | TVIF_TEXT | TVIF_PARAM
        ; Always set hParent and hInsertAfter before using this template
        struct.hParent := 0
        struct.hInsertAfter := TVI_LAST
        this.AddTemplate('insert', struct)
        ; Insert with static children template
        struct := struct.Clone()
        struct.cChildren := 1
        this.AddTemplate('insert static children', struct)
        ; Insert root template
        struct := struct.Clone()
        struct.hInsertAfter := TVI_ROOT
        struct.hParent := 0
        this.AddTemplate('insert root', struct)
        this.OnNotify(TVN_DELETEITEMW, TreeViewEx_HandlerDeleteItem_Node_Ptr)
        this.OnNotify(TVN_GETDISPINFOW, TreeViewEx_HandlerGetDispInfo_Node_Ptr)
        this.OnNotify(TVN_ITEMEXPANDEDW, TreeViewEx_HandlerItemExpanded_Node_Ptr)
        this.OnNotify(TVN_ITEMEXPANDINGW, TreeViewEx_HandlerItemExpanding_Node_Ptr)
        this.OnNotify(NM_CLICK, TreeViewEx_OnClick)
    }
    /**
     * @param {PropsInfoTree_Node} Node - The node object.
     *
     * @param {String|TvInsertStruct} [Struct = "insert"] - An instance of {@link TvInsertStruct}
     * that is sent with TVM_INSERTITEMW, or the key associated with the {@link TvInsertStruct}
     * object to retrieve from {@link TreeViewEx#Templates}.
     */
    AddNode2(Node, Struct := 'insert') {
        global g_TreeViewEx_Node := Node
        if !IsObject(Struct) {
            Struct := this.Templates.Get(Struct)
        }
        Struct.lParam := ObjPtrAddRef(Node)
        if this.PropsInfoTreeOptions.__CallbackBold {
            if this.PropsInfoTreeOptions.__CallbackBold.Call(Node) {
                Struct.mask := Struct.mask | TVIF_STATE
                Struct.state := Struct.state | TVIS_BOLD
                Struct.stateMask := Struct.stateMask | TVIS_BOLD
            } else {
                Struct.mask := Struct.mask & ~TVIF_STATE
                Struct.state := Struct.state & ~TVIS_BOLD
                Struct.stateMask := Struct.stateMask & ~TVIS_BOLD
            }
        }
        if Node.handle := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
            g_TreeViewEx_Node := ''
        } else {
            throw Error('Sending ``TVM_INSERTITEMW`` failed.')
        }
    }
    /**
     * @description - Similar to {@link PropsInfoTree.Prototype.AddNode2} except the pszText
     * member is always set with {@link PropsInfoTree_Node_Object#Label}.
     * @param {PropsInfoTree_Node} Node - The node object.
     *
     * @param {String|TvInsertStruct} [Struct = "insert"] - An instance of {@link TvInsertStruct}
     * that is sent with TVM_INSERTITEMW, or the key associated with the {@link TvInsertStruct}
     * object to retrieve from {@link TreeViewEx#Templates}.
     */
    AddNode3(Node, Struct := 'insert') {
        global g_TreeViewEx_Node := Node
        if !IsObject(Struct) {
            Struct := this.Templates.Get(Struct)
        }
        Struct := Struct.Clone()
        Struct.lParam := ObjPtrAddRef(Node)
        Struct.SetTextBuffer()
        Struct.mask := Struct.mask | TVIF_TEXT
        Struct.pszText := node.Label
        if this.PropsInfoTreeOptions.__CallbackBold {
            if this.PropsInfoTreeOptions.__CallbackBold.Call(Node) {
                Struct.mask := Struct.mask | TVIF_STATE
                Struct.state := Struct.state | TVIS_BOLD
                Struct.stateMask := Struct.stateMask | TVIS_BOLD
            } else {
                Struct.mask := Struct.mask & ~TVIF_STATE
                Struct.state := Struct.state & ~TVIS_BOLD
                Struct.stateMask := Struct.stateMask & ~TVIS_BOLD
            }
        }
        if Node.handle := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
            g_TreeViewEx_Node := ''
        } else {
            throw Error('Sending ``TVM_INSERTITEMW`` failed.')
        }
    }
    /**
     * @param {*} Value - The value to associate with the node.
     *
     * @param {String} [Name] - The name to assign to the node. This is displayed with the tree-view
     * item's label and is used as the root of the object path. If unset, the return value from
     * `Type(Value)` is used.
     *
     * @param {String|TvInsertStruct} [Struct = "insert root"] - An instance of {@link TvInsertStruct}
     * that is sent with TVM_INSERTITEMW, or the key associated with the {@link TvInsertStruct}
     * object to retrieve from {@link TreeViewEx#Templates}.
     */
    AddRootNode(Value, Name?, Struct := 'insert root') {
        global g_TreeViewEx_Node
        if !IsObject(Struct) {
            Struct := this.Templates.Get(Struct)
        }
        g_TreeViewEx_Node := this.NodeConstructor_Root.Call(PathObj(Name ?? Type(Value)), Value)
        node := g_TreeViewEx_Node
        Struct.lParam := ObjPtrAddRef(Node)
        if this.PropsInfoTreeOptions.__CallbackBold {
            if this.PropsInfoTreeOptions.__CallbackBold.Call(Node) {
                Struct.mask := Struct.mask | TVIF_STATE
                Struct.state := Struct.state | TVIS_BOLD
                Struct.stateMask := Struct.stateMask | TVIS_BOLD
            } else {
                Struct.mask := Struct.mask & ~TVIF_STATE
                Struct.state := Struct.state & ~TVIS_BOLD
                Struct.stateMask := Struct.stateMask & ~TVIS_BOLD
            }
        }
        if node.Handle := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
            g_TreeViewEx_Node := ''
            return node
        } else {
            throw OSError()
        }
    }
    AddRootNode2(Node, Struct := 'insert root') {
        global g_TreeViewEx_Node := Node
        if !IsObject(Struct) {
            Struct := this.Templates.Get(Struct)
        }
        Struct.lParam := ObjPtrAddRef(Node)
        if this.PropsInfoTreeOptions.__CallbackBold {
            if this.PropsInfoTreeOptions.__CallbackBold.Call(Node) {
                Struct.mask := Struct.mask | TVIF_STATE
                Struct.state := Struct.state | TVIS_BOLD
                Struct.stateMask := Struct.stateMask | TVIS_BOLD
            } else {
                Struct.mask := Struct.mask & ~TVIF_STATE
                Struct.state := Struct.state & ~TVIS_BOLD
                Struct.stateMask := Struct.stateMask & ~TVIS_BOLD
            }
        }
        if node.Handle := SendMessage(TVM_INSERTITEMW, 0, Struct.Ptr, this.Hwnd) {
            g_TreeViewEx_Node := ''
        } else {
            throw OSError()
        }
    }
    GetConstructor(NodeType) {
        return this.NodeConstructor_%PropsInfoTree.NodeTypes[NodeType].Name%
    }
    class Options {
        static __New() {
            this.DeleteProp('__New')
            PropsInfoTree_SetConstants()
            proto := this.Prototype
            proto.__AutoUpdate := true
            proto.__BaseProp := false
            proto.__CallAccessors := true
            ; Called when children are being added for an object's enumerator
            ; (Get the array of objects with properties "InfoItem" {PropsInfoItem} and "Value" {*}
            ; from property "EnumList" from the node object)
            ; params: {PropsInfoTree_Node}, {VarRef} CallbackProcess, {VarRef} CallbackEnd
            ; CallbackProcess: {PropsInfoTree_Node} added node, {Integer} index.
            ; CallbackEnd: {PropsInfoTree_Node} parent node (original node passed to callback).
            proto.__CallbackAddChildrenEnum := ''
            ; Called when children are being added for an object's properties
            ; (Get the array of objects with properties "InfoItem" {PropsInfoItem} and "Value" {*}
            ; from property "PropsList" from the node object)
            ; params: {PropsInfoTree_Node}, {VarRef} CallbackProcess, {VarRef} CallbackEnd
            ; CallbackProcess: {PropsInfoTree_Node} added node, {Integer} index.
            ; CallbackEnd: {PropsInfoTree_Node} parent node (original node passed to callback).
            proto.__CallbackAddChildrenProps := ''
            proto.__CallbackBold := ''
            proto.__CallbackDelete := ''
            proto.__CallbackCallEnum := PropsInfoTree_CallbackCallEnum
            ; params: {PropsInfoTree_Node}, {VarRef} CallbackProcess, {VarRef} CallbackEnd
            ; The function can return nonzero to skip the enumerator altogether.
            ; CallbackProcess: {VarRef} Key, {VarRef} Value, {PropsInfoTree_Node}; and returns nonzero to skip the property
            ; CallbackEnd is called right before the function returns with {PropsInfoTree_Node}.
            proto.__CallbackEnumProcess := ''
            proto.__CallbackGetPropsInfoParams := ''
            proto.__CallbackGetImage := ''
            proto.__CallbackGetSelectedImage := ''
            proto.__CallbackPreview := ''
            proto.__CallbackPreviewProps := ''
            ; params: {PropsInfoTree_Node}, {VarRef} CallbackProcess, {VarRef} CallbackEnd
            ; The function can return nonzero to skip the properties altogether.
            ; CallbackProcess accepts a {PropsInfoItem}, {PropsInfoTree_Node}; and returns nonzero to skip the property
            ; CallbackEnd is called right before the function returns with {PropsInfoTree_Node}.
            proto.__CallbackProcessProps := ''
            proto.__CallbackProps := ''
            proto.__CallbackSetNodeConstructor := PropsInfoTree_SetNodeConstructor
            proto.__CombineAccessorTypes := false
            proto.__ContextMenu := true
            proto.__DeleteOnCollapse := false
            proto.__DI_SETITEM := true
            proto.__EnumErrors := false
            proto.__GetAccessors := true
            proto.__LabelMaxChars := 300
            proto.__NodeClass := PropsInfoTree_Node
            proto.__NormalizeKeyExtent := false
            ; Max pixels for a key when Options.NormalizeKeyExtent is 2.
            proto.__MaxKeyWidthExtent := 350
            ; Max chars for key. Ignored when MaxKeyWidthExtent is applied.
            proto.__PreviewItemMaxChars := 70
            proto.__PreviewItemMaxChars := 50
            proto.__PreviewMaxChars := 200
            proto.__PropertyErrors := false
            proto.__Props := true
            proto.__PropsInfoParams := ''
            proto.__PropValues := true
            proto.__SetAccessors := true
            proto.__ShowOwnerIndex := false
        }
        __New(pit, propsInfoTreeOptions?) {
            this.HwndCtrl := pit.Hwnd
            if IsSet(propsInfoTreeOptions) {
                for prop in this.Base.OwnProps() {
                    prop := SubStr(prop, 3)
                    if HasProp(propsInfoTreeOptions, prop) {
                        this.__%prop% := propsInfoTreeOptions.%prop%
                    }
                }
            }
            if this.__ContextMenu {
                pit.SetContextMenu(IsObject(this.__ContextMenu) ? this.__ContextMenu : PropsInfoTree_ContextMenu())
            }
            if this.__PropsInfoParams {
                if not this.__PropsInfoParams is PropsInfo.Options {
                    this.__PropsInfoParams := PropsInfo.Options(this.__PropsInfoParams)
                }
                if this.__PropsInfoParams.BaseProp {
                    throw ValueError('``PropsInfoTreeOptions.PropsInfoParams.BaseProp`` must be ``false``;'
                    ' to include a tree-view item for the "Base" property, set ``PropsInfoTreeOptions.BaseProp`` instead.')
                }
            } else {
                this.__PropsInfoParams := PropsInfo.Options({
                    Call: this.__CallAccessors
                  , Get: this.__GetAccessors || this.__PropValues
                  , Set: this.__SetAccessors
                  , Value: this.__PropValues
                })
            }
            pit.SetNodeConstructor(this.__NodeClass)
            this.__CallbackSetNodeConstructor.Call(pit, this)
        }
        GetPropsInfo(node) {
            if (this.__CallbackProps && this.__CallbackProps.Call(node)) || !this.__Props {
                return
            }
            if this.__CallbackGetPropsInfoParams {
                this.__CallbackGetPropsInfoParams.Call(node, this.__PropsInfoParams)
            }
            if this.__PropsInfoParams.BaseProp {
                throw ValueError('``PropsInfoTreeOptions.PropsInfoParams.BaseProp`` must be ``false``;'
                ' to include a tree-view item for the "Base" property, set ``PropsInfoTreeOptions.BaseProp`` instead.')
            }
            return GetPropsInfoEx(node.Value, this.__PropsInfoParams, true)
        }
        /**
         * @param {*} Callback - The function to call.
         * - Parameters:
         *   1. The node object.
         * - Returns: The string label.
         *
         * If zero or an empty string, reverts any previously applied callbacks.
         *
         * @param {Integer|Integer[]} [NodeType] - If set, either a node type integer or an array of node type
         * integers. If unset, `Callback` will be applied to all node types.
         *
         * @throws {PropertyError} - "The property "Label" has not been defined on the prototype for the
         * indicated node type." This is thrown if the function is called with `Callback` set with zero
         * or an empty string, and if there was no previously active callback for a node type EXCEPT
         * if `NodeType` was left unset. If `NodeType` was left unset, then the function suppresses this
         * error. This is to allow the caller to call the function to remove all previously set callbacks
         * indiscriminately.
         */
        SetCallbackLabel(Callback, NodeType?) {
            if IsSet(NodeType) {
                if not NodeType is Array {
                    NodeType := [ NodeType ]
                }
                flag_suppress_propertyError := false
            } else {
                NodeType := []
                NodeType.Capacity := PROPSINFOTREE_NODETYPE_END
                loop PROPSINFOTREE_NODETYPE_END {
                    NodeType.Push(A_Index)
                }
                flag_suppress_propertyError := true
            }
            pit := this.Ctrl
            if Callback {
                for nt in NodeType {
                    pit.NodeConstructor_%PropsInfoTree.NodeTypes[nt].Name%.Prototype.DefineProp('Label', { Get: Callback })
                }
            ; If `Callback` is zero or an empty string, then we are to reset the "Label" property to
            ; its original state.
            } else {
                for nt in NodeType {
                    protoInheritor := pit.NodeConstructor_%PropsInfoTree.NodeTypes[nt].Name%.Prototype
                    protoBase := PropsInfoTree.NodeTypes[nt].Class.Prototype
                    ; If the original class prototype owns a property "Label"
                    if protoBase.HasOwnProp('Label') {
                        ; Define "Label" using the original
                        protoInheritor.DefineProp('Label', protoBase.GetOwnPropDesc('Label'))
                    ; If the original class prototype does not own a property "Label", that would imply
                    ; that our prototype owns a property "Label" which overrides an inherited property.
                    } else if protoInheritor.HasOwnProp('Label') {
                        ; Delete the override
                        protoInheritor.DeleteProp('Label')
                    ; If we get here, that means PropsInfoTree.Prototype.SetCallbackLabel has not been
                    ; called to set the "Label" property for the indicated node type, and so there
                    ; is nothing to reset.
                    } else if !flag_suppress_propertyError {
                        throw PropertyError('The property "Label" has not been defined on the prototype for the indicated node type.', , 'Node type: ' nt)
                    }
                }
            }
        }
        SetSpaceExtentList() {
            context := TreeViewEx_SelectFontIntoDc(this.HwndCtrl)
            this.DefineProp('SpaceExtentList', { Value: TreeViewEx_GetSpaceExtentList(context.hdc, false) })
            context()
            return this.SpaceExtentList
        }

        Accessors => this.__CallAccessors || this.__GetAccessors || this.__SetAccessors
        Ctrl => TreeViewEx.Get(this.HwndCtrl)
        SpaceExtentList => this.SetSpaceExtentList()
    }

}

class BringYourOwnObject {
    static __New() {
        this.DeleteProp('__New')
        if PropsInfoTree {
        }
    }
    /**
     * @description -
     * This demo enables you to pass any object to the demo constructor to see how PropsInfoTree works.
     *
     * To run this demo, simply #include this file in an external script that has an object you want to
     * explore, then pass that object to `Demo.Call`. This demo handles the rest.
     *
     * @example
     * #include C:\path\to\this\demo-BringYourOwnObject.ahk
     * obj := YourObjectConstructor()
     * BringYourOwnObject(obj)
     * @
     *
     * I recommend trying it with a UIA.IUIAutomationElement
     *
     * @example
     * #include C:\path\to\this\demo-BringYourOwnObject.ahk
     * #include <UIA>
     * elDesktop := UIA.GetRootElement()
     * BringYourOwnObject(elDesktop)
     * @
     *
     * All of the dependencies have been packaged together for convenience running this demo script.
     * If you decide you have a use for the library, I would recommend cloning
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-TreeViewEx?tab=readme-ov-file#getting-started TreeViewEx}
     * and its dependencies to ensure your copies stay up-to-date.
     *
     * @param {*} [Obj] - The object to explore visually using a tree-view control. You can omit
     * this parameter if you set `Options.DeferAddControl := true`.
     *
     * @param {Object|BringYourOwnObject.Options} - An object with options as property : value pairs,
     * or an {@link BringYourOwnObject.Options} object.
     *
     * @param {Object} [Options.AddOptions = { TreeViewClass: PropsInfoTree }] - An object with
     * {@link TreeViewEx_Tab.Prototype.Add} options as property : value pairs. If you set
     * `Options.AddOptions`, this will overwrite "TreeViewClass".
     *
     * @param {*} [Options.CallbackGui] - A `Func` or callable object. The function will receive the
     * gui object as a parameter, and the return value is ignored. This is called before
     * {@link BringYourOwnObject} adds anything to the gui. If you add controls to the window, you
     * should modify `Options.TvexTabOptions.Opt` to specify where the tab control should be placed,
     * e.g. `Options.TvexTabOptions.Opt := "x10 y200 w1100 r15"`. You should only place controls
     * above the tab control. If you place anything below the tab control, when the window is
     * resized to be larger vertically, your controls will be overlapped by the tab control.
     *
     * @param {Boolean} [Options.DeferAddControl = false] - If true, the {@link TreeViewEx} control
     * is not added to the window. Your code must call {@link BringYourOwnObject.Prototype.Add}
     * to add the control. If `Options.DeferAddControl` is nonzero, `Obj` is ignored. Calling
     * {@link BringYourOwnObject.Prototype.Add} automatically shows the window if it is hidden.
     *
     * @param {String} [Options.FaceName = "Segoe Ui"] - The font name to pass to `Gui.Prototype.SetFont`.
     *
     * @param {String} [Options.FontOpt = "s11 q5"] - The options to pass to `Gui.Prototype.SetFont`.
     *
     * @param {String} [Options.GuiOpt = "+Resize"] - The options to pass to `Gui`.
     *
     * @param {String} [Options.Name = "BringYourOwnObject"] - The name to display in the tab control's tab.
     *
     * @param {Object} [Options.PropsInfoTreeOptions] - An object with PropsInfoTree options as property : value pairs.
     *
     * @param {Boolean} [Options.Show = true] - If nonzero, the gui window is shown. If false, your
     * code must call {@link BringYourOwnObject#Gui.Show}.
     *
     * @param {Object} [Options.TvexOptions = { TreeViewClass: PropsInfoTree }] - An object with
     * {@link TreeViewEx} options as property : value pairs. If you set `Options.TvexOptions`, this will
     * overwrite "TreeViewClass".
     *
     * @param {Object} [Options.TvexTabOptions] - An object with TreeViewEx_Tab options as property : value pairs.
     * The default options are:
     * ```
     * {
     *     opt: 'w1000 r25'
     *   , CallbackDelete: Demo_CallbackDelete
     *   , CallbackOnChangeAfter: Demo_CallbackOnChange
     *   , Which: 'Tab2'
     *   , DefaultPropsInfoTreeOptions: pitOpt
     * }
     * ```
     *
     * If you set `Options.TvexTabOptions`, this will overwrite "CallbackDelete", "CallbackOnChangeAfter",
     * and "Which", and "DefaultPropsInfoTreeOptions" (if present) with the above values, as they
     * are required for functioning. "DefaultPropsInfoTreeOptions" is set with the value passed to
     * `Options.PropsInfoTreeOptions`, if set.
     */
    __New(Obj?, Options?) {
        options := this.Options := BringYourOwnObject.Options(Options ?? unset)
        g := Gui(options.GuiOpt)
        this.HwndGui := g.Hwnd
        g.SetFont(options.FontOpt, options.FaceName)
        if options.PropsInfoTreeOptions {
            pitOpt := options.PropsInfoTreeOptions
        } else {
            pitOpt := options.PropsInfoTreeOptions := {
                NormalizeKeyExtent: 2
              , ShowOwnerIndex: false
            }
        }
        if options.TvexTabOptions {
            tvexTabOpt := options.TvexTabOptions
            tvexTabOpt.CallbackDelete := Demo_CallbackDelete
            tvexTabOpt.CallbackOnChangeAfter := Demo_CallbackOnChange
            tvexTabOpt.Which := 'Tab2'
            tvexTabOpt.DefaultPropsInfoTreeOptions := pitOpt
        } else {
            tvexTabOpt := options.TvexTabOptions := {
                Opt: 'w1000 r25'
              , CallbackDelete: Demo_CallbackDelete
              , CallbackOnChangeAfter: Demo_CallbackOnChange
              , Which: 'Tab2'
              , DefaultPropsInfoTreeOptions: pitOpt
            }
        }
        if options.TvexOptions {
            tvexOpt := options.TvexOptions
        } else {
            tvexOpt := options.TvexOptions := { AddStyle: TVS_NOTOOLTIPS }
        }
        if options.AddOptions {
            addOpt := options.AddOptions
            addOpt.TreeViewClass := PropsInfoTree
        } else {
            addOpt := options.AddOptions := { TreeViewClass: PropsInfoTree }
        }
        ; Limit the recursion depth when seleceting "Expand all recursive" from the context menu.
        global TVEX_MAX_RECURSION := 4
        if options.CallbackGui {
            options.CallbackGui.Call(g)
        }
        tvexTab := this.TvexTab := TreeViewEx_Tab(g, tvexTabOpt, addOpt, tvexOpt)
        rc := tvexTab.Tab.GetClientWindowRect()
        btn := g.Add('Button', 'x' g.MarginX ' y' (rc.B + g.MarginY) ' Section', 'Exit')
        btn.OnEvent('Click', (*) => ExitApp())
        resizerObj := { Y: 1 }
        btn.Resizer := resizerObj
        btn := g.Add('Button', 'ys', 'Reload')
        btn.OnEvent('Click', (*) => Reload())
        btn.Resizer := resizerObj
        tvexTab.Tab.Resizer := { W: 1, H: 1 }
        if options.Show {
            g.Show(options.GuiShowOpt || unset)
        }
        this.Added := false
        if !options.DeferAddControl {
            this.Add(Obj)
        }
    }
    /**
     * @description - Creates a new tab, adds a {@link PropsInfoTree} control, and shows the window.
     * @param {*} Obj - The object to associate with a {@link PropsInfoTree} control.
     */
    Add(Obj) {
        tvexTab := this.TvexTab
        options := this.Options
        item := tvexTab.Add(options.Name)
        pit := item.tvex
        tvexTab.PropsInfoTreeContextMenu.RegisterTreeViewExTab(pit.Hwnd, tvexTab, Demo_ContextMenu_AddAsNewTab, Demo_ContextMenu_DeleteTab)
        pit.AddRootNode(Obj, options.Name)
        pit.Resizer := { W: 1, H: 1 }
        if this.Added {
            this.controls.Push(pit)
            this.Gui.resizer.Activate(this.controls)
        } else {
            lf := pit.GetFont()
            if RegExMatch(options.FontOpt, 's(\d+)', &m) {
                lf.FontSize := m[1]
            } else {
                lf.FontSize := 11
            }
            if RegExMatch(options.FontOpt, 'q(\d+)', &m) {
                lf.Quality := m[1]
            } else {
                lf.Quality := 5
            }
            lf.FaceName := options.FaceName || 'Segoe Ui'
            lf.Apply()
            this.controls := [ pit ]
            if !DllCall('IsWindowVisible', 'ptr', this.HwndGui, 'int') {
                this.Gui.Show()
            }
            this.Gui.resizer := GuiResizer(this.Gui, { NoDeferAll: true }, this.controls)
            this.Added := true
        }
    }
    Gui => GuiFromHwnd(this.HwndGui)

    class Options {
        static __New() {
            this.DeleteProp('__New')
            proto := this.Prototype
            proto.Name := 'BringYourOwnObject'
            proto.PropsInfoTreeOptions := ''
            proto.TvexTabOptions := ''
            proto.TvexOptions := ''
            proto.AddOptions := ''
            proto.CallbackGui := ''
            proto.GuiOpt := '+Resize'
            proto.GuiShowOpt := ''
            proto.FontOpt := 's11 q5'
            proto.FaceName := 'Segoe Ui'
            proto.DeferAddControl := false
            proto.Show := true
        }

        __New(options?) {
            if IsSet(options) {
                for prop in BringYourOwnObject.Options.Prototype.OwnProps() {
                    if HasProp(options, prop) {
                        this.%prop% := options.%prop%
                    }
                }
                if this.HasOwnProp('__Class') {
                    this.DeleteProp('__Class')
                }
            }
        }
    }

}


Demo_CallbackDelete(item, flag_isCurrentTab, *) {
    if flag_isCurrentTab {
        if item.tvex.Gui.Resizer.Status {
            item.tvex.Gui.Resizer.Deactivate()
        }
        for ctrl in BringYourOwnObject.controls {
            if item.HwndTvex = ctrl.Hwnd {
                BringYourOwnObject.controls.RemoveAt(A_Index)
                break
            }
        }
    }
    item.tvex.Dispose()
}

Demo_CallbackOnChange(tvexTab, formerActive, newlyActive) {
    resizer := BringYourOwnObject.g.resizer
    controls := BringYourOwnObject.controls
    for item in formerActive {
        for _item in controls {
            if item.HwndTvex = _item.Hwnd {
                controls.RemoveAt(A_Index)
                break
            }
        }
    }
    for item in newlyActive {
        controls.Push(item.tvex)
    }
    resizer.Activate(controls)
}

Demo_ContextMenu_AddAsNewTab(TvexTab, Node, *) {
    ; Get a PATHOBJ_TYPE_ROOT instance using the object's path
    path := node.Path.ToRoot()
    ; Add the tab and PropsInfoTree
    item := TvexTab.Add(path.Name)
    pit := item.tvex
    ; Create the node object using the constructor associated with the new PropsInfoTree instance
    node := pit.NodeConstructor_Root.Call(path, Node.Value)
    ; If using GuiResizer https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/GuiResizer.ahk
    ; I personally always cache the GuiResizer object as a property "Resizer" on the gui object,
    ; so for this condition to work, your code would need to do the same.
    if HasProp(TvexTab.Gui, 'Resizer') {
        pit.Resizer := { W: 1, H: 1 }
    }
    pit.AddNode3(node, 'insert root')
    ; Return the PropsInfoTree
    return pit
}

Demo_ContextMenu_DeleteTab(TvexTab, Pit) {
    tab := TvexTab.Tab
    TvexTab.DeleteTab(tab.Text)
    ; The GuiResizer gets reactivated in Demo_CallbackOnChange
}
